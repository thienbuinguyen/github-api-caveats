\chapter{Introduction}
\label{cha:intro}
An Application Programming Interface (API) provides a set of functions to interact with some software. However, APIs often contain numerous constraints that developers must follow for correct usage of a given API. Misuse of an API can lead to severe bugs for developers such as software failures. These constraints are documented by the developers of an API in their formal documentation, which are usually created manually by the API developers or automatically generated from source code comments such as with the Javadoc tool for the Java programming language. A recent study by \citeauthor{caveat-knowledge-graph} researched a particular subset of constraints that focused specifically on correct and incorrect API usage that are referred to as \textit{API caveats}. Furthermore, \citeauthor{caveat-knowledge-graph} proposed an extraction method for these API caveats at the sentence level by identifying common keywords between them, improving the accessibility of these API caveats. 
In addition to this, an approach by \citeauthor{jiamou} to simplify these API caveats for developers and improve understanding was proposed using Natural Language Processing (NLP) techniques. This involved using word/sentence embedding and comparing sentence similarity of sentence vectors across community text from Q/A forums such as Stack Overflow to link the API caveats with actual code examples. With this, API caveats are augmented with ``real'' code examples by developers that can help them understand how to use an API. However, this approach requires a large corpus of code examples alongside the assumption informal text by communities containing high lexical similarity to sentences of formal API documentation. Besides this, it also makes the assumption that text surrounding code examples are relevant to the code examples provided.
This thesis seeks to extend upon the word by \citeauthor{caveat-knowledge-graph, jiamou, xiaoxue} to investigate alternative methods of improving comprehension of API caveats. In particular, I focus on translating natural language of API caveats into code \textit{contracts} that can be used directly by program analysis tools to check for API misuse in real time. \\

\section{Motivation}
Suppose a new developer was starting their journey on learning Java programming. One of the first topics they might be interested in could be file handling (i.e. how to read a text file into their program). A common strategy to solve this problem involves using a search query on Google such as ``java how to read files''. The first search result of this is from GeeksforGeeks\footnote{https://www.geeksforgeeks.org/different-ways-reading-text-file-java/} that provides multiple examples for reading a file in Java. The first example described is shown in Listing  \ref{lst:code-example}. The next step a developer might take is to copy-paste the relevant section into their program (i.e. the code within \lstinline{main}). Finally, the developer might try to execute their modified program, but this would result in a \lstinline{FileNotFoundException} to be thrown. This is because the file path in the \lstinline{File} constructor call (line 11) has not been changed to the appropriate file path for the developer. In an integrated development environment (IDE) such as IntelliJ,  information about the exception such as which line the exception was thrown from will also be displayed. With further investigation, the developer will find a confounding result: IntelliJ reports the exception is not associated with the \lstinline{File} constructor line (where the file path is set), but with the \lstinline{FileReader} constructor in line 13. In other words, the file path appears to be accepted by \lstinline{File} but not by \lstinline{FileReader}. Searching for the reference documentation of these classes\footnote{FileReader: https://docs.oracle.com/javase/7/docs/api/java/io/FileReader.html \\\indent File: https://docs.oracle.com/javase/7/docs/api/java/io/File.html, the developer could find the reference documentation for both of these classes}. Specfically, the documentation of the relevant constructor for \lstinline{FileReader} says ``Throws: FileNotFoundException - if the file does not exist, is a directory rather than a regular file, or for some other reason cannot be opened for reading''. Furthermore, the documentation for the constructor of \lstinline{File} does not mention the consequences of an invalid path. Rather, the developer might notice that \lstinline{File} has an \lstinline{exists()} method that can be used to verify whether the file exists. Only then could the developer understand the source of the problem encountered alongside correct usage of both \lstinline{File} and \lstinline{FileReader} for reading files in Java applications.
Although the above example presents a contrived view of how a new developer would approach using a feature of an API for the first time, we observe the constraints associated with an API introduce a significant problem for all programmers that is best explained with the common phrase: ``you don't know what you don't know''. This indicates that the usage of an API requires considerable understanding of the different components involved alongside how its functions will behave in different scenarios. This is both time-consuming and a significant endeavour due to the number and size of APIs that exist across all programming languages and computer science fields.

\begin{lstlisting}[tabsize=4,caption={File reading java code example from GeeksforGeeks},label={lst:code-example}]
// Java Program to illustrate reading from FileReader 
// using BufferedReader 
import java.io.*; 
public class ReadFromFile2 
{ 
	public static void main(String[] args)throws Exception 
	{ 
		// We need to provide file path as the parameter: 
		// double backquote is to avoid compiler interpret words 
		// like \test as \t (ie. as a escape sequence) 
		File file = new File("C:\\Users\\pankaj\\Desktop\\test.txt"); 
		
		BufferedReader br = new BufferedReader(new FileReader(file)); 
		
		String st; 
		while ((st = br.readLine()) != null) 
		System.out.println(st); 
	} 
} 
\end{lstlisting}

\begin{enumerate}
	\item Provide 3 caveat examples from Java 12 API (ArrayList.subList, String.indexOf, HashMap concurrency)
\end{enumerate}

\section{Main Research Challenges}
\label{sec:mainresearchchallenges}
The primary goal of this thesis is the investigation of methods for linking API caveats to code. Ideally, this allows API misuse cases to be detected and help developers understand correct usage of a given API. Previous work has focused on an indirect approach of linking where caveats sentences would be matched to community text surrounding code examples on Q\&A websites such as Stack Overflow. This utilised NLP techniques involving sentence embedding to form information retrieval systems in which caveat sentences could be used as queries and code examples from the Q\&A websites would be retrieved. For this thesis, the original objective was to determine whether the same approach could be applied to a different domain that is not a Q\&A platform: GitHub. This is a complex task that mainly involves three components: (1) sentence embedding, (2) matching caveats to code examples, and (3) presenting code examples to developers. Sentence embedding is a modern approach in NLP that transforms sentences into vectors that retain semantic meaning \cite{palangi2016deep}. However, it typically requires complex models (such as neural networks) to learn important features of sentences. Matching caveats to code examples is non-trivial given the semantic/lexical gap that exists between natural language and programming code. An example of this in terms of API caveats is the sentence ``UnsupportedEncodingException - If the named charset is not supported'' from the Java 12 Documentation (method \lstinline{getBytes} of class \lstinline{java.lang.String}). It is obvious that developing a generalised representation of this that can be understood by computers is difficult. It requires both consideration of the context that ``charset'' refers to the parameter ``charsetName'', alongside what exactly denotes a supported ``charset''. The third component of presenting code examples refers to the problem of highlighting code examples in a succinct manner that also offers guidance towards correct API usage. The scope of this thesis is focused on the first and second component as experiments in \cite{jiamou} showed that even a simple Graphical User Interface (GUI) could help users understand API caveats. However, negative results were found using this approach and an alternative method was investigated. This resulted in additional research challenges involving sentence parsing and static code analysis.\\

Sentence parsing involves numerous problems in the process of interpreting meaning, requiring identification of individual words, contextual information, punctuation and subtle features such as intonation \cite{mitchell1994sentence}. Numerous fields exist simply to determine some properties of a sentence such as named entity recognition where to identify what entity a word refers to. An example of this from \cite{ratinov-roth-2009-design} is a news headline that reads ``SOCCER - PER BLINKER BAN LIFTED''. Without prior knowledge, it is difficult to discern that ``BLINKER'' refers to a person. It is therefore clear that parsing a sentence to understand different types of constraints alongside finding a generalised representation for these constraints is a difficult problem. This thesis extends upon the work by \cite{zhou-directive} that uses sentence normalisation (where specific words and phrases are substituted with labelled words) and from their heuristic rules to parse and extract the constraints of caveat sentences. The project scope for this approach is strictly based on applying the parsing techniques used and providing alternative methods of parsing. \\
Static code analysis involves examining the source code of programs before execution of the program \cite{baca2009static}. This is typically used to ``find bugs and reduce defects in a software application'' \cite{bardas2010static}, and has been found to be the best method for eliminating bugs. However, implementing static code analysers is non-trivial. Complex static analysis tools can detect vulnerabilities such as buffer overflows, but detection rates are not perfect and false positive alarms can be common \cite{zitser2004testing}. Furthermore, performance of these tools must also be considered as high complexity analysis requires more computation time. A major challenge is to then implement a static code analyser that can detect as many coding errors as possible without the minimal amount of computation time and resources. Overall, the scope of static code analysis involves usage of an existing API (IntelliJ's Program Structure Interface) to develop a plugin that analyses source code.

\section{Thesis Outline}
\label{sec:outline}
An overview of API caveats and the background of this thesis is described in Chapter \ref{cha:background}. Chapter \ref{cha:infoRetrieval} extends upon the work of \cite{jiamou} and \cite{xiaoxue} for linking API caveat sentences to code examples in a different domain: GitHub. However, due to the negative results found, a more direct approach is attempted with the idea of transforming the natural language from API caveats to code contracts in Chapter \ref{cha:codeAnalysis}. In Chapter \ref{cha:conc}, the findings of this thesis are discussed with remarks for future work.

\section{Main Contributions}
The main contributions of Chapter \ref{cha:infoRetrieval} is the discovery of a significant lexical gap for community text from GitHub and (Java 12) API caveat sentences. This impedes previous approaches used for linking API caveats to code examples.\\

\noindent
The main contributions of Chapter \ref{cha:codeAnalysis} are:
\begin{itemize}
	\item Parsing of a subset of API caveats that result in exceptions to formulate code contracts.
	\item A tool implementation that uses static code analysis to automatically check code contract compliance in real time.
\end{itemize}