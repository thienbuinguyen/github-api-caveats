\chapter{Introduction}
\label{cha:intro}
% Introduce API caveats
% Highlight entire story with the 3 examples
% Explore code analysis for API Caveats

An Application Programming Interface (API) provides a set of functions to interact with some software. However, APIs often contain numerous constraints that developers must abide for correct usage of a given API. Misuse of an API can lead to severe bugs for developers such as software failures. These constraints are documented by the developers of an API in their formal documentation, which are usually created manually by the API developers or automatically generated from source code comments such as with the Javadoc tool for the Java programming language. A recent study by \citeauthor{caveat-knowledge-graph} researched a particular subset of constraints that focused specifically on correct and incorrect API usage that are referred to as \textit{API caveats}. Furthermore, \citeauthor{caveat-knowledge-graph} proposed an extraction method for these API caveats at the sentence level by identifying common keywords between them, improving the accessibility of these API caveats. 
In addition to this, an approach by \citeauthor{jiamou} to simplify these API caveats for developers and improve understanding was proposed using Natural Language Processing (NLP) techniques. This involved using word/sentence embedding and comparing sentence similarity of sentence vectors across community text from Q/A forums such as Stack Overflow to link the API caveats with actual code examples. With this, API caveats are augmented with ``real'' code examples by developers that can help them understand how to use an API. However, this approach requires a large corpus of code examples alongside the assumption informal text by communities containing high lexical similarity to sentences of formal API documentation. Besides this, it also makes the assumption that text surrounding code examples are relevant to the code examples provided.
This thesis seeks to extend upon the word by \citeauthor{caveat-knowledge-graph, jiamou, xiaoxue} to investigate alternative methods of improving the understandability of API caveats. In particular, I focus on translating natural language of API caveats into code \textit{contracts} that can be used directly by program analysis tools to check for API misuse in real time.

are also proposed and used by \fix{JIAMOU and XIAOXUE ref}

A specific subset of API usage constraints are classified by \cite{maalej2013patterns} as \textit{directives}, which ``specify what users
are allowed/not allowed to do with the API element''. 

This subset of constraints was further researched by \citeauthor{caveat-knowledge-graph}
\\

Suppose a new developer was starting their journey on learning Java or programming in general. One of the first topics they might be interested in could be file handling (i.e. how to read a text file into their program). A common strategy to solve this problem involves using a search query on Google such as ``java how to read files''. The first search result of this is a HTML page from GeeksforGeeks\footnote{https://www.geeksforgeeks.org/different-ways-reading-text-file-java/} that provides multiple examples for reading a file in Java. The first example described is shown in Listing  \ref{lst:code-example}. The next step a developer would take is to copy-paste the relevant section into their program (i.e. the code within \lstinline{main}). Finally, the developer might try to execute their modified program, but this would result in \lstinline{FileNotFoundException} to be thrown. This is because the file path in the \lstinline{File} constructor call (line 11) has not been changed to the appropriate file path for the developer. In an integrated development environment (IDE) such as IntelliJ,  information about the exception such as which line the exception was thrown from will also be displayed. With further investigation, the developer will find a confounding result: IntelliJ reports the exception is not associated with the \lstinline{File} constructor line (where the file path is set), but with the \lstinline{FileReader} constructor in line 13. In other words, the file path appears to be accepted by \lstinline{File} but not by \lstinline{FileReader}. Searching for the reference documentation of these classes\footnote{FileReader: https://docs.oracle.com/javase/7/docs/api/java/io/FileReader.html \\\indent File: https://docs.oracle.com/javase/7/docs/api/java/io/File.html, the developer could find the reference documentation for both of these classes}. Specfically, the documentation of the relevant constructor for \lstinline{FileReader} says ``Throws: FileNotFoundException - if the file does not exist, is a directory rather than a regular file, or for some other reason cannot be opened for reading''. Furthermore, the documentation for the constructor of \lstinline{File} does not mention the consequences of an invalid path. Rather, the developer might notice that \lstinline{File} has an \lstinline{exists()} method that can be used to verify whether the file exists. Only then could the developer understand the source of the problem encountered alongside correct usage of both \lstinline{File} and \lstinline{FileReader} for reading files in Java applications.

Although the above example presents a contrived view of how a new developer would approach using a feature of an API for the first time, we observe the constraints associated with an API introduce a significant problem for all programmers that is best explained with the common phrase: ``you don't know what you don't know''. This indicates that the usage of an API requires considerable understanding of the different components involved alongside how its functions will behave in different scenarios. This is both time-consuming and a significant endeavour due to the number and size of APIs that exist across all programming languages and computer science fields.

\begin{lstlisting}[tabsize=4,caption={File reading java code example from GeeksforGeeks},label={lst:code-example}]
// Java Program to illustrate reading from FileReader 
// using BufferedReader 
import java.io.*; 
public class ReadFromFile2 
{ 
	public static void main(String[] args)throws Exception 
	{ 
		// We need to provide file path as the parameter: 
		// double backquote is to avoid compiler interpret words 
		// like \test as \t (ie. as a escape sequence) 
		File file = new File("C:\\Users\\pankaj\\Desktop\\test.txt"); 
		
		BufferedReader br = new BufferedReader(new FileReader(file)); 
		
		String st; 
		while ((st = br.readLine()) != null) 
		System.out.println(st); 
	} 
} 
\end{lstlisting}

\section{Main Research Challenges}
\label{sec:mainresearchchallenges}

\subsection{Sentence Parsing for Contracts Generation}

\subsection{Source Code Analysis}

\section{Thesis Outline}
\label{sec:outline}
How many chapters you have? You may have Chapter~\ref{cha:background},

\section{Main Contributions}
Parsing of API caveat sentences to formulate contracts (basic proof-of-concept)
Developed checkers that can output warnings from contracts
\fix{Discover lexical gap for GitHub data...}