\chapter{Conclusion}
\label{cha:conc}
In this chapter, I summarise the topic of investigation, the main challenges identified in Chapter \ref{cha:intro} and how they relate to the main contributions of this thesis and make suggestions for future work. \bigbreak

Section \ref{sec:summary} provides an overview of this thesis in terms of topic, challenges, contributions and findings.\bigbreak

Section \ref{sec:future} describes some future work ideas relevant to API caveats and constructing API caveat contracts.\bigbreak 

\section{Summary}
\label{sec:summary}
This thesis presents the approach of NLP techniques to link Java 12 API caveats to community text from GitHub. Besides this, methods to construct caveat contracts from API documentation and its applications are also explained. Chapter \ref{cha:intro} introduces the concept of API caveats. A realistic scenario is also provided to describe the motivation for linking API caveats to code, and the main challenges of this thesis are identified. Chapter \ref{cha:background} presents related work that defines the key concepts of this thesis: API caveats, using NLP techniques to augment API caveats with code examples, and the applications of static code analysis with API documentation. In Chapter \ref{cha:infoRetrieval}, the process of extracting the documentation and caveats from the Java 12 API is described in detail alongside the extraction process of GitHub community text data and the construction of multiple information retrieval systems based on TF-IDF, word2vec, BM25. The negative results of this approach are discussed and used to introduce an alternative method applied in Chapter \ref{cha:codeAnalysis}. Chapter \ref{cha:codeAnalysis} presents the idea of caveat contracts and the transformation of API caveats to form caveat contracts. The design of a checker program that can utilise the caveat contracts is given.\bigbreak

The main challenges of this thesis (Chapter \ref{cha:intro}) revolve around how API caveats can be linked to code. The challenges consist of effective sentence embedding and matching, sentence parsing techniques to extract constraints and the use of static code analysis with caveat contracts. In Chapter \ref{cha:infoRetrieval}, I tackled the problem of sentence embedding and matching by extending the work of \cite{jiamou} with additional information retrieval system models. Specifically, information retrieval systems built upon TF-IDF, BM25 and word2vec + BM25 were used in addition to just word2vec to investigate the differences of embedding models and how this approach could be applied to GitHub. I attempt to match 73,831 API caveat sentences against 629,933 GitHub comment sentences using the models mentioned and perform statistical sampling with manual labelling to determine the performance of these information retrieval systems. However, a significant lexical gap was observed given that only 1\% of query results were found relevant to their API caveat queries. The negative result of this reveals that linkage via sentence embeddings cannot be performed in the presence of large lexical gaps. \bigbreak

In Chapter \ref{cha:codeAnalysis}, I tackle the challenges of sentence parsing for constraints extraction by utilising and combining ideas from \cite{zhou-directive} and \cite{blasi2018translating} to propose a sentence normalisation approach. I conduct a statistical analysis of the Java 12 API documentation for constraints recognised in \cite{zhou-directive} as \textit{not-null} and \textit{range limitation} constraints to showcase their prevalence in the Java API documentation. I find that 20\% of unique caveat sentences from exception sections of the documentation specify a \textit{non-null} constraint, while approximately 13\% of these sentences specify a \textit{range limitation} constraint. I tackle the challenge of static code analysis by developing a proof-of-concept checker and showing how it can detect contract violations. Overall, I construct 4,694 unique caveat contracts and develop an IntelliJ plugin to automatically detect caveat contract violations in real-time. 

\section{Future Work}
\label{sec:future}

\noindent
\textbf{Extending caveat contracts to include other caveat categories.} Other interesting caveat types mentioned in Chapter \ref{cha:intro} should also be considered for caveat contracts. These require much more complex parsing techniques. In addition, other methods to resolve dependencies of API caveats should be investigated. For example, the ``add'' method of ``ArrayList'' in Java specifies ``IndexOutOfBoundsException - if the index is out of range (index < 0 || index > size())''. Identifying that ``size()'' refers to the \lstinline{size} method of \lstinline{ArrayList} is a complex problem given that cross-class dependencies exist.\\

\noindent
\textbf{Detecting bugs in existing software and more complex static code analysis.} The automatic detection of bugs remains a challenging problem. Two notable works that the methods proposed in this thesis can be combined with is \cite{code-examples}, which uses API call sequences to detect bugs, and \cite{mutation-analysis}, which uses mutation analysis to detect bugs. In \cite{code-examples}, the Boa programming language is used as an interface to a large number GitHub repositories associated ASTs to data-mine correct usage patterns of APIs. Caveat contracts could be applied to this to detect API misuse in free, open-source software. Caveat contracts could also be integrated into development pipelines as checks that are performed before code is uploaded to GitHub. Besides this, methods to effectively present these errors and suggest fixes to developers still require further research as this thesis only identifies misuse after it has occurred. More complex static analysis for special API caveats, such as those that deal with the temporal order of API calls, is another topic for investigation. For \cite{mutation-analysis}, I suggest the topic of mutating caveat contracts to create correct code usage patterns. Specifically, this could be used to generate test suites that add an extra layer of code validation and overall development efficiency.\\

\noindent
\textbf{Testing other APIs, programming languages and natural languages.} Evaluating the practicality of caveat contracts and their construction for other APIs is a useful topic that should be investigated. This is because differing results can be expected for even minor differences such as dynamically typed instead of statically typed programming language. Furthermore, the different syntactic styles used by developers for documentation presents a challenge for sentence parsing. Methods to construct caveat contracts for other languages (like Mandarin) would also be useful.