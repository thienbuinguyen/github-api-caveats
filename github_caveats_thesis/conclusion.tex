\chapter{Conclusion}
\label{cha:conc}
In this chapter, I summarise the topic of investigation, the main challenges identified in Chapter \ref{cha:intro} and how they relate to the main contributions of this thesis and make suggestions for future work. \bigbreak

Section \ref{sec:summary} provides an overview of this thesis in terms of topic, challenges, contributions and findings.\bigbreak

Section \ref{sec:future} describes some future work ideas relevant to API caveats and constructing API caveat contracts.\bigbreak 

\section{Summary}
\label{sec:summary}
This thesis presents the approach of using sentence embedding techniques to link Java 12 API caveats to community text from GitHub. Besides this, the complete process of constructing caveat contracts from API documentation (and its applications) is explored. Chapter \ref{cha:intro} introduced the concept of API caveats. A realistic scenario was provided to describe the motivation for linking API caveats to code, and the main challenges of this thesis were identified. Chapter \ref{cha:background} presented related work that defines the key concepts of this thesis: API caveats, using NLP techniques to augment API caveats with code examples, and the applications of static code analysis with API documentation. In Chapter \ref{cha:infoRetrieval}, the process of extracting the documentation and caveats from the Java 12 API was described in detail alongside the extraction process of GitHub community text data. The construction of multiple information retrieval systems based on TF-IDF, word2vec, BM25 was also documented. The negative results of this approach were discussed and used to introduce an alternative method applied in Chapter \ref{cha:codeAnalysis}. Chapter \ref{cha:codeAnalysis} presented the idea of caveat contracts and the transformation of API caveats to form caveat contracts. The design and implementation of a checker program that could utilise the caveat contracts was presented.\bigbreak

The main challenges of this thesis (Chapter \ref{cha:intro}) revolve around how API caveats can be linked to code. The challenges consist of effective sentence embedding and matching, sentence parsing techniques to extract constraints and the use of static code analysis with caveat contracts. In Chapter \ref{cha:infoRetrieval}, I tackled the problem of sentence embedding and matching by extending the work of \cite{jiamou} with additional information retrieval system models. Specifically, I constructed systems based on TF-IDF, word2vec, BM25 and word2vec + BM25 to investigate the differences of embedding models and how this approach performed with GitHub data. I attempted to match 73,831 API caveat sentences against 629,933 GitHub comment sentences using the models mentioned and performed statistical sampling with manual labelling to determine the performance of these information retrieval systems. However, a significant lexical gap was observed given that only 1\% of query results were found relevant to their API caveat queries. The negative result of this reveals that linkage via sentence embeddings cannot be performed in the presence of large lexical gaps. \bigbreak

In Chapter \ref{cha:codeAnalysis}, I tackled the challenges of sentence parsing for constraints extraction by utilising and combining ideas from \cite{zhou-directive} and \cite{blasi2018translating} to propose a sentence normalisation approach. I conducted a statistical analysis of the Java 12 API documentation for constraints recognised in \cite{zhou-directive} as \textit{not-null} and \textit{range limitation} constraints to showcase their prevalence in the Java API documentation. I found that 20\% of unique caveat sentences from exception sections of the documentation specify a \textit{non-null} constraint, while approximately 13\% of these sentences specify a \textit{range limitation} constraint. I then approached the challenges of static code analysis by developing a proof-of-concept checker and showing how it could detect caveat contract violations. This process involved the construction of 4,694 unique caveat contracts and an IntelliJ plugin that analysed code in real-time. 

\section{Future Work}
\label{sec:future}

\noindent
\textbf{Extending caveat contracts to include other caveat categories.} Other interesting caveat types mentioned in Chapter \ref{cha:intro} should also be considered for caveat contracts. These require much more complex parsing techniques. In addition, other methods to resolve dependencies of API caveats should be investigated. For example, the ``add'' method of ``ArrayList'' in Java specifies ``IndexOutOfBoundsException - if the index is out of range (index < 0 || index > size())''. Identifying that ``size()'' refers to the \lstinline{size} method of \lstinline{ArrayList} is a complex problem given that cross-element and cross-class dependencies exist.\\

\noindent
\textbf{Detecting bugs in existing software and performing more complex static code analysis.} The automatic detection of bugs remains a challenging problem. Two notable works that the methods proposed in this thesis can be combined with is \cite{code-examples}, which uses API call sequences to detect bugs, and \cite{mutation-analysis}, which uses mutation analysis to detect bugs. In \cite{code-examples}, the Boa programming language is used as an interface to a large number GitHub repositories and associated ASTs, used to data-mine correct usage patterns of APIs. Caveat contracts could be applied to this to detect API misuse in free, open-source software. They could also be integrated into development pipelines as automated tests that are performed before code is uploaded to GitHub. Besides this, methods to effectively present these errors and suggest fixes to developers still require further research as this thesis only identifies misuse after it has occurred. More complex static analysis for special API caveats, such as those that deal with the temporal order of API calls, is another topic for investigation. For \cite{mutation-analysis}, I suggest the topic of mutating caveat contracts to create correct code usage patterns. Specifically, this could be used to generate test suites that add an extra layer of code validation and overall development efficiency.\\

\noindent
\textbf{Testing other APIs, programming languages and natural languages.} Evaluating the practicality of caveat contracts and their construction for other APIs is a useful topic that should be investigated. This is because differing results can be expected for even minor differences in languages/APIs. Furthermore, the different syntactic styles used by developers for documentation presents a challenge for sentence parsing. Methods to construct caveat contracts for other languages (like Mandarin) would be valuable.