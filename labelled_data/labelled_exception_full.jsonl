{"id": 11488, "text": "if the Java virtual machine does not support this operation.", "labels": ["Ambiguous"]}
{"id": 11489, "text": "if the given cd and its composite type does not contain all of the attributes defined for a ThreadInfo of a specific runtime version.", "labels": ["Ambiguous"]}
{"id": 11490, "text": "if the element cannot be added at this time due to capacity restrictions", "labels": ["Ambiguous"]}
{"id": 11491, "text": "if the class of the specified element prevents it from being added to this queue", "labels": ["Ambiguous"]}
{"id": 11492, "text": "if the specified element is null and this queue does not permit null elements", "labels": ["NullnessNotAllowed"]}
{"id": 11493, "text": "if some property of this element prevents it from being added to this queue", "labels": ["Ambiguous"]}
{"id": 11494, "text": "if this queue is empty", "labels": ["Ambiguous"]}
{"id": 11495, "text": "if the class of an element of the specified collection prevents it from being added to this queue", "labels": ["Ambiguous"]}
{"id": 11496, "text": "if the specified collection contains a null element and this queue does not permit null elements, or if the specified collection is null", "labels": ["NullnessNotAllowed"]}
{"id": 11497, "text": "if some property of an element of the specified collection prevents it from being added to this queue, or if the specified collection is this queue", "labels": ["Ambiguous"]}
{"id": 11498, "text": "if not all the elements can be added at this time due to insertion restrictions", "labels": ["Ambiguous"]}
{"id": 11499, "text": "if tiffImageMetadata is null.", "labels": ["NullnessNotAllowed"]}
{"id": 11500, "text": "if tiffImageMetadata does not support a compatible image metadata format.", "labels": ["Ambiguous"]}
{"id": 11501, "text": "if the supplied metadata object cannot be parsed.", "labels": ["Ambiguous"]}
{"id": 11502, "text": "if obj is null or not a Rdn.", "labels": ["NullnessNotAllowed"]}
{"id": 11503, "text": "if val is not a String or byte array.", "labels": ["TypeRestriction"]}
{"id": 11504, "text": "When an Illegal value is provided.", "labels": ["Ambiguous"]}
{"id": 11505, "text": "if infos is null", "labels": ["NullnessNotAllowed"]}
{"id": 11506, "text": "if newLookAndFeel is non-null and newLookAndFeel.isSupportedLookAndFeel() returns false", "labels": ["NullnessNotAllowed", "Dependent"]}
{"id": 11507, "text": "if key is null", "labels": ["NullnessNotAllowed"]}
{"id": 11508, "text": "if target is null", "labels": ["NullnessNotAllowed"]}
{"id": 11509, "text": "if the VirtualMachine is read-only - see VirtualMachine.canBeModified().", "labels": ["Dependent"]}
{"id": 11510, "text": "if throwable is not an instance of java.lang.Throwable in the target VM.", "labels": ["Ambiguous"]}
{"id": 11511, "text": "if the thread is not suspended in the target VM", "labels": ["Ambiguous"]}
{"id": 11512, "text": "if the index is greater than or equal to frameCount() or is negative.", "labels": ["RangeLimitation"]}
{"id": 11513, "text": "if the specified range is not within the range of stack frame indicies.", "labels": ["Ambiguous"]}
{"id": 11514, "text": "That is, the exception is thrown if any of the following are true: start < 0 start >= frameCount() length < 0 (start+length) > frameCount()", "labels": ["RangeLimitation"]}
{"id": 11515, "text": "if the target virtual machine does not support this operation.", "labels": ["Ambiguous"]}
{"id": 11516, "text": "if the target virtual machine does not support this operation - see VirtualMachine.canPopFrames().", "labels": ["Dependent"]}
{"id": 11517, "text": "if this thread is not suspended.", "labels": ["Ambiguous"]}
{"id": 11518, "text": "if frame is not on this thread's call stack.", "labels": ["Ambiguous"]}
{"id": 11519, "text": "if one of the frames that would be popped is that of a native method or if the frame previous to frame is native.", "labels": ["Ambiguous"]}
{"id": 11520, "text": "if frame has become invalid.", "labels": ["Ambiguous"]}
{"id": 11521, "text": "This exception is also thrown if there are no more frames.", "labels": ["Ambiguous"]}
{"id": 11522, "text": "if the target virtual machine does not support this operation - see canForceEarlyReturn()", "labels": ["Dependent"]}
{"id": 11523, "text": "if the frame to be returned from is that of a native method.", "labels": ["Ambiguous"]}
{"id": 11524, "text": "if there are no frames.", "labels": ["Ambiguous"]}
{"id": 11525, "text": "if the value's type does not match the method's return type.", "labels": ["TypeRestriction"]}
{"id": 11526, "text": "if the method's return type has not yet been loaded through the appropriate class loader.", "labels": ["Ambiguous"]}
{"id": 11527, "text": "if this enum type has no constant with the specified name", "labels": ["Ambiguous"]}
{"id": 11528, "text": "if the argument is null", "labels": ["NullnessNotAllowed"]}
{"id": 11529, "text": "if unable to convert to a Month", "labels": ["Ambiguous"]}
{"id": 11530, "text": "if the range for the field cannot be obtained", "labels": ["Ambiguous"]}
{"id": 11531, "text": "if the field is not supported", "labels": ["Ambiguous"]}
{"id": 11532, "text": "if a value for the field cannot be obtained or the value is outside the range of valid values for the field", "labels": ["Ambiguous"]}
{"id": 11533, "text": "if the field is not supported or the range of values exceeds an int", "labels": ["Ambiguous"]}
{"id": 11534, "text": "if numeric overflow occurs", "labels": ["Ambiguous"]}
{"id": 11535, "text": "if a value for the field cannot be obtained", "labels": ["Ambiguous"]}
{"id": 11536, "text": "if unable to make the adjustment", "labels": ["Ambiguous"]}
{"id": 11537, "text": "If the parser parameter is null.", "labels": ["NullnessNotAllowed"]}
{"id": 11538, "text": "If the feature can't be assigned or retrieved.", "labels": ["Ambiguous"]}
{"id": 11539, "text": "If the feature can't be assigned that value.", "labels": ["Ambiguous"]}
{"id": 11540, "text": "If the feature value can't be assigned or retrieved.", "labels": ["Ambiguous"]}
{"id": 11541, "text": "If the feature is not currently readable.", "labels": ["Ambiguous"]}
{"id": 11542, "text": "The client may raise a processing exception.", "labels": ["Ambiguous"]}
{"id": 11543, "text": "if the compression strategy is invalid", "labels": ["Ambiguous"]}
{"id": 11544, "text": "if the compression level is invalid", "labels": ["Ambiguous"]}
{"id": 11545, "text": "if the flush mode is invalid", "labels": ["Ambiguous"]}
{"id": 11546, "text": "If functionName or arity is null.", "labels": ["NullnessNotAllowed"]}
{"id": 11547, "text": "if map is not a ComponentInputMap or is not associated with the same component", "labels": ["TypeRestriction"]}
{"id": 11548, "text": "if this PKIXCertPathChecker is unable to check certificates in the specified order; it should never be thrown if the forward flag is false since reverse checking must be supported", "labels": ["Ambiguous"]}
{"id": 11549, "text": "if an I/O error occurs", "labels": ["Ambiguous"]}
{"id": 11550, "text": "containing the following major error codes: GSSException.FAILURE", "labels": ["Ambiguous"]}
{"id": 11551, "text": "containing the following major error codes: GSSException.BAD_MECH, GSSException.FAILURE", "labels": ["Ambiguous"]}
{"id": 11552, "text": "containing the following major error codes: GSSException.DUPLICATE_ELEMENT, GSSException.BAD_MECH, GSSException.BAD_NAMETYPE, GSSException.NO_CRED, GSSException.CREDENTIALS_EXPIRED, GSSException.FAILURE", "labels": ["Ambiguous"]}
{"id": 11553, "text": "if locale is null", "labels": ["NullnessNotAllowed"]}
{"id": 11554, "text": "if interrupted while waiting", "labels": ["Ambiguous"]}
{"id": 11555, "text": "if the specified element is null", "labels": ["NullnessNotAllowed"]}
{"id": 11556, "text": "if the runtime type of the specified array is not a supertype of the runtime type of every element in this queue", "labels": ["Ambiguous"]}
{"id": 11557, "text": "if the specified array is null", "labels": ["NullnessNotAllowed"]}
{"id": 11558, "text": "if signingKey, parent or nextSibling is null", "labels": ["NullnessNotAllowed"]}
{"id": 11559, "text": "if ks, parent or nextSibling is null", "labels": ["NullnessNotAllowed"]}
{"id": 11560, "text": "If the feature value can't be assigned or retrieved from the parent.", "labels": ["Ambiguous"]}
{"id": 11561, "text": "When the parent recognizes the feature name but cannot set the requested value.", "labels": ["Ambiguous"]}
{"id": 11562, "text": "When the parent recognizes the feature name but cannot determine its value at this time.", "labels": ["Ambiguous"]}
{"id": 11563, "text": "If the property value can't be assigned or retrieved from the parent.", "labels": ["Ambiguous"]}
{"id": 11564, "text": "When the parent recognizes the property name but cannot set the requested value.", "labels": ["Ambiguous"]}
{"id": 11565, "text": "The client may throw an exception during processing.", "labels": ["Ambiguous"]}
{"id": 11566, "text": "if the connection could not be made because of a communication problem.", "labels": ["Ambiguous"]}
{"id": 11567, "text": "if the connection could not be made for security reasons.", "labels": ["Ambiguous"]}
{"id": 11568, "text": "if a valid MBeanServerConnection cannot be created, for instance because the connection to the remote MBean server has not yet been established (with the connect method), or it has been closed, or it has broken.", "labels": ["Ambiguous"]}
{"id": 11569, "text": "if the connection cannot be closed cleanly.", "labels": ["Ambiguous"]}
{"id": 11570, "text": "If this exception is thrown, it is not known whether the server end of the connection has been cleanly closed.", "labels": ["Ambiguous"]}
{"id": 11571, "text": "if listener is null.", "labels": ["NullnessNotAllowed"]}
{"id": 11572, "text": "if the listener is not registered with this JMXConnector.", "labels": ["Ambiguous"]}
{"id": 11573, "text": "if the listener is not registered with this JMXConnector, or is not registered with the given filter and handback.", "labels": ["Ambiguous"]}
{"id": 11574, "text": "if this is called on an implementation that does not support Cloneable.", "labels": ["Ambiguous"]}
{"id": 11575, "text": "Any SAX exception, possibly wrapping another exception.", "labels": ["Ambiguous"]}
{"id": 11576, "text": "Probably indicating a failure to create a new InputStream or Reader, or an illegal URL.", "labels": ["Ambiguous"]}
{"id": 11577, "text": "if the associated stack frame has become invalid.", "labels": ["Ambiguous"]}
{"id": 11578, "text": "if the port parameter is outside the specified range of valid port values.", "labels": ["Ambiguous"]}
{"id": 11579, "text": "if the port parameter is outside the range of valid port values, or if the hostname parameter is null.", "labels": ["Ambiguous", "NullnessNotAllowed"]}
{"id": 11580, "text": "if a security manager is present and permission to resolve the host name is denied.", "labels": ["Ambiguous"]}
{"id": 11581, "text": "if info is null", "labels": ["NullnessNotAllowed"]}
{"id": 11582, "text": "if locale isn't one of the locales returned from getAvailableLocales().", "labels": ["Dependent"]}
{"id": 11583, "text": "if index is invalid", "labels": ["Ambiguous"]}
{"id": 11584, "text": "if adding the container's parent to itself", "labels": ["Ambiguous"]}
{"id": 11585, "text": "if adding a window to a container", "labels": ["Ambiguous"]}
{"id": 11586, "text": "if comp is null", "labels": ["NullnessNotAllowed"]}
{"id": 11587, "text": "when the attempt to set the property is vetoed by the JInternalFrame", "labels": ["Ambiguous"]}
{"id": 11588, "text": "if the current thread is interrupted (and interruption of thread suspension is supported)", "labels": ["Ambiguous"]}
{"id": 11589, "text": "if the member is not of the expected type", "labels": ["Ambiguous"]}
{"id": 11590, "text": "if either argument is null", "labels": ["NullnessNotAllowed"]}
{"id": 11591, "text": "if the underlying member is not accessible to the given lookup object", "labels": ["Ambiguous"]}
{"id": 11592, "text": "if the category is null", "labels": ["NullnessNotAllowed"]}
{"id": 11593, "text": "if category is not a Class that implements interface PrintServiceAttribute", "labels": ["Ambiguous"]}
{"id": 11594, "text": "if flavor is null", "labels": ["NullnessNotAllowed"]}
{"id": 11595, "text": "if category is null", "labels": ["NullnessNotAllowed"]}
{"id": 11596, "text": "if category is not a Class that implements interface Attribute", "labels": ["Ambiguous"]}
{"id": 11597, "text": "if category is not a Class that implements interface Attribute, or DocFlavor is not supported by this service", "labels": ["Ambiguous"]}
{"id": 11598, "text": "if attrval is null", "labels": ["NullnessNotAllowed"]}
{"id": 11599, "text": "if flavor is not supported by this PrintService", "labels": ["Ambiguous"]}
{"id": 11600, "text": "if name is null.", "labels": ["NullnessNotAllowed"]}
{"id": 11601, "text": "if name is empty.", "labels": ["Ambiguous"]}
{"id": 11602, "text": "if null or zero-length array is passed in for the chain parameter or if null or zero-length string is passed in for the authType parameter", "labels": ["NullnessNotAllowed", "Ambiguous"]}
{"id": 11603, "text": "if the certificate chain is not trusted by this TrustManager", "labels": ["Ambiguous"]}
{"id": 11604, "text": "If an I/O error has occurred.", "labels": ["Ambiguous"]}
{"id": 11605, "text": "if size <= 0", "labels": ["RangeLimitation"]}
{"id": 11606, "text": "if an I/O error has occurred", "labels": ["Ambiguous"]}
{"id": 11607, "text": "if name is null", "labels": ["NullnessNotAllowed"]}
{"id": 11608, "text": "if the value of constructorParameter is invalid for this type of service.", "labels": ["Ambiguous"]}
{"id": 11609, "text": "if instantiation failed for any other reason.", "labels": ["Ambiguous"]}
{"id": 11610, "text": "if the value of parameter is invalid for this type of service or if this method cannot be used with this type of service", "labels": ["Ambiguous"]}
{"id": 11611, "text": "If resolution fails for any of the observability-related reasons specified by the static resolve method", "labels": ["Ambiguous"]}
{"id": 11612, "text": "If resolution fails any of the consistency checks specified by the static resolve method", "labels": ["Ambiguous"]}
{"id": 11613, "text": "If locating a module is denied by the security manager", "labels": ["Ambiguous"]}
{"id": 11614, "text": "If resolution fails for any of observability-related reasons specified above", "labels": ["Ambiguous"]}
{"id": 11615, "text": "If resolution fails for any of the consistency checks specified above", "labels": ["Ambiguous"]}
{"id": 11616, "text": "If the list of parents is empty, or the list has two or more parents with modules for different target operating systems, architectures, or versions", "labels": ["Ambiguous"]}
{"id": 11617, "text": "if shortName is null.", "labels": ["NullnessNotAllowed"]}
{"id": 11618, "text": "if a security manager exists and its checkPermission method doesn't allow access.", "labels": ["Ambiguous"]}
{"id": 11619, "text": "if dsc is null.", "labels": ["NullnessNotAllowed"]}
{"id": 11620, "text": "if newChild is null.", "labels": ["NullnessNotAllowed"]}
{"id": 11621, "text": "always.", "labels": ["Ambiguous"]}
{"id": 11622, "text": "if the field cannot be set", "labels": ["Ambiguous"]}
{"id": 11623, "text": "if the addition cannot be made", "labels": ["Ambiguous"]}
{"id": 11624, "text": "if the unit cannot be added", "labels": ["Ambiguous"]}
{"id": 11625, "text": "if the subtraction cannot be made", "labels": ["Ambiguous"]}
{"id": 11626, "text": "if the unit cannot be subtracted", "labels": ["Ambiguous"]}
{"id": 11627, "text": "if an error occurs during printing", "labels": ["Ambiguous"]}
{"id": 11628, "text": "if table is null or table.length is not equal to 64.", "labels": ["NullnessNotAllowed", "RangeLimitation"]}
{"id": 11629, "text": "If an I/O error occurs", "labels": ["Ambiguous"]}
{"id": 11630, "text": "if an I/O error occurs.", "labels": ["Ambiguous"]}
{"id": 11631, "text": "Wraps an IllegalArgumentException for invalid Descriptor.", "labels": ["Ambiguous"]}
{"id": 11632, "text": "If the providers for the service type have already been declared", "labels": ["Ambiguous"]}
{"id": 11633, "text": "If the service type or any of the provider class names is null or not a qualified name of a class in a named package, or the list of provider class names is empty", "labels": ["Ambiguous"]}
{"id": 11634, "text": "If mainClass is null or not a qualified name of a class in a named package", "labels": ["NullnessNotAllowed"]}
{"id": 11635, "text": "if there is an error in the conversion", "labels": ["Ambiguous"]}
{"id": 11636, "text": "if any exception occurs during remote method invocation", "labels": ["Ambiguous"]}
{"id": 11637, "text": "if listenerType doesn't specify a class or interface that implements java.util.EventListener", "labels": ["Ambiguous"]}
{"id": 11638, "text": "on signature errors.", "labels": ["Ambiguous"]}
{"id": 11639, "text": "on encoding errors.", "labels": ["Ambiguous"]}
{"id": 11640, "text": "if certificate is null", "labels": ["NullnessNotAllowed"]}
{"id": 11641, "text": "if the commit fails.", "labels": ["Ambiguous"]}
{"id": 11642, "text": "if the abort fails.", "labels": ["Ambiguous"]}
{"id": 11643, "text": "if GraphicsEnvironment.isHeadless() returns true", "labels": ["Dependent"]}
{"id": 11644, "text": "if this class is not supported on the current platform", "labels": ["Ambiguous"]}
{"id": 11645, "text": "if a security manager exists and it denies the RuntimePermission(\"canProcessApplicationEvents\") permission.", "labels": ["Ambiguous"]}
{"id": 11646, "text": "if the current platform does not support the Taskbar.Feature.USER_ATTENTION_WINDOW feature", "labels": ["Ambiguous"]}
{"id": 11647, "text": "if the current platform does not support the Taskbar.Feature.ICON_BADGE_NUMBER or Taskbar.Feature.ICON_BADGE_TEXT feature", "labels": ["Ambiguous"]}
{"id": 11648, "text": "if the current platform does not support the Taskbar.Feature.ICON_BADGE_IMAGE_WINDOW feature", "labels": ["Ambiguous"]}
{"id": 11649, "text": "if the current platform does not support the Taskbar.Feature.PROGRESS_VALUE_WINDOW feature", "labels": ["Ambiguous"]}
{"id": 11650, "text": "if the current platform does not support the Taskbar.Feature.PROGRESS_STATE_WINDOW feature", "labels": ["Ambiguous"]}
{"id": 11651, "text": "if s is null", "labels": ["NullnessNotAllowed"]}
{"id": 11652, "text": "if a database access error occurs", "labels": ["Ambiguous"]}
{"id": 11653, "text": "if the JDBC driver does not support this method", "labels": ["Ambiguous"]}
{"id": 11654, "text": "if a database access error occurs or if the Java Object specified by x is an InputStream or Reader object and the value of the scale parameter is less than zero", "labels": ["Ambiguous"]}
{"id": 11655, "text": "if the JDBC driver does not support this data type", "labels": ["Ambiguous"]}
{"id": 11656, "text": "if the specified position is invalid", "labels": ["Ambiguous"]}
{"id": 11657, "text": "if a security manager exists and its checkPropertiesAccess method doesn't allow setting of system properties.", "labels": ["Ambiguous"]}
{"id": 11658, "text": "if the calling thread does not have permission to get SSL session context.", "labels": ["Ambiguous"]}
{"id": 11659, "text": "if either argument is null.", "labels": ["NullnessNotAllowed"]}
{"id": 11660, "text": "if the argument is null.", "labels": ["NullnessNotAllowed"]}
{"id": 11661, "text": "if the peer's identity has not been verified", "labels": ["Ambiguous"]}
{"id": 11662, "text": "if unable to convert to a YearMonth", "labels": ["Ambiguous"]}
{"id": 11663, "text": "if the text cannot be parsed", "labels": ["Ambiguous"]}
{"id": 11664, "text": "if the unit is not supported", "labels": ["Ambiguous"]}
{"id": 11665, "text": "if the amount cannot be calculated, or the end temporal cannot be converted to a YearMonth", "labels": ["Ambiguous"]}
{"id": 11666, "text": "if the day is invalid for the year-month", "labels": ["Ambiguous"]}
{"id": 11667, "text": "if no Provider supports a MacSpi implementation for the specified algorithm", "labels": ["Ambiguous"]}
{"id": 11668, "text": "if algorithm is null", "labels": ["NullnessNotAllowed"]}
{"id": 11669, "text": "if the provider is null or empty", "labels": ["NullnessNotAllowed", "Ambiguous"]}
{"id": 11670, "text": "if a MacSpi implementation for the specified algorithm is not available from the specified provider", "labels": ["Ambiguous"]}
{"id": 11671, "text": "if the specified provider is not registered in the security provider list", "labels": ["Ambiguous"]}
{"id": 11672, "text": "if the provider is null", "labels": ["NullnessNotAllowed"]}
{"id": 11673, "text": "if a MacSpi implementation for the specified algorithm is not available from the specified Provider object", "labels": ["Ambiguous"]}
{"id": 11674, "text": "if this Mac has not been initialized.", "labels": ["Ambiguous"]}
{"id": 11675, "text": "if the given output buffer is too small to hold the result", "labels": ["Ambiguous"]}
{"id": 11676, "text": "if this is called on a delegate that does not support Cloneable.", "labels": ["Ambiguous"]}
{"id": 11677, "text": "if no value is present", "labels": ["Ambiguous"]}
{"id": 11678, "text": "if value is present and the given action is null", "labels": ["Ambiguous"]}
{"id": 11679, "text": "if a value is present and the given action is null, or no value is present and the given empty-based action is null.", "labels": ["Ambiguous"]}
{"id": 11680, "text": "if no value is present and the supplying function is null", "labels": ["NullnessNotAllowed"]}
{"id": 11681, "text": "if no value is present and the exception supplying function is null", "labels": ["NullnessNotAllowed"]}
{"id": 11682, "text": "if baseName is null", "labels": ["NullnessNotAllowed"]}
{"id": 11683, "text": "if an I/O error occurs or this stream is already closed", "labels": ["Ambiguous"]}
{"id": 11684, "text": "if elementName is null, or is not a legal element name for this format.", "labels": ["NullnessNotAllowed"]}
{"id": 11685, "text": "if enumeratedValues is null.", "labels": ["NullnessNotAllowed"]}
{"id": 11686, "text": "if enumeratedValues does not contain at least one entry.", "labels": ["Ambiguous"]}
{"id": 11687, "text": "if enumeratedValues contains an element that is not an instance of the class type denoted by classType or is null.", "labels": ["NullnessNotAllowed", "TypeRestriction"]}
{"id": 11688, "text": "if elementName is not a legal element name for this format.", "labels": ["Ambiguous"]}
{"id": 11689, "text": "if attrName is null or is not a legal attribute name for this element.", "labels": ["NullnessNotAllowed"]}
{"id": 11690, "text": "if the Component does not have its own locale and has not yet been added to a containment hierarchy such that the locale can be determined from the containing parent", "labels": ["Ambiguous"]}
{"id": 11691, "text": "If the component does not have its own locale and has not yet been added to a containment hierarchy such that the locale can be determined from the containing parent", "labels": ["Ambiguous"]}
{"id": 11692, "text": "if the specified offset is less than the first text boundary or greater than the last text boundary.", "labels": ["RangeLimitation"]}
{"id": 11693, "text": "if a state other than RAW_TEXT or CONVERTED_TEXT is given", "labels": ["Ambiguous"]}
{"id": 11694, "text": "if an I/O error occurs when creating the socket", "labels": ["Ambiguous"]}
{"id": 11695, "text": "if a security manager exists and its checkListen method doesn't allow the operation.", "labels": ["Ambiguous"]}
{"id": 11696, "text": "if the port parameter is outside the specified range of valid port values, which is between 0 and 65535, inclusive.", "labels": ["RangeLimitation"]}
{"id": 11697, "text": "when one or more of ciphers named by the parameter is not supported, or when the parameter is null.", "labels": ["NullnessNotAllowed"]}
{"id": 11698, "text": "when one or more of the protocols named by the parameter is not supported or when the protocols parameter is null.", "labels": ["NullnessNotAllowed"]}
{"id": 11699, "text": "if the setEnabledCipherSuites() or the setEnabledProtocols() call fails", "labels": ["Dependent"]}
{"id": 11700, "text": "if this context's handler is already set.", "labels": ["Ambiguous"]}
{"id": 11701, "text": "if handler is null", "labels": ["NullnessNotAllowed"]}
{"id": 11702, "text": "if table is null", "labels": ["NullnessNotAllowed"]}
{"id": 11703, "text": "if theme is null", "labels": ["NullnessNotAllowed"]}
{"id": 11704, "text": "if salt is null.", "labels": ["NullnessNotAllowed"]}
{"id": 11705, "text": "if salt is empty, i.e.", "labels": ["Ambiguous"]}
{"id": 11706, "text": "if password has been cleared by calling clearPassword method.", "labels": ["Dependent"]}
{"id": 11707, "text": "if toAppendTo or pos is null", "labels": ["NullnessNotAllowed"]}
{"id": 11708, "text": "if the Format cannot format the given object", "labels": ["Ambiguous"]}
{"id": 11709, "text": "if obj is null.", "labels": ["NullnessNotAllowed"]}
{"id": 11710, "text": "when the Format cannot format the given object.", "labels": ["Ambiguous"]}
{"id": 11711, "text": "if source or pos is null.", "labels": ["NullnessNotAllowed"]}
{"id": 11712, "text": "Wraps a distributed communication Exception.", "labels": ["Ambiguous"]}
{"id": 11713, "text": "Wraps a RuntimeException during the construction of the object.", "labels": ["Ambiguous"]}
{"id": 11714, "text": "Wraps an {link java.lang.IllegalArgumentException}: The MBeanInfo passed in parameter is null.", "labels": ["NullnessNotAllowed"]}
{"id": 11715, "text": "Wraps an IllegalArgumentException if the MBeanInfo passed in parameter is null.", "labels": ["NullnessNotAllowed"]}
{"id": 11716, "text": "Wraps an IllegalStateException if the ModelMBean is currently registered in the MBeanServer.", "labels": ["Ambiguous"]}
{"id": 11717, "text": "Wraps another exception, or persistence is not supported", "labels": ["Ambiguous"]}
{"id": 11718, "text": "Wraps exceptions from the persistence mechanism", "labels": ["Ambiguous"]}
{"id": 11719, "text": "Wraps one of the following Exceptions: An Exception thrown by the managed object's invoked method.", "labels": ["Ambiguous"]}
{"id": 11720, "text": "ServiceNotFoundException: No ModelMBeanOperationInfo or no descriptor defined for the specified operation or the managed resource is null.", "labels": ["NullnessNotAllowed"]}
{"id": 11721, "text": "InvalidTargetObjectTypeException: The 'targetType' field value is not 'objectReference'.", "labels": ["Ambiguous"]}
{"id": 11722, "text": "Wraps an Exception thrown while trying to invoke the method.", "labels": ["Ambiguous"]}
{"id": 11723, "text": "Wraps an IllegalArgumentException Method name is null.", "labels": ["NullnessNotAllowed"]}
{"id": 11724, "text": "The following cases may result in an AttributeNotFoundException: No ModelMBeanInfo was found for the Model MBean.", "labels": ["Ambiguous"]}
{"id": 11725, "text": "Wraps one of the following Exceptions: InvalidAttributeValueException: A wrong value type was received from the attribute's getter method or no 'getMethod' field defined in the descriptor for the attribute and no default value exists.", "labels": ["Ambiguous"]}
{"id": 11726, "text": "ServiceNotFoundException: No ModelMBeanOperationInfo defined for the attribute's getter method or no descriptor associated with the ModelMBeanOperationInfo or the managed resource is null.", "labels": ["NullnessNotAllowed"]}
{"id": 11727, "text": "InvalidTargetObjectTypeException The 'targetType' field value is not 'objectReference'.", "labels": ["Ambiguous"]}
{"id": 11728, "text": "An Exception thrown by the managed object's getter.", "labels": ["Ambiguous"]}
{"id": 11729, "text": "Wraps an Exception thrown while trying to invoke the getter.", "labels": ["Ambiguous"]}
{"id": 11730, "text": "Wraps an IllegalArgumentException: The attribute name in parameter is null.", "labels": ["NullnessNotAllowed"]}
{"id": 11731, "text": "The following cases may result in an AttributeNotFoundException: No ModelMBeanAttributeInfo is found for the specified attribute.", "labels": ["Ambiguous"]}
{"id": 11732, "text": "Wraps one of the following Exceptions: An Exception thrown by the managed object's setter.", "labels": ["Ambiguous"]}
{"id": 11733, "text": "A ServiceNotFoundException if a setMethod field is defined in the descriptor for the attribute and the managed resource is null; or if no setMethod field is defined and caching is not enabled for the attribute.", "labels": ["NullnessNotAllowed"]}
{"id": 11734, "text": "Note that if there is no getMethod field either, then caching is automatically enabled.", "labels": ["Ambiguous"]}
{"id": 11735, "text": "Wraps an Exception thrown while trying to invoke the setter.", "labels": ["Ambiguous"]}
{"id": 11736, "text": "Wraps an IllegalArgumentException: The attribute in parameter is null.", "labels": ["NullnessNotAllowed"]}
{"id": 11737, "text": "The listener cannot be null.", "labels": ["NullnessNotAllowed"]}
{"id": 11738, "text": "This exception will be caught by the MBean server and re-thrown as an MBeanRegistrationException.", "labels": ["Ambiguous"]}
{"id": 11739, "text": "if a null range is specified or if a non-null range is specified with lowerBound less than zero", "labels": ["NullnessNotAllowed", "RangeLimitation"]}
{"id": 11740, "text": "if there is an error accessing the BLOB value or if pos is less than 1", "labels": ["RangeLimitation"]}
{"id": 11741, "text": "if there is an error accessing the BLOB value or if len is less than 0", "labels": ["RangeLimitation"]}
{"id": 11742, "text": "if an error occurs releasing the Blob's resources", "labels": ["Ambiguous"]}
{"id": 11743, "text": "NOT_SUPPORTED_ERR: Raised if an attempt is made to set currentNode to null.", "labels": ["NullnessNotAllowed"]}
{"id": 11744, "text": "if this class not yet been prepared.", "labels": ["Ambiguous"]}
{"id": 11745, "text": "if the method is not a member of this interface, if the size of the argument list does not match the number of declared arguments for the method, or if the method is not static or is a static initializer.", "labels": ["Ambiguous"]}
{"id": 11746, "text": "if any argument type has not yet been loaded through the appropriate class loader.", "labels": ["Ambiguous"]}
{"id": 11747, "text": "if the specified thread has not been suspended by an event.", "labels": ["Ambiguous"]}
{"id": 11748, "text": "if the method invocation resulted in an exception in the target VM.", "labels": ["Ambiguous"]}
{"id": 11749, "text": "If the arguments do not meet this requirement -- Object arguments must be assignment compatible with the argument type.", "labels": ["Ambiguous"]}
{"id": 11750, "text": "This implies that the argument type must be loaded through the enclosing class' class loader.", "labels": ["Ambiguous"]}
{"id": 11751, "text": "Primitive arguments must be either assignment compatible with the argument type or must be convertible to the argument type without loss of information.", "labels": ["Ambiguous"]}
{"id": 11752, "text": "if no Provider supports a KeyFactorySpi implementation for the specified algorithm", "labels": ["Ambiguous"]}
{"id": 11753, "text": "if the provider name is null or empty", "labels": ["NullnessNotAllowed"]}
{"id": 11754, "text": "if a KeyFactorySpi implementation for the specified algorithm is not available from the specified provider", "labels": []}
{"id": 11755, "text": "if the specified provider is null", "labels": ["NullnessNotAllowed"]}
{"id": 11756, "text": "if a KeyFactorySpi implementation for the specified algorithm is not available from the specified Provider object", "labels": ["Ambiguous"]}
{"id": 11757, "text": "if the requested key specification is inappropriate for the given key, or the given key cannot be processed (e.g., the given key has an unrecognized algorithm or format).", "labels": ["Ambiguous"]}
{"id": 11758, "text": "if the host or port are invalid or are not specified as LogManager properties.", "labels": ["Ambiguous"]}
{"id": 11759, "text": "if we are unable to connect to the target host and port.", "labels": ["Ambiguous"]}
{"id": 11760, "text": "if the host or port are invalid.", "labels": ["Ambiguous"]}
{"id": 11761, "text": "if the specified collection or any of its elements are null", "labels": ["NullnessNotAllowed"]}
{"id": 11762, "text": "if the collection is this deque", "labels": ["Ambiguous"]}
{"id": 11763, "text": "if the runtime type of the specified array is not a supertype of the runtime type of every element in this deque", "labels": ["Ambiguous"]}
{"id": 11764, "text": "if pattern is null", "labels": ["NullnessNotAllowed"]}
{"id": 11765, "text": "if the given pattern is invalid.", "labels": ["Ambiguous"]}
{"id": 11766, "text": "if any of the given arguments is null", "labels": ["NullnessNotAllowed"]}
{"id": 11767, "text": "if the given pattern is invalid", "labels": ["Ambiguous"]}
{"id": 11768, "text": "if text or pos is null.", "labels": ["NullnessNotAllowed"]}
{"id": 11769, "text": "if currency is null", "labels": ["NullnessNotAllowed"]}
{"id": 11770, "text": "if the intfc is not a valid argument to this method", "labels": ["Ambiguous"]}
{"id": 11771, "text": "if the target cannot be converted to the type required by the requested interface", "labels": ["Ambiguous"]}
{"id": 11772, "text": "if the reference x is not to a wrapper instance", "labels": ["Ambiguous"]}
{"id": 11773, "text": "if the current thread is interrupted", "labels": ["Ambiguous"]}
{"id": 11774, "text": "if the time unit is null", "labels": ["NullnessNotAllowed"]}
{"id": 11775, "text": "if the current thread does not hold this lock", "labels": ["Ambiguous"]}
{"id": 11776, "text": "if source is null", "labels": ["NullnessNotAllowed"]}
{"id": 11777, "text": "if when is null.", "labels": ["NullnessNotAllowed"]}
{"id": 11778, "text": "if instant is null.", "labels": ["NullnessNotAllowed"]}
{"id": 11779, "text": "if the instant is too large to represent as a Date", "labels": ["Ambiguous"]}
{"id": 11780, "text": "if any element of attributes is null", "labels": ["NullnessNotAllowed"]}
{"id": 11781, "text": "if image is null", "labels": ["NullnessNotAllowed"]}
{"id": 11782, "text": "if the system tray isn't supported by the current platform", "labels": ["Ambiguous"]}
{"id": 11783, "text": "if accessSystemTray permission is not granted", "labels": ["Ambiguous"]}
{"id": 11784, "text": "if the popup is already set for another TrayIcon", "labels": ["Ambiguous"]}
{"id": 11785, "text": "if both caption and text are null", "labels": ["NullnessNotAllowed"]}
{"id": 11786, "text": "if an I/O error occurs or if this stream is already closed", "labels": ["Ambiguous"]}
{"id": 11787, "text": "if the target isn't the container specified to the BoxLayout constructor", "labels": ["Ambiguous"]}
{"id": 11788, "text": "INVALID_CHARACTER_ERR: Raised if the specified name is not an XML name according to the XML version in use specified in the Document.xmlVersion attribute.", "labels": ["Ambiguous"]}
{"id": 11789, "text": "NOT_SUPPORTED_ERR: Raised if this document is an HTML document.", "labels": ["Ambiguous"]}
{"id": 11790, "text": "INVALID_CHARACTER_ERR: Raised if the specified qualifiedName is not an XML name according to the XML version in use specified in the Document.xmlVersion attribute.", "labels": ["Ambiguous"]}
{"id": 11791, "text": "NOT_SUPPORTED_ERR: Always thrown if the current document does not support the \"XML\" feature, since namespaces were defined by XML.", "labels": ["Ambiguous"]}
{"id": 11792, "text": "NOT_SUPPORTED_ERR: Raised if this document does not support the \"XML\" feature.", "labels": ["Ambiguous"]}
{"id": 11793, "text": "NOT_SUPPORTED_ERR: Raised if the version is set to a value that is not supported by this Document or if this document does not support the \"XML\" feature.", "labels": ["Ambiguous"]}
{"id": 11794, "text": "NOT_SUPPORTED_ERR: Raised when the type of the specified node is neither ELEMENT_NODE nor ATTRIBUTE_NODE, or if the implementation does not support the renaming of the document element.", "labels": ["Ambiguous"]}
{"id": 11795, "text": "INVALID_CHARACTER_ERR: Raised if the new qualified name is not an XML name according to the XML version in use specified in the Document.xmlVersion attribute.", "labels": []}
{"id": 11796, "text": "WRONG_DOCUMENT_ERR: Raised when the specified node was created from a different document than this document.", "labels": ["Ambiguous"]}
{"id": 11797, "text": "NAMESPACE_ERR: Raised if the qualifiedName is a malformed qualified name, if the qualifiedName has a prefix and the namespaceURI is null, or if the qualifiedName has a prefix that is \"xml\" and the namespaceURI is different from \" http://www.w3.org/XML/1998/namespace\" [XML Namespaces] .", "labels": ["Ambiguous"]}
{"id": 11798, "text": "Also raised, when the node being renamed is an attribute, if the qualifiedName, or its prefix, is \"xmlns\" and the namespaceURI is different from \"http://www.w3.org/2000/xmlns/\".", "labels": ["Ambiguous"]}
{"id": 11799, "text": "if the input is not valid.", "labels": ["Ambiguous"]}
{"id": 11800, "text": "For example, input might not be valid if the field type or name is not valid in the Java language or an annotation element references a type that can't be found.", "labels": ["Ambiguous"]}
{"id": 11801, "text": "if a security manager exists and the caller does not have FlightRecorderPermission(\"registerEvent\")", "labels": ["Ambiguous"]}
{"id": 11802, "text": "if val is infinite or NaN.", "labels": ["RangeLimitation"]}
{"id": 11803, "text": "if the result is inexact but the RoundingMode is UNNECESSARY.", "labels": ["Ambiguous"]}
{"id": 11804, "text": "if the result is inexact but the rounding mode is UNNECESSARY.", "labels": ["Ambiguous"]}
{"id": 11805, "text": "if divisor is zero, roundingMode==RoundingMode.UNNECESSARY and the specified scale is insufficient to represent the result of the division exactly.", "labels": ["RangeLimitation"]}
{"id": 11806, "text": "if divisor==0, or roundingMode==RoundingMode.UNNECESSARY and this.scale() is insufficient to represent the result of the division exactly.", "labels": ["RangeLimitation"]}
{"id": 11807, "text": "if the exact quotient does not have a terminating decimal expansion", "labels": ["Ambiguous"]}
{"id": 11808, "text": "if divisor==0", "labels": ["RangeLimitation"]}
{"id": 11809, "text": "if mc.precision > 0 and the result requires a precision of more than mc.precision digits.", "labels": ["RangeLimitation"]}
{"id": 11810, "text": "if the result is inexact but the rounding mode is UNNECESSARY, or mc.precision > 0 and the result of this.divideToIntgralValue(divisor) would require a precision of more than mc.precision digits.", "labels": ["RangeLimitation"]}
{"id": 11811, "text": "if this is less than zero.", "labels": ["RangeLimitation"]}
{"id": 11812, "text": "if an exact result is requested (mc.getPrecision()==0) and there is no finite decimal expansion of the exact result", "labels": ["Ambiguous"]}
{"id": 11813, "text": "if (mc.getRoundingMode()==RoundingMode.UNNECESSARY) and the exact result cannot fit in mc.getPrecision() digits.", "labels": ["Ambiguous"]}
{"id": 11814, "text": "if n is out of range.", "labels": ["Ambiguous"]}
{"id": 11815, "text": "if the result is inexact but the rounding mode is UNNECESSARY, or n is out of range.", "labels": ["Ambiguous"]}
{"id": 11816, "text": "if the rounding mode is UNNECESSARY and the BigDecimal operation would require rounding.", "labels": ["Ambiguous"]}
{"id": 11817, "text": "if roundingMode==UNNECESSARY and the specified scaling operation would require rounding.", "labels": ["Ambiguous"]}
{"id": 11818, "text": "if the specified scaling operation would require rounding.", "labels": ["Ambiguous"]}
{"id": 11819, "text": "if scale overflows.", "labels": ["Ambiguous"]}
{"id": 11820, "text": "if this has a nonzero fractional part.", "labels": ["Ambiguous"]}
{"id": 11821, "text": "if this has a nonzero fractional part, or will not fit in a long.", "labels": ["Ambiguous"]}
{"id": 11822, "text": "if this has a nonzero fractional part, or will not fit in an int.", "labels": ["Ambiguous"]}
{"id": 11823, "text": "if this has a nonzero fractional part, or will not fit in a short.", "labels": ["Ambiguous"]}
{"id": 11824, "text": "if this has a nonzero fractional part, or will not fit in a byte.", "labels": ["Ambiguous"]}
{"id": 11825, "text": "When the ValidatorHandler recognizes the feature name but cannot determine its value at this time.", "labels": ["Ambiguous"]}
{"id": 11826, "text": "When name is null.", "labels": ["NullnessNotAllowed"]}
{"id": 11827, "text": "When the ValidatorHandler recognizes the feature name but cannot set the requested value.", "labels": ["Ambiguous"]}
{"id": 11828, "text": "If the property value can't be assigned or retrieved.", "labels": ["Ambiguous"]}
{"id": 11829, "text": "When the ValidatorHandler recognizes the property name but cannot set the requested value.", "labels": ["Ambiguous"]}
{"id": 11830, "text": "When the XMLReader recognizes the property name but cannot determine its value at this time.", "labels": ["Ambiguous"]}
{"id": 11831, "text": "If this formatter has been closed by invoking its close() method", "labels": ["Dependent"]}
{"id": 11832, "text": "if an I/O error occurs while writing stream header", "labels": ["Ambiguous"]}
{"id": 11833, "text": "if untrusted subclass illegally overrides security-sensitive methods", "labels": ["Ambiguous"]}
{"id": 11834, "text": "if out is null", "labels": ["NullnessNotAllowed"]}
{"id": 11835, "text": "if a security manager exists and its checkPermission method denies enabling subclassing.", "labels": ["Ambiguous"]}
{"id": 11836, "text": "if an I/O error occurs while creating this stream", "labels": ["Ambiguous"]}
{"id": 11837, "text": "if called after any objects have been serialized.", "labels": ["Ambiguous"]}
{"id": 11838, "text": "if invalid version is passed in.", "labels": ["Ambiguous"]}
{"id": 11839, "text": "if I/O errors occur", "labels": ["Ambiguous"]}
{"id": 11840, "text": "Any exception thrown by the underlying OutputStream.", "labels": ["Ambiguous"]}
{"id": 11841, "text": "if an object in the graph to be serialized does not implement the Serializable interface", "labels": ["Ambiguous"]}
{"id": 11842, "text": "if a problem exists with the class of an object to be serialized", "labels": ["Ambiguous"]}
{"id": 11843, "text": "if an I/O error occurs during serialization", "labels": ["Ambiguous"]}
{"id": 11844, "text": "if I/O errors occur while writing to the underlying OutputStream", "labels": ["Ambiguous"]}
{"id": 11845, "text": "any exception thrown by the underlying OutputStream", "labels": ["Ambiguous"]}
{"id": 11846, "text": "if a security manager exists and its checkPermission method denies enabling the stream to do replacement of objects written to the stream.", "labels": ["Ambiguous"]}
{"id": 11847, "text": "if I/O errors occur while writing to the underlying stream", "labels": ["Ambiguous"]}
{"id": 11848, "text": "if the number format class doesn't implement currency formatting", "labels": ["Ambiguous"]}
{"id": 11849, "text": "The default implementation always throws this exception", "labels": ["Ambiguous"]}
{"id": 11850, "text": "if roundingMode is null", "labels": ["NullnessNotAllowed"]}
{"id": 11851, "text": "if the iteration has no next element", "labels": ["Ambiguous"]}
{"id": 11852, "text": "if the iteration has no previous element", "labels": ["Ambiguous"]}
{"id": 11853, "text": "if the remove operation is not supported by this list iterator", "labels": ["Ambiguous"]}
{"id": 11854, "text": "if neither next nor previous have been called, or remove or add have been called after the last call to next or previous", "labels": ["Ambiguous"]}
{"id": 11855, "text": "if the set operation is not supported by this list iterator", "labels": ["Ambiguous"]}
{"id": 11856, "text": "if the class of the specified element prevents it from being added to this list", "labels": ["Ambiguous"]}
{"id": 11857, "text": "if some aspect of the specified element prevents it from being added to this list", "labels": ["Ambiguous"]}
{"id": 11858, "text": "if the add method is not supported by this list iterator", "labels": ["Ambiguous"]}
{"id": 11859, "text": "if some aspect of this element prevents it from being added to this list", "labels": ["Ambiguous"]}
{"id": 11860, "text": "if the type of the specified element is incompatible with this list (optional)", "labels": ["Ambiguous"]}
{"id": 11861, "text": "if the specified element is null and this list does not permit null elements (optional)", "labels": ["NullnessNotAllowed"]}
{"id": 11862, "text": "if the runtime type of the specified array is not a supertype of the runtime type of every element in this list", "labels": ["Ambiguous"]}
{"id": 11863, "text": "if the add operation is not supported by this list", "labels": ["Ambiguous"]}
{"id": 11864, "text": "if the specified element is null and this list does not permit null elements", "labels": ["NullnessNotAllowed"]}
{"id": 11865, "text": "if some property of this element prevents it from being added to this list", "labels": ["Ambiguous"]}
{"id": 11866, "text": "if the remove operation is not supported by this list", "labels": ["Ambiguous"]}
{"id": 11867, "text": "if the types of one or more elements in the specified collection are incompatible with this list (optional)", "labels": ["Ambiguous"]}
{"id": 11868, "text": "if the specified collection contains one or more null elements and this list does not permit null elements (optional), or if the specified collection is null", "labels": ["NullnessNotAllowed"]}
{"id": 11869, "text": "if the addAll operation is not supported by this list", "labels": ["Ambiguous"]}
{"id": 11870, "text": "if the class of an element of the specified collection prevents it from being added to this list", "labels": ["Ambiguous"]}
{"id": 11871, "text": "if the specified collection contains one or more null elements and this list does not permit null elements, or if the specified collection is null", "labels": ["NullnessNotAllowed"]}
{"id": 11872, "text": "if some property of an element of the specified collection prevents it from being added to this list", "labels": ["Ambiguous"]}
{"id": 11873, "text": "if the index is out of range (index < 0 || index > size())", "labels": ["RangeLimitation"]}
{"id": 11874, "text": "if the retainAll operation is not supported by this list", "labels": ["Ambiguous"]}
{"id": 11875, "text": "if the class of an element of this list is incompatible with the specified collection (optional)", "labels": ["Ambiguous"]}
{"id": 11876, "text": "if this list contains a null element and the specified collection does not permit null elements (optional), or if the specified collection is null", "labels": ["NullnessNotAllowed"]}
{"id": 11877, "text": "if this list is unmodifiable.", "labels": ["Ambiguous"]}
{"id": 11878, "text": "Implementations may throw this exception if an element cannot be replaced or if, in general, modification is not supported", "labels": ["Ambiguous"]}
{"id": 11879, "text": "if the specified operator is null or if the operator result is a null value and this list does not permit null elements (optional)", "labels": ["NullnessNotAllowed"]}
{"id": 11880, "text": "if the list contains elements that are not mutually comparable using the specified comparator", "labels": ["Ambiguous"]}
{"id": 11881, "text": "if the list's list-iterator does not support the set operation", "labels": ["Ambiguous"]}
{"id": 11882, "text": "(optional) if the comparator is found to violate the Comparator contract", "labels": ["Ambiguous"]}
{"id": 11883, "text": "if the clear operation is not supported by this list", "labels": ["Ambiguous"]}
{"id": 11884, "text": "if some property of the specified element prevents it from being added to this list", "labels": ["Ambiguous"]}
{"id": 11885, "text": "for an illegal endpoint index value (fromIndex < 0 || toIndex > size || fromIndex > toIndex)", "labels": ["RangeLimitation"]}
{"id": 11886, "text": "if coll is null, or if it contains any nulls", "labels": ["NullnessNotAllowed"]}
{"id": 11887, "text": "Thrown in case of service configuration error or if the implementation is not available or cannot be instantiated.", "labels": ["Ambiguous"]}
{"id": 11888, "text": "if factoryClassName is null, or the factory class cannot be loaded, instantiated.", "labels": ["NullnessNotAllowed"]}
{"id": 11889, "text": "Thrown if there are errors when parsing the Source or it is not possible to create a Transformer instance.", "labels": ["Ambiguous"]}
{"id": 11890, "text": "An Exception is thrown if an error occurings during parsing of the source.", "labels": ["Ambiguous"]}
{"id": 11891, "text": "if this TransformerFactory or the Transformers or Templates it creates cannot support this feature.", "labels": ["Ambiguous"]}
{"id": 11892, "text": "If the name parameter is null.", "labels": ["NullnessNotAllowed"]}
{"id": 11893, "text": "When implementation does not recognize the attribute.", "labels": ["Ambiguous"]}
{"id": 11894, "text": "When listener is null", "labels": ["NullnessNotAllowed"]}
{"id": 11895, "text": "if the builder has already transitioned to the built state", "labels": ["Ambiguous"]}
{"id": 11896, "text": "If b is null.", "labels": ["NullnessNotAllowed"]}
{"id": 11897, "text": "If off is negative, len is negative, or len is greater than b.length - off", "labels": ["RangeLimitation"]}
{"id": 11898, "text": "if member < 1", "labels": ["RangeLimitation"]}
{"id": 11899, "text": "if a null range is specified or if a non-null range is specified with lowerBound less than 1", "labels": ["RangeLimitation"]}
{"id": 11900, "text": "if the destroy operation fails.", "labels": ["Ambiguous"]}
{"id": 11901, "text": "if the caller does not have permission to destroy this Object.", "labels": ["Ambiguous"]}
{"id": 11902, "text": "If the set contains an invalid combination of options", "labels": ["Ambiguous"]}
{"id": 11903, "text": "If the file is associated with a provider that does not support creating asynchronous file channels, or an unsupported open option is specified, or the array contains an attribute that cannot be set atomically when creating the file", "labels": ["Ambiguous"]}
{"id": 11904, "text": "If a security manager is installed and it denies an unspecified permission required by the implementation.", "labels": ["Ambiguous"]}
{"id": 11905, "text": "In the case of the default provider, the SecurityManager.checkRead(String) method is invoked to check read access if the file is opened for reading.", "labels": ["Ambiguous"]}
{"id": 11906, "text": "The SecurityManager.checkWrite(String) method is invoked to check write access if the file is opened for writing", "labels": ["Ambiguous"]}
{"id": 11907, "text": "If the file is associated with a provider that does not support creating file channels, or an unsupported open option is specified", "labels": ["Ambiguous"]}
{"id": 11908, "text": "If this channel was not opened for writing", "labels": ["Ambiguous"]}
{"id": 11909, "text": "If this channel is closed", "labels": ["Ambiguous"]}
{"id": 11910, "text": "If the new size is negative", "labels": ["RangeLimitation"]}
{"id": 11911, "text": "If some other I/O error occurs", "labels": ["Ambiguous"]}
{"id": 11912, "text": "If a lock that overlaps the requested region is already held by this Java virtual machine, or there is already a pending attempt to lock an overlapping region", "labels": ["Ambiguous"]}
{"id": 11913, "text": "If the preconditions on the parameters do not hold", "labels": ["Ambiguous"]}
{"id": 11914, "text": "If shared is true but this channel was not opened for reading", "labels": ["Ambiguous"]}
{"id": 11915, "text": "If shared is false but this channel was not opened for writing", "labels": ["Ambiguous"]}
{"id": 11916, "text": "If a lock is already held by this Java virtual machine, or there is already a pending attempt to lock a region", "labels": ["Ambiguous"]}
{"id": 11917, "text": "If a lock that overlaps the requested region is already held by this Java virtual machine, or if another thread is already blocked in this method and is attempting to lock an overlapping region of the same file", "labels": ["Ambiguous"]}
{"id": 11918, "text": "If the position is negative or the buffer is read-only", "labels": ["RangeLimitation"]}
{"id": 11919, "text": "If this channel was not opened for reading", "labels": ["Ambiguous"]}
{"id": 11920, "text": "If the position is negative", "labels": ["RangeLimitation"]}
{"id": 11921, "text": "if any one of the arguments is null", "labels": ["NullnessNotAllowed"]}
{"id": 11922, "text": "if the arguments are inconsistent", "labels": ["Ambiguous"]}
{"id": 11923, "text": "if a ZIP format error has occurred", "labels": ["Ambiguous"]}
{"id": 11924, "text": "if a security manager exists and its checkRead method doesn't allow read access to the file.", "labels": ["Ambiguous"]}
{"id": 11925, "text": "if a security manager exists and its checkRead method doesn't allow read access to the file, or its checkDelete method doesn't allow deleting the file when the OPEN_DELETE flag is set.", "labels": ["Ambiguous"]}
{"id": 11926, "text": "if the mode argument is invalid", "labels": ["Ambiguous"]}
{"id": 11927, "text": "if a security manager exists and its checkRead method doesn't allow read access to the file,or its checkDelete method doesn't allow deleting the file when the OPEN_DELETE flag is set", "labels": ["Ambiguous"]}
{"id": 11928, "text": "if a security manager exists and its checkRead method doesn't allow read access to the file", "labels": ["Ambiguous"]}
{"id": 11929, "text": "if the zip file has been closed", "labels": ["Ambiguous"]}
{"id": 11930, "text": "If the socket is already bound", "labels": ["Ambiguous"]}
{"id": 11931, "text": "If the type of the given address is not supported", "labels": ["Ambiguous"]}
{"id": 11932, "text": "If a security manager has been installed and its checkListen method denies the operation", "labels": ["Ambiguous"]}
{"id": 11933, "text": "If another thread closes this channel while the accept operation is in progress", "labels": ["Ambiguous"]}
{"id": 11934, "text": "If another thread interrupts the current thread while the accept operation is in progress, thereby closing the channel and setting the current thread's interrupt status", "labels": ["Ambiguous"]}
{"id": 11935, "text": "If this channel's socket has not yet been bound", "labels": ["Ambiguous"]}
{"id": 11936, "text": "If a security manager has been installed and it does not permit access to the remote endpoint of the new connection", "labels": ["Ambiguous"]}
{"id": 11937, "text": "If the channel is closed", "labels": ["Ambiguous"]}
{"id": 11938, "text": "if the axis parameter is invalid", "labels": ["Ambiguous"]}
{"id": 11939, "text": "if any of the specified parameters with the exception of otherPrimeInfo is null", "labels": ["NullnessNotAllowed"]}
{"id": 11940, "text": "if an empty, i.e.", "labels": ["Ambiguous"]}
{"id": 11941, "text": "if any of the specified parameters with the exception of otherPrimeInfo and keyParams is null", "labels": ["NullnessNotAllowed"]}
{"id": 11942, "text": "if this object factory encountered an exception while attempting to create an object, and no other object factories are to be tried.", "labels": ["Ambiguous"]}
{"id": 11943, "text": "If a naming exception was encountered.", "labels": ["Ambiguous"]}
{"id": 11944, "text": "If an I/O error occurs.", "labels": ["Ambiguous"]}
{"id": 11945, "text": "If the listen key is invalid", "labels": ["Ambiguous"]}
{"id": 11946, "text": "if fileType is null", "labels": ["NullnessNotAllowed"]}
{"id": 11947, "text": "if fileType or stream are null", "labels": ["NullnessNotAllowed"]}
{"id": 11948, "text": "if an I/O exception occurs", "labels": ["Ambiguous"]}
{"id": 11949, "text": "if the file type is not supported by the system", "labels": ["Ambiguous"]}
{"id": 11950, "text": "if stream or fileType or out are null", "labels": ["NullnessNotAllowed"]}
{"id": 11951, "text": "if key is null.", "labels": ["NullnessNotAllowed"]}
{"id": 11952, "text": "if the given key material, starting at offset inclusive, is shorter than 24 bytes", "labels": ["Ambiguous"]}
{"id": 11953, "text": "if elements of the specified collection cannot be compared to one another according to the priority queue's ordering", "labels": ["Ambiguous"]}
{"id": 11954, "text": "if the specified element cannot be compared with elements currently in the priority queue according to the priority queue's ordering", "labels": ["Ambiguous"]}
{"id": 11955, "text": "if the offset is out of range", "labels": ["RangeLimitation"]}
{"id": 11956, "text": "if it's not a dynamically generated event", "labels": ["Ambiguous"]}
{"id": 11957, "text": "if index is less than 0 or greater than or equal to the number of fields specified for the event", "labels": ["RangeLimitation"]}
{"id": 11958, "text": "always", "labels": ["Ambiguous"]}
{"id": 11959, "text": "will be thrown if index is >= length of the text, or < -1", "labels": []}
{"id": 11960, "text": "if hostname is null", "labels": []}
{"id": 11961, "text": "if hostname is illegal", "labels": []}
{"id": 11962, "text": "if encoded is null", "labels": []}
{"id": 11963, "text": "if encoded is illegal", "labels": []}
{"id": 11964, "text": "if no object for the given key can be found", "labels": []}
{"id": 11965, "text": "if baseName, targetLocale, or module is null", "labels": []}
{"id": 11966, "text": "if a security manager exists and the caller is not the specified module and doesn't have RuntimePermission(\"getClassLoader\")", "labels": []}
{"id": 11967, "text": "if no resource bundle for the specified base name and locale can be found in the specified module", "labels": []}
{"id": 11968, "text": "if baseName, locale, or loader is null", "labels": []}
{"id": 11969, "text": "if no resource bundle for the specified base name can be found", "labels": []}
{"id": 11970, "text": "if baseName, targetLocale, loader, or control is null", "labels": []}
{"id": 11971, "text": "if the given control doesn't perform properly (e.g., control.getCandidateLocales returns null.)", "labels": []}
{"id": 11972, "text": "Note that validation of control is performed as needed.", "labels": []}
{"id": 11973, "text": "if this method is called in a named module", "labels": []}
{"id": 11974, "text": "if type is not a reference type", "labels": []}
{"id": 11975, "text": "if the handle's method type cannot be adjusted to take the given number of arguments, or if the handle's return type cannot be adjusted to the desired type", "labels": []}
{"id": 11976, "text": "if an argument or the result produced by invoking the handle cannot be converted by reference casting", "labels": []}
{"id": 11977, "text": "if the given parameters are inappropriate for this key pair generator.", "labels": []}
{"id": 11978, "text": "if a naming exception is encountered", "labels": []}
{"id": 11979, "text": "if some property of the specified element prevents it from being added to this queue", "labels": []}
{"id": 11980, "text": "if the class of the specified element is incompatible with this queue (optional)", "labels": []}
{"id": 11981, "text": "if the specified element is null (optional)", "labels": []}
{"id": 11982, "text": "if addition of elements is not supported by the specified collection", "labels": []}
{"id": 11983, "text": "if the class of an element of this queue prevents it from being added to the specified collection", "labels": []}
{"id": 11984, "text": "if the specified collection is null", "labels": []}
{"id": 11985, "text": "if the specified collection is this queue, or some property of an element of this queue prevents it from being added to the specified collection", "labels": []}
{"id": 11986, "text": "if the compressed data format is invalid", "labels": ["Ambiguous"]}
{"id": 11987, "text": "if the given output buffer is read-only", "labels": []}
{"id": 11988, "text": "if b is true and GraphicsEnvironment.isHeadless() returns true", "labels": []}
{"id": 11989, "text": "if the drop mode is unsupported or null", "labels": []}
{"id": 11990, "text": "if numeric overflow would occur while calling instant.toEpochMilli().", "labels": []}
{"id": 11991, "text": "if pipeSize <= 0.", "labels": []}
{"id": 11992, "text": "If the pipe is broken, unconnected, closed, or if an I/O error occurs.", "labels": []}
{"id": 11993, "text": "if the pipe is unconnected, broken, closed, or if an I/O error occurs.", "labels": []}
{"id": 11994, "text": "if the pipe is broken, unconnected, closed, or if an I/O error occurs.", "labels": []}
{"id": 11995, "text": "may be thrown by any filter module, and if caught, must be rethrown again.", "labels": []}
{"id": 11996, "text": "if either exchange or chain are null", "labels": []}
{"id": 11997, "text": "if this implementation does not support storing native libraries in this way.", "labels": []}
{"id": 11998, "text": "This exception should be caught by the MBean server and re-thrown as an MBeanRegistrationException.", "labels": []}
{"id": 11999, "text": "If a problem occurred while writing.", "labels": []}
{"id": 12000, "text": "If this implementation does not support this operation.", "labels": []}
{"id": 12001, "text": "if a problem occurred while reading.", "labels": []}
{"id": 12002, "text": "if the class for the object being restored cannot be found.", "labels": []}
{"id": 12003, "text": "if this implementation does not support this operation.", "labels": []}
{"id": 12004, "text": "if the MBean is not to be loaded for some reason.", "labels": []}
{"id": 12005, "text": "The exception will be added to the set returned by getMBeansFromURL.", "labels": []}
{"id": 12006, "text": "if the key is null.", "labels": []}
{"id": 12007, "text": "if obj or m or args or any of the elements of args is null.", "labels": []}
{"id": 12008, "text": "if dscp is null", "labels": []}
{"id": 12009, "text": "if dgl is null", "labels": []}
{"id": 12010, "text": "if dragImage is not null and imageOffset is null", "labels": []}
{"id": 12011, "text": "if t is null", "labels": []}
{"id": 12012, "text": "if the Component associated with the trigger event is null.", "labels": []}
{"id": 12013, "text": "if the DragSource for the trigger event is null.", "labels": []}
{"id": 12014, "text": "if the drag action for the trigger event is DnDConstants.ACTION_NONE.", "labels": []}
{"id": 12015, "text": "if the source actions for the DragGestureRecognizer associated with the trigger event are equal to DnDConstants.ACTION_NONE.", "labels": []}
{"id": 12016, "text": "if the specified object is null", "labels": []}
{"id": 12017, "text": "if the specified object's type prevents it from being compared to this object.", "labels": []}
{"id": 12018, "text": "if the specified listener has already been added.", "labels": []}
{"id": 12019, "text": "if ks is null.", "labels": []}
{"id": 12020, "text": "if the hints are not one of the legal values.", "labels": []}
{"id": 12021, "text": "if an I/O error occurs when attempting a connection.", "labels": []}
{"id": 12022, "text": "if an I/O error occurs when creating the queue.", "labels": []}
{"id": 12023, "text": "if an I/O error occurs when shutting down this socket.", "labels": []}
{"id": 12024, "text": "if the object's class does not support the Cloneable interface.", "labels": []}
{"id": 12025, "text": "Subclasses that override the clone method can also throw this exception to indicate that an instance cannot be cloned.", "labels": []}
{"id": 12026, "text": "if the current thread is not the owner of this object's monitor.", "labels": []}
{"id": 12027, "text": "if the current thread is not the owner of the object's monitor", "labels": []}
{"id": 12028, "text": "if any thread interrupted the current thread before or while the current thread was waiting.", "labels": []}
{"id": 12029, "text": "The interrupted status of the current thread is cleared when this exception is thrown.", "labels": []}
{"id": 12030, "text": "if timeoutMillis is negative", "labels": []}
{"id": 12031, "text": "if timeoutMillis is negative, or if the value of nanos is out of range", "labels": []}
{"id": 12032, "text": "if a security manager is present and the caller doesn't have FlightRecorderPermission(\"registerEvent\")", "labels": []}
{"id": 12033, "text": "if the target virtual machine does not support this operation - see canGetMethodReturnValues()", "labels": []}
{"id": 12034, "text": "DOMSTRING_SIZE_ERR: Raised when it would return more characters than fit in a DOMString variable on the implementation platform.", "labels": []}
{"id": 12035, "text": "NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly and if it is not defined to be null.", "labels": []}
{"id": 12036, "text": "HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does not allow children of the type of the newChild node, or if the node to insert is one of this node's ancestors or this node itself, or if this node is of type Document and the DOM application attempts to insert a second DocumentType or Element node.", "labels": []}
{"id": 12037, "text": "WRONG_DOCUMENT_ERR: Raised if newChild was created from a different document than the one that created this node.", "labels": []}
{"id": 12038, "text": "NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly or if the parent of the node being inserted is readonly.", "labels": []}
{"id": 12039, "text": "NOT_FOUND_ERR: Raised if refChild is not a child of this node.", "labels": []}
{"id": 12040, "text": "NOT_SUPPORTED_ERR: if this node is of type Document, this exception might be raised if the DOM implementation doesn't support the insertion of a DocumentType or Element node.", "labels": []}
{"id": 12041, "text": "HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does not allow children of the type of the newChild node, or if the node to put in is one of this node's ancestors or this node itself, or if this node is of type Document and the result of the replacement operation would add a second DocumentType or Element on the Document node.", "labels": []}
{"id": 12042, "text": "NO_MODIFICATION_ALLOWED_ERR: Raised if this node or the parent of the new node is readonly.", "labels": []}
{"id": 12043, "text": "NOT_FOUND_ERR: Raised if oldChild is not a child of this node.", "labels": []}
{"id": 12044, "text": "NOT_SUPPORTED_ERR: if this node is of type Document, this exception might be raised if the DOM implementation doesn't support the replacement of the DocumentType child or Element child.", "labels": []}
{"id": 12045, "text": "HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does not allow children of the type of the newChild node, or if the node to append is one of this node's ancestors or this node itself, or if this node is of type Document and the DOM application attempts to append a second DocumentType or Element node.", "labels": []}
{"id": 12046, "text": "NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly or if the previous parent of the node being inserted is readonly.", "labels": []}
{"id": 12047, "text": "NOT_SUPPORTED_ERR: if the newChild node is a child of the Document node, this exception might be raised if the DOM implementation doesn't support the removal of the DocumentType child or Element child.", "labels": []}
{"id": 12048, "text": "INVALID_CHARACTER_ERR: Raised if the specified prefix contains an illegal character according to the XML version in use specified in the Document.xmlVersion attribute.", "labels": ["Ambiguous"]}
{"id": 12049, "text": "NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.", "labels": []}
{"id": 12050, "text": "NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly.", "labels": []}
{"id": 12051, "text": "if the operation fails for whatever reason", "labels": []}
{"id": 12052, "text": "if the access mode type does not match the caller's symbolic type descriptor.", "labels": []}
{"id": 12053, "text": "if the access mode type matches the caller's symbolic type descriptor, but a reference cast fails.", "labels": []}
{"id": 12054, "text": "if the access mode is unsupported for this VarHandle.", "labels": []}
{"id": 12055, "text": "if the access mode type is not compatible with the caller's symbolic type descriptor.", "labels": []}
{"id": 12056, "text": "if the access mode type is compatible with the caller's symbolic type descriptor, but a reference cast fails.", "labels": []}
{"id": 12057, "text": "if the computation was cancelled", "labels": []}
{"id": 12058, "text": "if the computation threw an exception", "labels": []}
{"id": 12059, "text": "if the current thread was interrupted while waiting", "labels": []}
{"id": 12060, "text": "if the wait timed out", "labels": []}
{"id": 12061, "text": "if id is KEY_TYPED and keyChar is CHAR_UNDEFINED; or if id is KEY_TYPED and keyCode is not VK_UNDEFINED; or if id is KEY_TYPED and keyLocation is not KEY_LOCATION_UNKNOWN; or if keyLocation is not one of the legal values enumerated above.", "labels": []}
{"id": 12062, "text": "if id is KEY_TYPED and keyChar is CHAR_UNDEFINED; or if id is KEY_TYPED and keyCode is not VK_UNDEFINED", "labels": []}
{"id": 12063, "text": "if this method is not supported", "labels": []}
{"id": 12064, "text": "if the value of any field is out of range, or if the day-of-month is invalid for the month", "labels": ["Ambiguous"]}
{"id": 12065, "text": "if unable to convert to a MonthDay", "labels": []}
{"id": 12066, "text": "if the month-of-year value is invalid", "labels": ["Ambiguous"]}
{"id": 12067, "text": "if the day-of-month value is invalid, or if the day-of-month is invalid for the month", "labels": ["Ambiguous"]}
{"id": 12068, "text": "if the year is outside the valid range of years", "labels": []}
{"id": 12069, "text": "if any of the actual type arguments refers to a non-existent type declaration", "labels": []}
{"id": 12070, "text": "if any of the actual type parameters refer to a parameterized type that cannot be instantiated for any reason", "labels": []}
{"id": 12071, "text": "if the owner type refers to a non-existent type declaration", "labels": []}
{"id": 12072, "text": "if the owner type refers to a parameterized type that cannot be instantiated for any reason", "labels": []}
{"id": 12073, "text": "if there was an error during creation of the converter", "labels": []}
{"id": 12074, "text": "if the given key is inappropriate for initializing this cipher, or requires algorithm parameters that cannot be determined from the given key.", "labels": []}
{"id": 12075, "text": "if opmode is WRAP_MODE or UNWRAP_MODE is not implemented by the cipher.", "labels": []}
{"id": 12076, "text": "if the given key is inappropriate for initializing this cipher", "labels": []}
{"id": 12077, "text": "if the given algorithm parameters are inappropriate for this cipher, or if this cipher requires algorithm parameters and params is null.", "labels": []}
{"id": 12078, "text": "if there is insufficient space in the output buffer", "labels": []}
{"id": 12079, "text": "if either parameter is null", "labels": []}
{"id": 12080, "text": "if this cipher is a block cipher, no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided.", "labels": []}
{"id": 12081, "text": "if this cipher is in decryption mode, and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes", "labels": []}
{"id": 12082, "text": "if this cipher is decrypting in an AEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value", "labels": []}
{"id": 12083, "text": "if this cipher is a block cipher, no padding has been requested, and the length of the encoding of the key to be wrapped is not a multiple of the block size.", "labels": []}
{"id": 12084, "text": "if it is impossible or unsafe to wrap the key with this cipher (e.g., a hardware protected key is being passed to a software-only cipher).", "labels": []}
{"id": 12085, "text": "if this method is not supported.", "labels": []}
{"id": 12086, "text": "if no installed providers can create keys of type wrappedKeyType for the wrappedKeyAlgorithm.", "labels": []}
{"id": 12087, "text": "if wrappedKey does not represent a wrapped key of type wrappedKeyType for the wrappedKeyAlgorithm.", "labels": []}
{"id": 12088, "text": "if key is invalid.", "labels": ["Ambiguous"]}
{"id": 12089, "text": "if this cipher is in a wrong state (e.g., has not been initialized), does not accept AAD, or if operating in either GCM or CCM mode and one of the update methods has already been called for the active encryption/decryption operation", "labels": []}
{"id": 12090, "text": "if this method has not been overridden by an implementation", "labels": []}
{"id": 12091, "text": "SYNTAX_ERR: Raised if the new value has a syntax error and is unparsable.", "labels": []}
{"id": 12092, "text": "NO_MODIFICATION_ALLOWED_ERR: Raised if this property is readonly.", "labels": []}
{"id": 12093, "text": "if the value indicated does not fall within the allowable range", "labels": []}
{"id": 12094, "text": "if either from or to value does not fall within the allowable range", "labels": []}
{"id": 12095, "text": "if the clipboard is currently unavailable", "labels": []}
{"id": 12096, "text": "if this clipboard is currently unavailable", "labels": []}
{"id": 12097, "text": "if the engine is not initialized properly, if this signature algorithm is unable to process the input data provided, or if len is less than the actual signature length.", "labels": []}
{"id": 12098, "text": "if the engine is not initialized properly, the passed-in signature is improperly encoded or of the wrong type, if this signature algorithm is unable to process the input data provided, etc.", "labels": []}
{"id": 12099, "text": "if this method is not overridden by a provider", "labels": []}
{"id": 12100, "text": "if the country of the given locale is not a supported ISO 3166 country code.", "labels": []}
{"id": 12101, "text": "if newFormats is null", "labels": []}
{"id": 12102, "text": "if formatElementIndex is equal to or larger than the number of format elements in the pattern string", "labels": []}
{"id": 12103, "text": "if an argument in the arguments array is not of the type expected by the format element(s) that use it.", "labels": []}
{"id": 12104, "text": "if result is null", "labels": []}
{"id": 12105, "text": "if the pattern is invalid, or if an argument in the arguments array is not of the type expected by the format element(s) that use it.", "labels": ["Ambiguous"]}
{"id": 12106, "text": "if arguments is null.", "labels": []}
{"id": 12107, "text": "if pos is null for a non-null source string.", "labels": []}
{"id": 12108, "text": "if pos is null.", "labels": []}
{"id": 12109, "text": "if the name is null.", "labels": []}
{"id": 12110, "text": "if the name is not * or one of the allowed names or a comma-separated list of the allowed names.", "labels": []}
{"id": 12111, "text": "If the specified protocol family is not supported.", "labels": []}
{"id": 12112, "text": "If this channel is already connected", "labels": []}
{"id": 12113, "text": "If another thread closes this channel while the connect operation is in progress", "labels": []}
{"id": 12114, "text": "If another thread interrupts the current thread while the connect operation is in progress, thereby closing the channel and setting the current thread's interrupt status", "labels": []}
{"id": 12115, "text": "If the given remote address is not fully resolved", "labels": []}
{"id": 12116, "text": "If the type of the given remote address is not supported", "labels": []}
{"id": 12117, "text": "If a security manager has been installed and it does not permit access to the given remote address", "labels": []}
{"id": 12118, "text": "If another thread closes this channel while the read operation is in progress", "labels": []}
{"id": 12119, "text": "If another thread interrupts the current thread while the read operation is in progress, thereby closing the channel and setting the current thread's interrupt status", "labels": []}
{"id": 12120, "text": "If a security manager has been installed and it does not permit datagrams to be accepted from the datagram's sender", "labels": []}
{"id": 12121, "text": "If this channel is connected to a different address from that specified by target", "labels": []}
{"id": 12122, "text": "If a security manager has been installed and it does not permit datagrams to be sent to the given address", "labels": []}
{"id": 12123, "text": "If this channel's socket is not connected", "labels": []}
{"id": 12124, "text": "If another thread closes this channel while the write operation is in progress", "labels": []}
{"id": 12125, "text": "If another thread interrupts the current thread while the write operation is in progress, thereby closing the channel and setting the current thread's interrupt status", "labels": []}
{"id": 12126, "text": "INDEX_SIZE_ERR: Raised if the specified offset is negative or greater than the number of 16-bit units in data.", "labels": []}
{"id": 12127, "text": "NO_MODIFICATION_ALLOWED_ERR: Raised if one of the Text nodes being replaced is readonly.", "labels": []}
{"id": 12128, "text": "if registration fails (e.g., database update failure, etc).", "labels": []}
{"id": 12129, "text": "if group referred to in desc is not registered with this system", "labels": []}
{"id": 12130, "text": "if remote call fails", "labels": []}
{"id": 12131, "text": "if group registration fails", "labels": []}
{"id": 12132, "text": "if unregister fails (e.g., database update failure, etc).", "labels": []}
{"id": 12133, "text": "if group is not registered", "labels": []}
{"id": 12134, "text": "if a database access error occurs or the Connection object within this CachedRowSet object is in auto-commit mode", "labels": []}
{"id": 12135, "text": "if stream is null.", "labels": []}
{"id": 12136, "text": "if cacheDir is non-null but is not a directory.", "labels": []}
{"id": 12137, "text": "if a cache file cannot be created.", "labels": []}
{"id": 12138, "text": "if pos is smaller than the flushed position.", "labels": []}
{"id": 12139, "text": "if any other I/O error occurs.", "labels": []}
{"id": 12140, "text": "if b is null.", "labels": []}
{"id": 12141, "text": "if off is negative, len is negative, or len is greater than b.length - off", "labels": []}
{"id": 12142, "text": "if a ZIP file error has occurred", "labels": []}
{"id": 12143, "text": "if an unsupported data source locking level is set.", "labels": []}
{"id": 12144, "text": "if the specified waiting time elapses before another thread enters the exchange", "labels": []}
{"id": 12145, "text": "If nextSibling is not a sibling of node or node is null and nextSibling is not null.", "labels": []}
{"id": 12146, "text": "If nextSibling is not null and nextSibling is not a child of node or node is null and nextSibling is not null.", "labels": []}
{"id": 12147, "text": "If nextSibling is not a descendant of node.", "labels": []}
{"id": 12148, "text": "If node is null and nextSibling is not null.", "labels": []}
{"id": 12149, "text": "INDEX_SIZE_ERR: Raised if the specified index is greater than the number of rows or if the index is negative.", "labels": []}
{"id": 12150, "text": "if the line cannot be opened due to resource restrictions", "labels": []}
{"id": 12151, "text": "if the buffer size does not represent an integral number of sample frames, or if format is not fully specified or invalid", "labels": ["Ambiguous"]}
{"id": 12152, "text": "if the line is already open", "labels": []}
{"id": 12153, "text": "if the line cannot be opened due to security restrictions", "labels": []}
{"id": 12154, "text": "if format is not fully specified or invalid", "labels": ["Ambiguous"]}
{"id": 12155, "text": "if the requested number of bytes does not represent an integral number of sample frames, or if len is negative", "labels": []}
{"id": 12156, "text": "if off is negative, or off+len is greater than the length of the array b", "labels": []}
{"id": 12157, "text": "if the resourceBundleName is non-null and no corresponding resource can be found.", "labels": []}
{"id": 12158, "text": "if the Logger already exists and uses a different resource bundle name; or if resourceBundleName is null but the named logger has a resource bundle set.", "labels": []}
{"id": 12159, "text": "if a security manager exists, this logger is not anonymous, and the caller does not have LoggingPermission(\"control\").", "labels": []}
{"id": 12160, "text": "if a security manager exists and if the caller does not have LoggingPermission(\"control\").", "labels": []}
{"id": 12161, "text": "if categories is null, or if one of the categories is not an allowed service type.", "labels": []}
{"id": 12162, "text": "if providerClass is null, or if it is not one of the allowed service types.", "labels": []}
{"id": 12163, "text": "if provider is null.", "labels": []}
{"id": 12164, "text": "if there is no category corresponding to category.", "labels": []}
{"id": 12165, "text": "if provider does not implement the Class defined by category.", "labels": []}
{"id": 12166, "text": "if providers is null or contains a null entry.", "labels": []}
{"id": 12167, "text": "if provider does not implement the class defined by category.", "labels": []}
{"id": 12168, "text": "if providerClass is null.", "labels": []}
{"id": 12169, "text": "if either provider is null or they are the same object.", "labels": []}
{"id": 12170, "text": "if unable to truncate", "labels": []}
{"id": 12171, "text": "if the amount cannot be calculated, or the end temporal cannot be converted to a LocalTime", "labels": []}
{"id": 12172, "text": "if the minimum is greater than the maximum", "labels": []}
{"id": 12173, "text": "if the minimum is greater than the smallest maximum, or the smallest maximum is greater than the largest maximum", "labels": []}
{"id": 12174, "text": "When the supplied index does not identify an attribute.", "labels": []}
{"id": 12175, "text": "if the remove operation is not supported by this iterator", "labels": []}
{"id": 12176, "text": "if the next method has not yet been called, or the remove method has already been called after the last call to the next method", "labels": []}
{"id": 12177, "text": "if the specified action is null", "labels": []}
{"id": 12178, "text": "if an error occurs when setting the Predicate object", "labels": []}
{"id": 12179, "text": "if g or c is null", "labels": []}
{"id": 12180, "text": "if the parameter s is null", "labels": []}
{"id": 12181, "text": "if the underlying provider does not implement the operation", "labels": []}
{"id": 12182, "text": "if the attribute name is invalid", "labels": ["Ambiguous"]}
{"id": 12183, "text": "if the name is not a Attributes.Name or the value is not a String", "labels": []}
{"id": 12184, "text": "if tag == null.", "labels": []}
{"id": 12185, "text": "if type is not one of the TIFFTag.TIFF_* data type constants.", "labels": []}
{"id": 12186, "text": "if type is an unacceptable data type for the supplied TIFFTag.", "labels": []}
{"id": 12187, "text": "if count < 0.", "labels": []}
{"id": 12188, "text": "if count < 1 and type is TIFF_RATIONAL or TIFF_SRATIONAL.", "labels": []}
{"id": 12189, "text": "if count != 1 and type is TIFF_IFD_POINTER.", "labels": []}
{"id": 12190, "text": "if data == null.", "labels": []}
{"id": 12191, "text": "if data is an instance of a class incompatible with the specified type.", "labels": []}
{"id": 12192, "text": "if the size of the data array is wrong.", "labels": []}
{"id": 12193, "text": "if the type of the data array is TIFF_LONG, TIFF_RATIONAL, or TIFF_IFD_POINTER and any of the elements is negative or greater than 0xffffffff.", "labels": []}
{"id": 12194, "text": "if value is not in [0,0xffffffff].", "labels": []}
{"id": 12195, "text": "if value is in [0,0xffff] and TIFF_SHORT is an unacceptable type for the TIFFTag, or if value is in [0x10000,0xffffffff] and TIFF_LONG is an unacceptable type for the TIFFTag.", "labels": []}
{"id": 12196, "text": "If the Node parameter content does not adhere to the TIFFField element structure defined by the TIFF native image metadata format specification, or if the combination of node attributes and data is not legal per the TIFFField(TIFFTag,int,int,Object) constructor specification.", "labels": []}
{"id": 12197, "text": "Note that a cause might be set on such an exception.", "labels": []}
{"id": 12198, "text": "if the field is not of type TIFF_BYTE, TIFF_SBYTE, or TIFF_UNDEFINED.", "labels": []}
{"id": 12199, "text": "if the field is not of one of the legal field types.", "labels": []}
{"id": 12200, "text": "if the generic signature of this generic declaration does not conform to the format specified in The Java\u2122 Virtual Machine Specification", "labels": []}
{"id": 12201, "text": "if the generic method signature does not conform to the format specified in The Java\u2122 Virtual Machine Specification", "labels": []}
{"id": 12202, "text": "if the underlying method's return type refers to a non-existent type declaration", "labels": []}
{"id": 12203, "text": "if the underlying method's return typed refers to a parameterized type that cannot be instantiated for any reason", "labels": []}
{"id": 12204, "text": "if any of the parameter types of the underlying executable refers to a non-existent type declaration", "labels": []}
{"id": 12205, "text": "if any of the underlying executable's parameter types refer to a parameterized type that cannot be instantiated for any reason", "labels": []}
{"id": 12206, "text": "if the underlying executable's throws clause refers to a non-existent type declaration", "labels": []}
{"id": 12207, "text": "if the underlying executable's throws clause refers to a parameterized type that cannot be instantiated for any reason", "labels": []}
{"id": 12208, "text": "if this Method object is enforcing Java language access control and the underlying method is inaccessible.", "labels": []}
{"id": 12209, "text": "if the underlying method throws an exception.", "labels": []}
{"id": 12210, "text": "if the specified object is null and the method is an instance method.", "labels": []}
{"id": 12211, "text": "if the initialization provoked by this method fails.", "labels": []}
{"id": 12212, "text": "if the annotation is of type Class and no definition can be found for the default class value.", "labels": []}
{"id": 12213, "text": "if the given annotation class is null", "labels": []}
{"id": 12214, "text": "If a format string contains an illegal syntax, a format specifier that is incompatible with the given arguments, insufficient arguments given the format string, or other illegal conditions.", "labels": []}
{"id": 12215, "text": "For specification of all possible formatting errors, see the Details section of the formatter class specification.", "labels": []}
{"id": 12216, "text": "If the format is null", "labels": []}
{"id": 12217, "text": "For specification of all possible formatting errors, see the Details section of the Formatter class specification.", "labels": []}
{"id": 12218, "text": "If start or end are negative, start is greater than end, or end is greater than csq.length()", "labels": []}
{"id": 12219, "text": "if target is a read only buffer", "labels": []}
{"id": 12220, "text": "If off is negative, or len is negative, or len is greater than cbuf.length - off", "labels": []}
{"id": 12221, "text": "If n is negative.", "labels": []}
{"id": 12222, "text": "If the stream has not been marked, or if the mark has been invalidated, or if the stream does not support reset(), or if some other I/O error occurs", "labels": []}
{"id": 12223, "text": "if an I/O error occurs when reading or writing", "labels": []}
{"id": 12224, "text": "if protocol is null", "labels": []}
{"id": 12225, "text": "if protocol is an invalid protocol specification", "labels": ["Ambiguous"]}
{"id": 12226, "text": "if no card is present in this terminal", "labels": []}
{"id": 12227, "text": "if a connection could not be established using the specified protocol or if a connection has previously been established using a different protocol", "labels": []}
{"id": 12228, "text": "if a SecurityManager exists and the caller does not have the required permission", "labels": []}
{"id": 12229, "text": "if the status could not be determined", "labels": []}
{"id": 12230, "text": "if timeout is negative", "labels": []}
{"id": 12231, "text": "if the operation failed", "labels": []}
{"id": 12232, "text": "If there are fewer than length floats remaining in this buffer", "labels": []}
{"id": 12233, "text": "If the preconditions on the offset and length parameters do not hold", "labels": []}
{"id": 12234, "text": "If there is insufficient space in this buffer for the remaining floats in the source buffer", "labels": []}
{"id": 12235, "text": "If the source buffer is this buffer", "labels": []}
{"id": 12236, "text": "If this buffer is read-only", "labels": []}
{"id": 12237, "text": "If there is insufficient space in this buffer", "labels": []}
{"id": 12238, "text": "If this buffer is backed by an array but is read-only", "labels": []}
{"id": 12239, "text": "If this buffer is not backed by an accessible array", "labels": []}
{"id": 12240, "text": "if it is not possible to start listening or if the connector server has been stopped.", "labels": []}
{"id": 12241, "text": "if the connector server has not been attached to an MBean server.", "labels": []}
{"id": 12242, "text": "if the server cannot be closed cleanly.", "labels": []}
{"id": 12243, "text": "When this exception is thrown, the server has already attempted to close all client connections.", "labels": []}
{"id": 12244, "text": "All client connections are closed except possibly those that generated exceptions when the server attempted to close them.", "labels": []}
{"id": 12245, "text": "if the call to mbsf.setMBeanServer fails with IllegalArgumentException.", "labels": []}
{"id": 12246, "text": "This includes the case where mbsf is null.", "labels": []}
{"id": 12247, "text": "if the selection mode isn't one of those allowed", "labels": []}
{"id": 12248, "text": "if either index is less than -1 (and neither index is -1)", "labels": []}
{"id": 12249, "text": "if this request is currently enabled or has been deleted.", "labels": []}
{"id": 12250, "text": "Filters may be added only to disabled requests.", "labels": []}
{"id": 12251, "text": "if trayIcon is null", "labels": []}
{"id": 12252, "text": "if the same instance of a TrayIcon is added more than once", "labels": []}
{"id": 12253, "text": "if the desktop system tray is missing", "labels": []}
{"id": 12254, "text": "If the source and/or destination image is not compatible with the types of images allowed by the class implementing this filter.", "labels": []}
{"id": 12255, "text": "if the row was invalid", "labels": ["Ambiguous"]}
{"id": 12256, "text": "if any of the elements would be moved out of the table's range", "labels": []}
{"id": 12257, "text": "if data is null.", "labels": []}
{"id": 12258, "text": "if the coordinates are not in bounds, or if obj is too small to hold the output.", "labels": []}
{"id": 12259, "text": "if the coordinates are not in bounds, or if iArray is too small to hold the output.", "labels": []}
{"id": 12260, "text": "if object activation fails", "labels": []}
{"id": 12261, "text": "on any I/O error", "labels": []}
{"id": 12262, "text": "if pos represents an invalid location within the document", "labels": []}
{"id": 12263, "text": "(will eventually be a BadLocationException) if pos is invalid", "labels": []}
{"id": 12264, "text": "when unable to start listening.", "labels": []}
{"id": 12265, "text": "Specific exceptions are dependent on the Connector implementation in use.", "labels": []}
{"id": 12266, "text": "when one of the connector arguments is invalid.", "labels": []}
{"id": 12267, "text": "when unable to stop listening.", "labels": []}
{"id": 12268, "text": "if the SyncResolver object is null.", "labels": []}
{"id": 12269, "text": "if inData is null.", "labels": []}
{"id": 12270, "text": "if either of inData or imageType is null.", "labels": []}
{"id": 12271, "text": "if an exception occurs", "labels": []}
{"id": 12272, "text": "if the specified initialization parameters are inappropriate for this CertStore", "labels": []}
{"id": 12273, "text": "if no Provider supports a CertStoreSpi implementation for the specified type", "labels": []}
{"id": 12274, "text": "if type is null", "labels": []}
{"id": 12275, "text": "if a CertStoreSpi implementation for the specified type is not available from the specified provider", "labels": []}
{"id": 12276, "text": "if a CertStoreSpi implementation for the specified type is not available from the specified Provider object", "labels": []}
{"id": 12277, "text": "if con is null.", "labels": []}
{"id": 12278, "text": "if other is null", "labels": []}
{"id": 12279, "text": "if action is null", "labels": []}
{"id": 12280, "text": "if listenerInterface is null", "labels": []}
{"id": 12281, "text": "if creating a Proxy for listenerInterface fails for any of the restrictions specified by Proxy.newProxyInstance(java.lang.ClassLoader, java.lang.Class<?>[], java.lang.reflect.InvocationHandler)", "labels": []}
{"id": 12282, "text": "if style is invalid.", "labels": []}
{"id": 12283, "text": "if locale is null.", "labels": []}
{"id": 12284, "text": "if the security manager's checkPermission denies PropertyPermission(\"user.timezone\", \"write\")", "labels": []}
{"id": 12285, "text": "if there is a database access error", "labels": []}
{"id": 12286, "text": "if the category or attribute are null", "labels": []}
{"id": 12287, "text": "if the category is not equal to the category of the attribute", "labels": []}
{"id": 12288, "text": "if cause is this throwable.", "labels": []}
{"id": 12289, "text": "if this throwable was created with TransformerException(Throwable) or TransformerException(String,Throwable), or this method has already been called on this throwable.", "labels": []}
{"id": 12290, "text": "if the specified stroke is null", "labels": []}
{"id": 12291, "text": "if the specified g is null", "labels": []}
{"id": 12292, "text": "if an unrecoverable error occurred in a user supplied component.", "labels": []}
{"id": 12293, "text": "The cause will be the error in user code.", "labels": []}
{"id": 12294, "text": "if any of the options are invalid, or if any of the given compilation units are of other kind than source", "labels": []}
{"id": 12295, "text": "if this resource cannot be closed", "labels": []}
{"id": 12296, "text": "If a security manager is present and its checkExit method does not permit exiting with the specified status", "labels": []}
{"id": 12297, "text": "If the specified hook has already been registered, or if it can be determined that the hook is already running or has already been run", "labels": []}
{"id": 12298, "text": "If the virtual machine is already in the process of shutting down", "labels": []}
{"id": 12299, "text": "If a security manager is present and it denies RuntimePermission(\"shutdownHooks\")", "labels": []}
{"id": 12300, "text": "If a security manager is present and its checkExit method does not permit an exit with the specified status", "labels": []}
{"id": 12301, "text": "If a security manager exists and its checkExec method doesn't allow creation of the subprocess", "labels": []}
{"id": 12302, "text": "If command is null", "labels": []}
{"id": 12303, "text": "If command is empty", "labels": []}
{"id": 12304, "text": "If command is null, or one of the elements of envp is null", "labels": []}
{"id": 12305, "text": "If cmdarray is null, or one of the elements of cmdarray is null", "labels": []}
{"id": 12306, "text": "If cmdarray is an empty array (has length 0)", "labels": []}
{"id": 12307, "text": "If cmdarray is null, or one of the elements of cmdarray is null, or one of the elements of envp is null", "labels": []}
{"id": 12308, "text": "If the operating system does not support the creation of processes.", "labels": []}
{"id": 12309, "text": "if a security manager exists and its checkLink method doesn't allow loading of the specified dynamic library", "labels": []}
{"id": 12310, "text": "if either the filename is not an absolute path name, the native library is not statically linked with the VM, or the library cannot be mapped to a native library image by the host system.", "labels": []}
{"id": 12311, "text": "if filename is null", "labels": []}
{"id": 12312, "text": "if either the libname argument contains a file path, the native library is not statically linked with the VM, or the library cannot be mapped to a native library image by the host system.", "labels": []}
{"id": 12313, "text": "if libname is null", "labels": []}
{"id": 12314, "text": "if the given cipher is null.", "labels": []}
{"id": 12315, "text": "if an error occurs during serialization", "labels": []}
{"id": 12316, "text": "if the given cipher is a block cipher, no padding has been requested, and the total input length (i.e., the length of the serialized object contents) is not a multiple of the cipher's block size", "labels": []}
{"id": 12317, "text": "if an error occurs during de-serialiazation.", "labels": []}
{"id": 12318, "text": "if the algorithm to unseal the object is not available.", "labels": []}
{"id": 12319, "text": "if the given key cannot be used to unseal the object (e.g., it has the wrong algorithm).", "labels": []}
{"id": 12320, "text": "if an error occurs during de-serialiazation", "labels": []}
{"id": 12321, "text": "if the given cipher is a block cipher, no padding has been requested, and the total input length is not a multiple of the cipher's block size", "labels": []}
{"id": 12322, "text": "if the given cipher has been initialized for decryption, and padding has been specified, but the input data does not have proper expected padding bytes", "labels": []}
{"id": 12323, "text": "if the given provider is null or empty.", "labels": []}
{"id": 12324, "text": "if the given provider is not configured.", "labels": []}
{"id": 12325, "text": "if the matrix cannot be inverted.", "labels": []}
{"id": 12326, "text": "if the type of the specified element is incompatible with this collection (optional)", "labels": []}
{"id": 12327, "text": "if the specified element is null and this collection does not permit null elements (optional)", "labels": []}
{"id": 12328, "text": "if the runtime type of any element in this collection is not assignable to the runtime component type of the specified array", "labels": []}
{"id": 12329, "text": "if the add operation is not supported by this collection", "labels": []}
{"id": 12330, "text": "if the class of the specified element prevents it from being added to this collection", "labels": []}
{"id": 12331, "text": "if the specified element is null and this collection does not permit null elements", "labels": []}
{"id": 12332, "text": "if some property of the element prevents it from being added to this collection", "labels": []}
{"id": 12333, "text": "if the element cannot be added at this time due to insertion restrictions", "labels": []}
{"id": 12334, "text": "if the remove operation is not supported by this collection", "labels": []}
{"id": 12335, "text": "if the types of one or more elements in the specified collection are incompatible with this collection (optional)", "labels": []}
{"id": 12336, "text": "if the specified collection contains one or more null elements and this collection does not permit null elements (optional), or if the specified collection is null.", "labels": []}
{"id": 12337, "text": "if the addAll operation is not supported by this collection", "labels": []}
{"id": 12338, "text": "if the class of an element of the specified collection prevents it from being added to this collection", "labels": []}
{"id": 12339, "text": "if the specified collection contains a null element and this collection does not permit null elements, or if the specified collection is null", "labels": []}
{"id": 12340, "text": "if some property of an element of the specified collection prevents it from being added to this collection", "labels": []}
{"id": 12341, "text": "if the removeAll method is not supported by this collection", "labels": []}
{"id": 12342, "text": "if the types of one or more elements in this collection are incompatible with the specified collection (optional)", "labels": []}
{"id": 12343, "text": "if this collection contains one or more null elements and the specified collection does not support null elements (optional), or if the specified collection is null", "labels": []}
{"id": 12344, "text": "if the retainAll operation is not supported by this collection", "labels": []}
{"id": 12345, "text": "if this collection contains one or more null elements and the specified collection does not permit null elements (optional), or if the specified collection is null", "labels": []}
{"id": 12346, "text": "if the clear operation is not supported by this collection", "labels": []}
{"id": 12347, "text": "if the task cannot be scheduled for execution", "labels": []}
{"id": 12348, "text": "if command or unit is null", "labels": []}
{"id": 12349, "text": "if period less than or equal to zero", "labels": []}
{"id": 12350, "text": "if delay less than or equal to zero", "labels": []}
{"id": 12351, "text": "at discretion of RejectedExecutionHandler, if the task cannot be accepted for execution because the executor has been shut down", "labels": []}
{"id": 12352, "text": "if command is null", "labels": []}
{"id": 12353, "text": "if a security manager exists and shutting down this ExecutorService may manipulate threads that the caller is not permitted to modify because it does not hold RuntimePermission(\"modifyThread\"), or the security manager's checkAccess method denies access.", "labels": []}
{"id": 12354, "text": "if no Provider supports a MessageDigestSpi implementation for the specified algorithm", "labels": []}
{"id": 12355, "text": "if a MessageDigestSpi implementation for the specified algorithm is not available from the specified provider", "labels": []}
{"id": 12356, "text": "if a MessageDigestSpi implementation for the specified algorithm is not available from the specified Provider object", "labels": []}
{"id": 12357, "text": "if an error occurs.", "labels": []}
{"id": 12358, "text": "if the params value is invalid, null, or unsupported.", "labels": []}
{"id": 12359, "text": "if modlen is invalid, or unsupported, or if genParams is false and there are no precomputed parameters for the requested modulus length.", "labels": []}
{"id": 12360, "text": "if the input string doesn't conform to RFC 3490 specification", "labels": []}
{"id": 12361, "text": "if orientation is neither HORIZONTAL nor VERTICAL", "labels": []}
{"id": 12362, "text": "if id is not in the range INPUT_METHOD_FIRST..INPUT_METHOD_LAST; or if id is CARET_POSITION_CHANGED and text is not null; or if committedCharacterCount is not in the range 0..(text.getEndIndex() - text.getBeginIndex())", "labels": []}
{"id": 12363, "text": "if id is not in the range INPUT_METHOD_FIRST..INPUT_METHOD_LAST", "labels": []}
{"id": 12364, "text": "If cannot create a SaslClient because of an error.", "labels": []}
{"id": 12365, "text": "If cannot create a SaslServer because of an error.", "labels": []}
{"id": 12366, "text": "if locale has any ill-formed fields.", "labels": []}
{"id": 12367, "text": "if languageTag is ill-formed", "labels": []}
{"id": 12368, "text": "if language is ill-formed", "labels": []}
{"id": 12369, "text": "if script is ill-formed", "labels": []}
{"id": 12370, "text": "if region is ill-formed", "labels": []}
{"id": 12371, "text": "if variant is ill-formed", "labels": []}
{"id": 12372, "text": "if key is illegal or value is ill-formed", "labels": []}
{"id": 12373, "text": "if key or type is ill-formed", "labels": []}
{"id": 12374, "text": "if attribute is null", "labels": []}
{"id": 12375, "text": "if attribute is ill-formed", "labels": []}
{"id": 12376, "text": "if an exception occurs during introspection.", "labels": []}
{"id": 12377, "text": "if chars is null.", "labels": []}
{"id": 12378, "text": "if start is negative or end is greater than the length of the chars array.", "labels": []}
{"id": 12379, "text": "if attributes is null.", "labels": []}
{"id": 12380, "text": "if the fontStream data does not contain the required font tables for any of the elements of the collection, or if it contains no fonts at all.", "labels": []}
{"id": 12381, "text": "if the fontStream cannot be completely read.", "labels": []}
{"id": 12382, "text": "if the File does not contain the required font tables for any of the elements of the collection, or if it contains no fonts at all.", "labels": []}
{"id": 12383, "text": "if the fontFile cannot be read.", "labels": []}
{"id": 12384, "text": "if fontFormat is not TRUETYPE_FONT or TYPE1_FONT.", "labels": []}
{"id": 12385, "text": "if the fontStream data does not contain the required font tables for the specified format.", "labels": []}
{"id": 12386, "text": "if nm is null.", "labels": []}
{"id": 12387, "text": "if the code point is not a valid Unicode code point.", "labels": []}
{"id": 12388, "text": "if beginIndex is less than zero, or limit is greater than the length of str, or beginIndex is greater than limit.", "labels": []}
{"id": 12389, "text": "if beginIndex is less than zero, or limit is greater than the length of chars, or beginIndex is greater than limit.", "labels": []}
{"id": 12390, "text": "if beginIndex is less than the start index of ci, or limit is greater than the end index of ci, or beginIndex is greater than limit", "labels": []}
{"id": 12391, "text": "if start or limit is out of bounds", "labels": []}
{"id": 12392, "text": "compositeType is null, or itemNames[] or itemValues[] is null or empty, or one of the elements in itemNames[] is a null or empty string, or itemNames[] and itemValues[] are not of the same size.", "labels": []}
{"id": 12393, "text": "If an IO error was encountered while establishing the TLS session.", "labels": []}
{"id": 12394, "text": "if the period unit has an estimated duration", "labels": []}
{"id": 12395, "text": "if a numeric overflow occurs", "labels": []}
{"id": 12396, "text": "if unable to convert to a Duration", "labels": []}
{"id": 12397, "text": "if the text cannot be parsed to a duration", "labels": []}
{"id": 12398, "text": "if the seconds between the temporals cannot be obtained", "labels": []}
{"id": 12399, "text": "if the calculation exceeds the capacity of Duration", "labels": []}
{"id": 12400, "text": "if unable to add", "labels": []}
{"id": 12401, "text": "if unable to subtract", "labels": []}
{"id": 12402, "text": "if the unit is invalid for truncation", "labels": []}
{"id": 12403, "text": "if unable to query", "labels": []}
{"id": 12404, "text": "if there is a security manager and the caller does not have the permission required by MBeanServerFactory.createMBeanServer().", "labels": []}
{"id": 12405, "text": "if mxbeanName is not with a valid ObjectName format, or the named MXBean in the connection is not a MXBean provided by the platform, or the named MXBean is not registered in the MBeanServerConnection, or the named MXBean is not an instance of the given mxbeanInterface", "labels": []}
{"id": 12406, "text": "if a communication problem occurred when accessing the MBeanServerConnection.", "labels": []}
{"id": 12407, "text": "if mxbeanInterface is not a platform management interface or not a singleton platform MXBean.", "labels": []}
{"id": 12408, "text": "if this attribute set does not support the add() operation", "labels": []}
{"id": 12409, "text": "if the attribute is not an instance of interface PrintServiceAttribute", "labels": []}
{"id": 12410, "text": "if the attribute is null", "labels": []}
{"id": 12411, "text": "if this attribute set does not support the addAll() method", "labels": []}
{"id": 12412, "text": "if some element in the specified set is not an instance of interface PrintServiceAttribute", "labels": []}
{"id": 12413, "text": "if the specified set is null", "labels": []}
{"id": 12414, "text": "If the preconditions on newPosition do not hold", "labels": []}
{"id": 12415, "text": "If the preconditions on newLimit do not hold", "labels": []}
{"id": 12416, "text": "if value or calendarField are null, if calendarField isn't valid, or if the following expression is false: (start <= value <= end).", "labels": []}
{"id": 12417, "text": "if value is null or not a Date", "labels": []}
{"id": 12418, "text": "if column is outside the range of the underlying model", "labels": []}
{"id": 12419, "text": "if either argument is invalid, or firstRow > endRow", "labels": []}
{"id": 12420, "text": "if either argument is outside the range of the model before the change, or firstRow > endRow", "labels": []}
{"id": 12421, "text": "if either argument is outside the range of the underlying model, or firstRow > endRow", "labels": []}
{"id": 12422, "text": "if either argument is outside the range of the underlying model after the change, firstRow > endRow, or column is outside the range of the underlying model", "labels": []}
{"id": 12423, "text": "if the result exceeds the supported range", "labels": []}
{"id": 12424, "text": "if unable to convert to an OffsetDateTime", "labels": []}
{"id": 12425, "text": "if the result exceeds the supported date range", "labels": []}
{"id": 12426, "text": "if the year value is invalid", "labels": []}
{"id": 12427, "text": "if the day-of-month value is invalid, or if the day-of-month is invalid for the month-year", "labels": []}
{"id": 12428, "text": "if the day-of-year value is invalid, or if the day-of-year is invalid for the year", "labels": []}
{"id": 12429, "text": "if the hour value is invalid", "labels": []}
{"id": 12430, "text": "if the minute value is invalid", "labels": []}
{"id": 12431, "text": "if the second value is invalid", "labels": []}
{"id": 12432, "text": "if the nano value is invalid", "labels": []}
{"id": 12433, "text": "if the amount cannot be calculated, or the end temporal cannot be converted to an OffsetDateTime", "labels": []}
{"id": 12434, "text": "if the file exists but is a directory rather than a regular file, does not exist but cannot be created, or cannot be opened for any other reason", "labels": []}
{"id": 12435, "text": "if a security manager exists and its checkWrite method denies write access to the file.", "labels": []}
{"id": 12436, "text": "if the file exists but is a directory rather than a regular file, does not exist but cannot be created, or cannot be opened for any other reason.", "labels": []}
{"id": 12437, "text": "if a security manager exists and its checkWrite method denies write access to the file descriptor", "labels": []}
{"id": 12438, "text": "if there are IO problems opening the files.", "labels": []}
{"id": 12439, "text": "if limit < 0, or count < 1.", "labels": []}
{"id": 12440, "text": "if pattern is an empty string", "labels": []}
{"id": 12441, "text": "if the index is negative or greater than the current size of this list", "labels": []}
{"id": 12442, "text": "if the index is negative or not less than the size of the list", "labels": []}
{"id": 12443, "text": "if the index is invalid", "labels": []}
{"id": 12444, "text": "if the index was invalid", "labels": []}
{"id": 12445, "text": "When localPart is null", "labels": []}
{"id": 12446, "text": "When localPart or prefix is null", "labels": []}
{"id": 12447, "text": "When qNameAsString is null or malformed", "labels": []}
{"id": 12448, "text": "if the current group is nonexistent", "labels": []}
{"id": 12449, "text": "if and only if activation is not supported by this implementation", "labels": []}
{"id": 12450, "text": "if groupID is null", "labels": []}
{"id": 12451, "text": "if the specified index is negative", "labels": []}
{"id": 12452, "text": "if the specified index is greater than or equal to the current size of this list", "labels": []}
{"id": 12453, "text": "if the string does not contain a parsable long.", "labels": []}
{"id": 12454, "text": "if the String does not contain a parsable long.", "labels": []}
{"id": 12455, "text": "if the string does not contain a parsable unsigned integer.", "labels": []}
{"id": 12456, "text": "If the String does not contain a parsable long.", "labels": []}
{"id": 12457, "text": "If the string cannot be parsed as a long.", "labels": []}
{"id": 12458, "text": "if permits is negative", "labels": []}
{"id": 12459, "text": "if reduction is negative", "labels": []}
{"id": 12460, "text": "If lexicalRepresentation is not a valid representation of a Duration.", "labels": []}
{"id": 12461, "text": "If implementation cannot support requested values.", "labels": []}
{"id": 12462, "text": "if lexicalRepresentation is null.", "labels": []}
{"id": 12463, "text": "If the values are not a valid representation of a Duration: if all the fields (years, months, ...) are null or if any of the fields is negative.", "labels": []}
{"id": 12464, "text": "If lexicalRepresentation is not a valid representation of a Duration expressed only in terms of days and time.", "labels": []}
{"id": 12465, "text": "If lexicalRepresentation is null.", "labels": []}
{"id": 12466, "text": "If the values are not a valid representation of a Duration: if all the fields (day, hour, ...) are null or if any of the fields is negative.", "labels": []}
{"id": 12467, "text": "If the values are not a valid representation of a Duration: if any of the fields (day, hour, ...) is negative.", "labels": []}
{"id": 12468, "text": "If lexicalRepresentation is not a valid representation of a Duration expressed only in terms of years and months.", "labels": []}
{"id": 12469, "text": "If the values are not a valid representation of a Duration: if all of the fields (year, month) are null or if any of the fields is negative.", "labels": []}
{"id": 12470, "text": "If cal is null.", "labels": []}
{"id": 12471, "text": "If any individual parameter's value is outside the maximum value constraint for the field as determined by the Date/Time Data Mapping table in XMLGregorianCalendar or if the composite values constitute an invalid XMLGregorianCalendar instance as determined by XMLGregorianCalendar.isValid().", "labels": []}
{"id": 12472, "text": "if flav or nat is null", "labels": []}
{"id": 12473, "text": "if flav or natives is null or if natives contains null elements", "labels": []}
{"id": 12474, "text": "if nat or flav is null", "labels": []}
{"id": 12475, "text": "if nat or flavors is null or if flavors contains null elements", "labels": []}
{"id": 12476, "text": "if start is negative, or start is greater than end or end is greater than s.length()", "labels": []}
{"id": 12477, "text": "if offset < 0 or len < 0 or offset+len > str.length", "labels": []}
{"id": 12478, "text": "if start is negative, greater than length(), or greater than end.", "labels": []}
{"id": 12479, "text": "if the index is negative or greater than or equal to length().", "labels": []}
{"id": 12480, "text": "if the offset is invalid.", "labels": []}
{"id": 12481, "text": "if dstOffset is negative or greater than this.length(), or start or end are negative, or start is greater than end or end is greater than s.length()", "labels": []}
{"id": 12482, "text": "if the newLength argument is negative.", "labels": []}
{"id": 12483, "text": "if index is negative or greater than or equal to length().", "labels": []}
{"id": 12484, "text": "if the index argument is negative or not less than the length of this sequence.", "labels": []}
{"id": 12485, "text": "if the index argument is less than 1 or greater than the length of this sequence.", "labels": []}
{"id": 12486, "text": "if the class of the specified element prevents it from being added to this deque", "labels": []}
{"id": 12487, "text": "if the specified element is null and this deque does not permit null elements", "labels": []}
{"id": 12488, "text": "if some property of the specified element prevents it from being added to this deque", "labels": []}
{"id": 12489, "text": "if this deque is empty", "labels": []}
{"id": 12490, "text": "if the class of the specified element is incompatible with this deque (optional)", "labels": []}
{"id": 12491, "text": "if the specified element is null and this deque does not permit null elements (optional)", "labels": []}
{"id": 12492, "text": "if the class of an element of the specified collection prevents it from being added to this deque", "labels": []}
{"id": 12493, "text": "if the specified collection contains a null element and this deque does not permit null elements, or if the specified collection is null", "labels": []}
{"id": 12494, "text": "if some property of an element of the specified collection prevents it from being added to this deque", "labels": []}
{"id": 12495, "text": "if there is security manager and the SerializablePermission(\"serialFilter\") is not granted", "labels": []}
{"id": 12496, "text": "if the filter has already been set non-null", "labels": []}
{"id": 12497, "text": "if the pattern string is illegal or malformed and cannot be parsed.", "labels": []}
{"id": 12498, "text": "In particular, if any of the following is true: if a limit is missing the name or the name is not one of \"maxdepth\", \"maxrefs\", \"maxbytes\", or \"maxarray\" if the value of the limit can not be parsed by Long.parseLong or is negative if the pattern contains \"/\" and the module name is missing or the remaining pattern is empty if the package is missing for \".", "labels": []}
{"id": 12499, "text": "when the type and the address are incompatible", "labels": []}
{"id": 12500, "text": "If there are fewer than length doubles remaining in this buffer", "labels": []}
{"id": 12501, "text": "If there is insufficient space in this buffer for the remaining doubles in the source buffer", "labels": []}
{"id": 12502, "text": "if the certificate has expired.", "labels": []}
{"id": 12503, "text": "if the certificate is not yet valid.", "labels": []}
{"id": 12504, "text": "if the certificate has expired with respect to the date supplied.", "labels": []}
{"id": 12505, "text": "if the certificate is not yet valid with respect to the date supplied.", "labels": []}
{"id": 12506, "text": "if the extension cannot be decoded", "labels": []}
{"id": 12507, "text": "if the method is not supported", "labels": []}
{"id": 12508, "text": "if g is null", "labels": []}
{"id": 12509, "text": "if the DisplayMode supplied is null, or is not available in the array returned by getDisplayModes", "labels": []}
{"id": 12510, "text": "if isDisplayChangeSupported returns false", "labels": []}
{"id": 12511, "text": "in case of service configuration error or if the implementation is not available or cannot be instantiated.", "labels": []}
{"id": 12512, "text": "thrown if the underlying implementation doesn't recognize the attribute.", "labels": []}
{"id": 12513, "text": "if this DocumentBuilderFactory or the DocumentBuilders it creates cannot support this feature.", "labels": []}
{"id": 12514, "text": "When implementation does not override this method.", "labels": []}
{"id": 12515, "text": "if the receiver is closed", "labels": []}
{"id": 12516, "text": "if the capabilities supplied could not be supported or met", "labels": []}
{"id": 12517, "text": "if the component is not a canvas or window.", "labels": []}
{"id": 12518, "text": "if the component has no peer", "labels": []}
{"id": 12519, "text": "if numBuffers is less than two, or if BufferCapabilities.isPageFlipping is not true.", "labels": []}
{"id": 12520, "text": "if encodedKey or algorithm is null.", "labels": []}
{"id": 12521, "text": "if algorithm is the empty string \"\"", "labels": []}
{"id": 12522, "text": "for illegal value for initNumFields (<= 0)", "labels": []}
{"id": 12523, "text": "If the String inStr passed in parameter is null", "labels": []}
{"id": 12524, "text": "for illegal value for field Names or field Values.", "labels": []}
{"id": 12525, "text": "The array lengths must be equal.", "labels": []}
{"id": 12526, "text": "If the descriptor construction fails for any reason, this exception will be thrown.", "labels": []}
{"id": 12527, "text": "If the validity checking fails for any reason, this exception will be thrown.", "labels": []}
{"id": 12528, "text": "If the XML formatted string construction fails for any reason, this exception will be thrown.", "labels": []}
{"id": 12529, "text": "If the descriptor string fails for any reason, this exception will be thrown.", "labels": []}
{"id": 12530, "text": "If any IO errors occur.", "labels": []}
{"id": 12531, "text": "If any parse errors occur.", "labels": []}
{"id": 12532, "text": "When is is null", "labels": []}
{"id": 12533, "text": "When uri is null", "labels": []}
{"id": 12534, "text": "When f is null", "labels": []}
{"id": 12535, "text": "When implementation does not override this method", "labels": []}
{"id": 12536, "text": "INDEX_SIZE_ERR: Raised if the specified index is greater than the number of rows of if the index is neagative.", "labels": []}
{"id": 12537, "text": "if key or value is null.", "labels": []}
{"id": 12538, "text": "if key.length() exceeds MAX_KEY_LENGTH or if value.length exceeds MAX_VALUE_LENGTH.", "labels": []}
{"id": 12539, "text": "if either key or value contain the null control character, code point U+0000.", "labels": []}
{"id": 12540, "text": "if this node (or an ancestor) has been removed with the removeNode() method.", "labels": []}
{"id": 12541, "text": "(A null default is permitted.)", "labels": []}
{"id": 12542, "text": "if key contains the null control character, code point U+0000.", "labels": []}
{"id": 12543, "text": "if key is null..", "labels": []}
{"id": 12544, "text": "if the path name is invalid (i.e., it contains multiple consecutive slash characters, or ends with a slash character and is more than one character long).", "labels": []}
{"id": 12545, "text": "if this operation cannot be completed due to a failure in the backing store, or inability to communicate with it.", "labels": []}
{"id": 12546, "text": "if this node (or an ancestor) has been removed with the removeNode() method and pathname is not the empty string (\"\").", "labels": []}
{"id": 12547, "text": "if this node (or an ancestor) has already been removed with the removeNode() method.", "labels": []}
{"id": 12548, "text": "if this method is invoked on the root node.", "labels": []}
{"id": 12549, "text": "if declaringClass or methodName is null", "labels": []}
{"id": 12550, "text": "if unable to compute a result", "labels": []}
{"id": 12551, "text": "if name is neither \"register\" nor \"*\".", "labels": []}
{"id": 12552, "text": "if value is less than lowerBound or greater than upperBound", "labels": []}
{"id": 12553, "text": "If the specified address is null.", "labels": []}
{"id": 12554, "text": "if an I/O error occurs, or if the platform does not have at least one configured network interface.", "labels": []}
{"id": 12555, "text": "if the authentication fails.", "labels": []}
{"id": 12556, "text": "if the logout fails.", "labels": []}
{"id": 12557, "text": "if cspace is null", "labels": []}
{"id": 12558, "text": "if either srcCspace or dstCspace is null", "labels": []}
{"id": 12559, "text": "when the profile sequence does not specify a well-defined color conversion", "labels": []}
{"id": 12560, "text": "if profiles is null", "labels": []}
{"id": 12561, "text": "if dest is null and this op was constructed using the constructor which takes only a RenderingHints argument, since the operation is ill defined.", "labels": []}
{"id": 12562, "text": "if the number of source or destination bands is incorrect, the source or destination color spaces are undefined, or this op was constructed with one of the constructors that applies only to operations on BufferedImages.", "labels": []}
{"id": 12563, "text": "if unable to convert to a Chronology", "labels": []}
{"id": 12564, "text": "if the locale-specified calendar cannot be found", "labels": []}
{"id": 12565, "text": "if the chronology cannot be found", "labels": []}
{"id": 12566, "text": "if unable to create the date-time", "labels": []}
{"id": 12567, "text": "if unable to convert to a proleptic-year, such as if the year is invalid for the era", "labels": []}
{"id": 12568, "text": "if the era is not of the correct type for the chronology", "labels": []}
{"id": 12569, "text": "if unable to create the era", "labels": []}
{"id": 12570, "text": "if the date cannot be resolved, typically because of a conflict in the input data", "labels": []}
{"id": 12571, "text": "if n is negative", "labels": []}
{"id": 12572, "text": "if the diagnostic argument is null and the implementation cannot handle null arguments", "labels": []}
{"id": 12573, "text": "If no match has yet been attempted, or if the previous match operation failed", "labels": []}
{"id": 12574, "text": "If there is no capturing group in the pattern with the given index", "labels": []}
{"id": 12575, "text": "If there is no capturing group in the pattern with the given name", "labels": []}
{"id": 12576, "text": "If start is less than zero or if start is greater than the length of the input sequence.", "labels": []}
{"id": 12577, "text": "If the replacement string refers to a named-capturing group that does not exist in the pattern", "labels": []}
{"id": 12578, "text": "If the replacement string refers to a capturing group that does not exist in the pattern", "labels": []}
{"id": 12579, "text": "if the replacer function is null", "labels": []}
{"id": 12580, "text": "if it is detected, on a best-effort basis, that the replacer function modified this matcher's state", "labels": []}
{"id": 12581, "text": "if the parameter is null, or if a field name is empty, or if the same field name appears more than once, or if one of the strings does not contain an = character.", "labels": []}
{"id": 12582, "text": "if two Descriptors contain the same field name with different associated values.", "labels": []}
{"id": 12583, "text": "Primitive array values are considered the same if they are of the same type with the same elements.", "labels": []}
{"id": 12584, "text": "Object array values are considered the same if Arrays.deepEquals(Object[],Object[]) returns true.", "labels": []}
{"id": 12585, "text": "if the validity checking fails.", "labels": []}
{"id": 12586, "text": "The method returns false if the descriptor is not valid, but throws this exception if the attempt to determine validity fails.", "labels": []}
{"id": 12587, "text": "if the change fails for any reason.", "labels": []}
{"id": 12588, "text": "Wrapped exception is IllegalArgumentException if fieldNames or fieldValues is null, or if the arrays are of different lengths, or if there is an illegal value in one of them.", "labels": []}
{"id": 12589, "text": "Wrapped exception is UnsupportedOperationException if the descriptor is immutable, and the call would change its contents.", "labels": []}
{"id": 12590, "text": "if the field name or field value is illegal (wrapped exception is IllegalArgumentException); or if the descriptor is immutable (wrapped exception is UnsupportedOperationException).", "labels": []}
{"id": 12591, "text": "if there is an error accessing the CLOB value or if pos is less than 1", "labels": []}
{"id": 12592, "text": "if there is an error accessing the CLOB value or if len is less than 0", "labels": []}
{"id": 12593, "text": "if an error occurs releasing the Clob's resources", "labels": []}
{"id": 12594, "text": "for a null or invalid page specification, or exception from the stream being read", "labels": []}
{"id": 12595, "text": "if an I/O problem occurs", "labels": []}
{"id": 12596, "text": "if the type parameter is null", "labels": []}
{"id": 12597, "text": "if it is not registered", "labels": []}
{"id": 12598, "text": "if null parameter", "labels": []}
{"id": 12599, "text": "if the Relation Service is not registered in the MBean Server", "labels": []}
{"id": 12600, "text": "If the MBean does not implement the Relation interface", "labels": []}
{"id": 12601, "text": "if the MBean for given ObjectName has not been registered", "labels": []}
{"id": 12602, "text": "if a value is provided for a role that does not exist in the relation type", "labels": []}
{"id": 12603, "text": "if the relation type is not known in the Relation Service", "labels": []}
{"id": 12604, "text": "if unknown relation type", "labels": []}
{"id": 12605, "text": "if there is no relation for given relation id", "labels": []}
{"id": 12606, "text": "if no relation for given id.", "labels": []}
{"id": 12607, "text": "if no relation corresponding to given relation id", "labels": []}
{"id": 12608, "text": "if the Relation Service is not registered in the MBean Server.", "labels": []}
{"id": 12609, "text": "an exceptional condition has occurred.", "labels": []}
{"id": 12610, "text": "Each class that implements PrivilegedExceptionAction should document the exceptions that its run method can throw.", "labels": []}
{"id": 12611, "text": "if the owner's GraphicsConfiguration is not from a screen device", "labels": []}
{"id": 12612, "text": "when GraphicsEnvironment.isHeadless returns true", "labels": []}
{"id": 12613, "text": "when GraphicsEnvironment.isHeadless() returns true", "labels": []}
{"id": 12614, "text": "if gc is not from a screen device", "labels": []}
{"id": 12615, "text": "if the calling thread does not have permission to set the modal exclusion property to the window with the given exclusionType", "labels": []}
{"id": 12616, "text": "if listenerType is null", "labels": []}
{"id": 12617, "text": "if the calling thread does not have permission to set the value of always-on-top property", "labels": []}
{"id": 12618, "text": "if id is not one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS", "labels": []}
{"id": 12619, "text": "if the window is displayable.", "labels": []}
{"id": 12620, "text": "if the type is null", "labels": []}
{"id": 12621, "text": "if numBuffers is less than 1.", "labels": []}
{"id": 12622, "text": "if the component is not displayable", "labels": []}
{"id": 12623, "text": "if the capabilities supplied could not be supported or met; this may happen, for example, if there is not enough accelerated memory currently available, or if page flipping is specified but not possible.", "labels": []}
{"id": 12624, "text": "if numBuffers is less than 1, or if caps is null", "labels": []}
{"id": 12625, "text": "if the window is showing on screen and locationByPlatform is true.", "labels": []}
{"id": 12626, "text": "if the opacity is out of the range [0..1]", "labels": []}
{"id": 12627, "text": "if the window is decorated and the opacity is less than 1.0f", "labels": []}
{"id": 12628, "text": "if the window is in full screen mode, and the opacity is less than 1.0f", "labels": []}
{"id": 12629, "text": "if the GraphicsDevice.WindowTranslucency#TRANSLUCENT TRANSLUCENT translucency is not supported and the opacity is less than 1.0f", "labels": []}
{"id": 12630, "text": "if the shape is not null and the window is decorated", "labels": []}
{"id": 12631, "text": "if the shape is not null and the window is in full-screen mode", "labels": []}
{"id": 12632, "text": "if the shape is not null and PERPIXEL_TRANSPARENT translucency is not supported", "labels": []}
{"id": 12633, "text": "if the alpha value of the given background color is less than 1.0f and the window is decorated", "labels": []}
{"id": 12634, "text": "if the alpha value of the given background color is less than 1.0f and the window is in full-screen mode", "labels": []}
{"id": 12635, "text": "if the alpha value of the given background color is less than 1.0f and PERPIXEL_TRANSLUCENT translucency is not supported", "labels": []}
{"id": 12636, "text": "if the named encoding is not supported.", "labels": []}
{"id": 12637, "text": "if there is a SecurityManager and the caller's permissions do not include or imply MBeanServerPermission(\"createMBeanServer\").", "labels": []}
{"id": 12638, "text": "if the property javax.management.builder.initial exists but the class it names cannot be instantiated through a public no-argument constructor; or if the instantiated builder returns null from its newMBeanServerDelegate or newMBeanServer methods.", "labels": []}
{"id": 12639, "text": "if the property javax.management.builder.initial exists and can be instantiated but is not assignment compatible with MBeanServerBuilder.", "labels": []}
{"id": 12640, "text": "if there is a SecurityManager and the caller's permissions do not include or imply MBeanServerPermission(\"newMBeanServer\").", "labels": []}
{"id": 12641, "text": "if the rows or columns arguments are negative.", "labels": []}
{"id": 12642, "text": "if pos is an invalid position in the model", "labels": []}
{"id": 12643, "text": "if part of the range is an invalid position in the model", "labels": []}
{"id": 12644, "text": "if rows is less than 0", "labels": []}
{"id": 12645, "text": "if columns is less than 0", "labels": []}
{"id": 12646, "text": "If the given charset name is illegal", "labels": []}
{"id": 12647, "text": "If the given charsetName is null", "labels": []}
{"id": 12648, "text": "if a custom Composite object is being used to render to the screen and a security manager is set and its checkPermission method does not allow the operation.", "labels": []}
{"id": 12649, "text": "If an I/O error occurs while closing the selector", "labels": []}
{"id": 12650, "text": "if revocationDate, reason, authority, or extensions is null", "labels": []}
{"id": 12651, "text": "if extensions contains an incorrectly typed key or value", "labels": []}
{"id": 12652, "text": "if null or zero-length chain is passed in for the chain parameter or if null or zero-length string is passed in for the authType parameter", "labels": []}
{"id": 12653, "text": "if the certificate chain is not trusted by this TrustManager.", "labels": []}
{"id": 12654, "text": "if the peer is not verified.", "labels": []}
{"id": 12655, "text": "if the Drag and Drop system is unable to initiate a drag operation, or if the user attempts to start a drag while an existing drag operation is still executing.", "labels": []}
{"id": 12656, "text": "if the Transferable is null", "labels": []}
{"id": 12657, "text": "if imageURL is null", "labels": []}
{"id": 12658, "text": "if there was an error while loading the image", "labels": []}
{"id": 12659, "text": "if the splash screen has already been closed", "labels": []}
{"id": 12660, "text": "as described in exceptions", "labels": []}
{"id": 12661, "text": "if c is null", "labels": []}
{"id": 12662, "text": "if the specified property is not one which can be set using this method", "labels": []}
{"id": 12663, "text": "if the property value has not been set by the developer and the type does not match the property's type", "labels": []}
{"id": 12664, "text": "if c is null, or the named property has not been set by the developer and propertyValue is null", "labels": []}
{"id": 12665, "text": "if keyBindingList is null", "labels": []}
{"id": 12666, "text": "if the key part of the pair is not a KeyStroke or String, or the action part of the pair is not a String", "labels": []}
{"id": 12667, "text": "if keys is non-null, not empty, and retMap is null", "labels": []}
{"id": 12668, "text": "If the given configuration has more than one parent or the parent of the configuration is not the configuration for this layer", "labels": []}
{"id": 12669, "text": "If the layer cannot be created for any of the reasons specified by the static defineModulesWithOneLoader method", "labels": []}
{"id": 12670, "text": "If RuntimePermission(\"createClassLoader\") or RuntimePermission(\"getClassLoader\") is denied by the security manager", "labels": []}
{"id": 12671, "text": "If the layer cannot be created for any of the reasons specified by the static defineModulesWithManyLoaders method", "labels": []}
{"id": 12672, "text": "If the layer cannot be created for any of the reasons specified by the static defineModules method", "labels": []}
{"id": 12673, "text": "If RuntimePermission(\"getClassLoader\") is denied by the security manager", "labels": []}
{"id": 12674, "text": "If the parent(s) of the given configuration do not match the configuration of the parent layers, including order", "labels": []}
{"id": 12675, "text": "If all modules cannot be defined to the same class loader for any of the reasons listed above", "labels": []}
{"id": 12676, "text": "If the layer cannot be created because the configuration contains a module named \"java.base\" or a module contains a package named \"java\" or a package with a name starting with \"java.\"", "labels": []}
{"id": 12677, "text": "If creating the layer fails for any of the reasons listed above", "labels": []}
{"id": 12678, "text": "if a module of the given name is not defined in this layer or any parent of this layer", "labels": []}
{"id": 12679, "text": "if denied by the security manager", "labels": []}
{"id": 12680, "text": "if obj is null", "labels": []}
{"id": 12681, "text": "if both obj is null and defaultObj is null", "labels": []}
{"id": 12682, "text": "if both obj is null and either the supplier is null or the supplier.get() value is null", "labels": []}
{"id": 12683, "text": "if the index is out of bounds", "labels": []}
{"id": 12684, "text": "if the sub-range is out of bounds", "labels": []}
{"id": 12685, "text": "if the given locale is null", "labels": []}
{"id": 12686, "text": "if a security manager exists and the caller is not permitted to modify threads because it does not hold RuntimePermission(\"modifyThread\")", "labels": []}
{"id": 12687, "text": "if parallelism less than or equal to zero, or greater than implementation limit", "labels": []}
{"id": 12688, "text": "if the factory is null", "labels": []}
{"id": 12689, "text": "if the task is null", "labels": []}
{"id": 12690, "text": "if blocker.block() did so", "labels": []}
{"id": 12691, "text": "if algorithm is null or key is null or empty.", "labels": []}
{"id": 12692, "text": "if algorithm is null or key is null, empty, or too short, i.e.", "labels": []}
{"id": 12693, "text": "is thrown if offset or len index bytes outside the key.", "labels": []}
{"id": 12694, "text": "if the CertPath does not validate", "labels": []}
{"id": 12695, "text": "if the specified parameters or the type of the specified CertPath are inappropriate for this CertPathValidator", "labels": []}
{"id": 12696, "text": "when the names cannot be compared, containing the following major error codes: GSSException.BAD_NAMETYPE, GSSException.FAILURE", "labels": []}
{"id": 12697, "text": "containing the following major error codes: GSSException.BAD_NAME, GSSException.BAD_NAMETYPE, GSSException.FAILURE", "labels": []}
{"id": 12698, "text": "if the socket could not be opened, or the socket could not bind to the specified local port.", "labels": []}
{"id": 12699, "text": "if any error happens during the bind, or if the socket is already bound.", "labels": []}
{"id": 12700, "text": "if addr is a SocketAddress subclass not supported by this socket.", "labels": []}
{"id": 12701, "text": "if the address is null, or the port is out of range.", "labels": []}
{"id": 12702, "text": "if a security manager has been installed and it does not permit access to the given remote address", "labels": []}
{"id": 12703, "text": "if the connect fails", "labels": []}
{"id": 12704, "text": "if addr is null, or addr is a SocketAddress subclass not supported by this socket", "labels": []}
{"id": 12705, "text": "if a security manager exists and its checkMulticast or checkConnect method doesn't allow the send.", "labels": []}
{"id": 12706, "text": "may be thrown if the socket is connected to a currently unreachable destination.", "labels": []}
{"id": 12707, "text": "Note, there is no guarantee that the exception will be thrown.", "labels": []}
{"id": 12708, "text": "if this socket has an associated channel, and the channel is in non-blocking mode.", "labels": []}
{"id": 12709, "text": "if the socket is connected, and connected address and packet address differ.", "labels": []}
{"id": 12710, "text": "if setSoTimeout was previously called and the timeout has expired.", "labels": []}
{"id": 12711, "text": "if there is an error in the underlying protocol, such as an UDP error.", "labels": []}
{"id": 12712, "text": "if the value is 0 or is negative.", "labels": []}
{"id": 12713, "text": "if an error occurs enabling or disabling the SO_REUSEADDR socket option, or the socket is closed.", "labels": []}
{"id": 12714, "text": "if there is an error setting the traffic class or type-of-service", "labels": []}
{"id": 12715, "text": "if an I/O error occurs when setting the datagram socket factory.", "labels": []}
{"id": 12716, "text": "if the factory is already defined.", "labels": []}
{"id": 12717, "text": "if a security manager exists and its checkSetFactory method doesn't allow the operation.", "labels": []}
{"id": 12718, "text": "If the class for an object being restored cannot be found.", "labels": []}
{"id": 12719, "text": "if constraints is not a GridBagConstraint", "labels": []}
{"id": 12720, "text": "if GraphicsEnvironment.isHeadless returns true", "labels": []}
{"id": 12721, "text": "if the converted zone ID has an invalid format", "labels": []}
{"id": 12722, "text": "if the converted zone region ID cannot be found", "labels": []}
{"id": 12723, "text": "if the zone ID has an invalid format", "labels": []}
{"id": 12724, "text": "if the zone ID is a region ID that cannot be found", "labels": []}
{"id": 12725, "text": "if the prefix is not one of \"GMT\", \"UTC\", or \"UT\", or \"\"", "labels": []}
{"id": 12726, "text": "if no rules are available for this ID", "labels": []}
{"id": 12727, "text": "If the Component does not have its own locale and has not yet been added to a containment hierarchy such that the locale can be determined from the containing parent.", "labels": []}
{"id": 12728, "text": "If a security manager has been installed and it denies AttachPermission (\"attachVirtualMachine\"), or other permission required by the implementation.", "labels": []}
{"id": 12729, "text": "If the identifier cannot be parsed, or it corresponds to to a Java virtual machine that does not exist, or it corresponds to a Java virtual machine which this provider cannot attach.", "labels": []}
{"id": 12730, "text": "If id is null", "labels": []}
{"id": 12731, "text": "If the new position is negative", "labels": []}
{"id": 12732, "text": "if direction is invalid", "labels": []}
{"id": 12733, "text": "if the parameter is null.", "labels": []}
{"id": 12734, "text": "if the platform configuration does not allow low-level input control.", "labels": []}
{"id": 12735, "text": "This exception is always thrown when GraphicsEnvironment.isHeadless() returns true.", "labels": []}
{"id": 12736, "text": "if screen is not a screen GraphicsDevice.", "labels": []}
{"id": 12737, "text": "if createRobot permission is not granted", "labels": []}
{"id": 12738, "text": "if the buttons mask contains the mask for extra mouse button and support for extended mouse buttons is disabled by Java", "labels": []}
{"id": 12739, "text": "if the buttons mask contains the mask for extra mouse button that does not exist on the mouse and support for extended mouse buttons is enabled by Java", "labels": []}
{"id": 12740, "text": "if keycode is not a valid key", "labels": []}
{"id": 12741, "text": "if screenRect width and height are not greater than zero", "labels": []}
{"id": 12742, "text": "if readDisplayPixels permission is not granted", "labels": []}
{"id": 12743, "text": "If ms is not between 0 and 60,000 milliseconds inclusive", "labels": []}
{"id": 12744, "text": "if ms is not between 0 and 60,000 milliseconds inclusive", "labels": []}
{"id": 12745, "text": "If the destination buffer is read-only", "labels": []}
{"id": 12746, "text": "If an I/O error occurs or there is insufficient space in the destination buffer for the attribute value", "labels": []}
{"id": 12747, "text": "if the requested key specification is inappropriate for the given key, or the given key cannot be dealt with (e.g., the given key has an unrecognized format).", "labels": []}
{"id": 12748, "text": "if an encoding error occurs.", "labels": []}
{"id": 12749, "text": "if object is unknown (may already be inactive)", "labels": []}
{"id": 12750, "text": "if call informing monitor fails", "labels": []}
{"id": 12751, "text": "if group is inactive", "labels": []}
{"id": 12752, "text": "if object is not registered", "labels": []}
{"id": 12753, "text": "if group already exists or if error occurs during group creation", "labels": []}
{"id": 12754, "text": "if permission to create group is denied.", "labels": []}
{"id": 12755, "text": "if activation system is already set", "labels": []}
{"id": 12756, "text": "if permission to set the activation system is denied.", "labels": []}
{"id": 12757, "text": "if activation system cannot be obtained or is not bound (means that it is not running)", "labels": []}
{"id": 12758, "text": "An error has occurred.", "labels": []}
{"id": 12759, "text": "Possible XAException values are XAER_RMERR, XAER_RMFAILED, XAER_NOTA, XAER_INVAL, XAER_PROTO, or XA_RB*.", "labels": []}
{"id": 12760, "text": "Possible exception values are XAER_RMERR and XAER_RMFAIL.", "labels": []}
{"id": 12761, "text": "Possible exception values are XAER_RMERR, XAER_RMFAIL, or XAER_INVAL.", "labels": []}
{"id": 12762, "text": "Possible exceptions are XA_RB*, XAER_RMERR, XAER_RMFAIL, XAER_DUPID, XAER_OUTSIDE, XAER_NOTA, XAER_INVAL, or XAER_PROTO.", "labels": []}
{"id": 12763, "text": "if ranges is null.", "labels": []}
{"id": 12764, "text": "if the specified defaultContext is not a single valid range.", "labels": []}
{"id": 12765, "text": "if ranges or defaultContext is null", "labels": []}
{"id": 12766, "text": "if start or start + count is out of bounds", "labels": []}
{"id": 12767, "text": "if text is null", "labels": []}
{"id": 12768, "text": "if this is a contextual shaper and the specified context is not a single valid range.", "labels": []}
{"id": 12769, "text": "if text or context is null", "labels": []}
{"id": 12770, "text": "if columns < 0", "labels": []}
{"id": 12771, "text": "if alignment is not a valid key", "labels": []}
{"id": 12772, "text": "if an error occurs reading the information from the input source.", "labels": []}
{"id": 12773, "text": "if input is not an instance of one of the classes returned by the originating service provider's getInputTypes method, or is not an ImageInputStream.", "labels": []}
{"id": 12774, "text": "if locale is non-null but is not one of the values returned by getAvailableLocales.", "labels": []}
{"id": 12775, "text": "if the input source has not been set, or if the input has been specified with seekForwardOnly set to true.", "labels": []}
{"id": 12776, "text": "if the input source has not been set.", "labels": []}
{"id": 12777, "text": "if the supplied index is out of bounds.", "labels": []}
{"id": 12778, "text": "if an error occurs reading the width information from the input source.", "labels": []}
{"id": 12779, "text": "if an error occurs reading the height information from the input source.", "labels": []}
{"id": 12780, "text": "if an input source is required to determine the return value, but none has been set.", "labels": []}
{"id": 12781, "text": "if an image must be accessed to determine the return value, but the supplied index is out of bounds.", "labels": []}
{"id": 12782, "text": "if an error occurs during reading.", "labels": []}
{"id": 12783, "text": "if an error occurs reading the format information from the input source.", "labels": []}
{"id": 12784, "text": "if formatName is null.", "labels": []}
{"id": 12785, "text": "if nodeNames is null.", "labels": []}
{"id": 12786, "text": "if the set of source and destination bands specified by param.getSourceBands and param.getDestinationBands differ in length or include indices that are out of bounds.", "labels": []}
{"id": 12787, "text": "if the resulting image would have a width or height less than 1.", "labels": []}
{"id": 12788, "text": "if any non-null element of params is not an ImageReadParam.", "labels": []}
{"id": 12789, "text": "if a resulting image would have a width or height less than 1.", "labels": []}
{"id": 12790, "text": "if this plug-in does not support reading raw Rasters.", "labels": []}
{"id": 12791, "text": "if imageIndex is out of bounds.", "labels": []}
{"id": 12792, "text": "if the tile indices are out of bounds.", "labels": []}
{"id": 12793, "text": "if the reader supports thumbnails but the input source has not been set.", "labels": []}
{"id": 12794, "text": "if the reader supports thumbnails but imageIndex is out of bounds.", "labels": []}
{"id": 12795, "text": "if thumbnails are not supported.", "labels": []}
{"id": 12796, "text": "if either of the supplied indices are out of bounds.", "labels": []}
{"id": 12797, "text": "if srcRegion is null.", "labels": []}
{"id": 12798, "text": "if dstRegion is null.", "labels": []}
{"id": 12799, "text": "if the resulting source or destination region is empty.", "labels": []}
{"id": 12800, "text": "if param contains an invalid specification of a source and/or destination band subset.", "labels": []}
{"id": 12801, "text": "if the ImageTypeSpecifier specified by param does not match any of the legal ones from imageTypes.", "labels": []}
{"id": 12802, "text": "if imageTypes is null or empty, or if an object not of type ImageTypeSpecifier is retrieved from it.", "labels": []}
{"id": 12803, "text": "if the product of width and height is greater than Integer.MAX_VALUE.", "labels": []}
{"id": 12804, "text": "if the key can not be cast to RenderingHints.Key", "labels": []}
{"id": 12805, "text": "if the Key.isCompatibleValue() method of the specified key returns false for the specified value", "labels": []}
{"id": 12806, "text": "if unsupported events or modifiers are specified", "labels": []}
{"id": 12807, "text": "if an invalid of combination of events are modifiers are specified", "labels": []}
{"id": 12808, "text": "if the watch service is closed", "labels": []}
{"id": 12809, "text": "if a security manager is installed and it denies an unspecified permission required to monitor this object.", "labels": []}
{"id": 12810, "text": "Implementations of this interface should specify the permission checks.", "labels": []}
{"id": 12811, "text": "If any of the linkage invariants described here are violated, or the lookup context does not have private access privileges.", "labels": []}
{"id": 12812, "text": "If any of the incoming arguments is null.", "labels": []}
{"id": 12813, "text": "This will never happen when a bootstrap method is called with invokedynamic.", "labels": []}
{"id": 12814, "text": "If any of the incoming arguments is null, or any constant in recipe is null.", "labels": []}
{"id": 12815, "text": "if fromIndex or toIndex is out of range (fromIndex < 0 || toIndex > size() || toIndex < fromIndex)", "labels": []}
{"id": 12816, "text": "if an endpoint index value is out of range (fromIndex < 0 || toIndex > size)", "labels": []}
{"id": 12817, "text": "if the endpoint indices are out of order (fromIndex > toIndex)", "labels": []}
{"id": 12818, "text": "if a security manager exists and its checkCreateClassLoader method doesn't allow creation of a class loader.", "labels": []}
{"id": 12819, "text": "if urls or any of its elements is null.", "labels": []}
{"id": 12820, "text": "if the given name is empty.", "labels": []}
{"id": 12821, "text": "if a security manager exists and its SecurityManager.checkCreateClassLoader() method doesn't allow creation of a class loader.", "labels": []}
{"id": 12822, "text": "If name is null", "labels": []}
{"id": 12823, "text": "if closing any file opened by this class loader resulted in an IOException.", "labels": []}
{"id": 12824, "text": "Any such exceptions are caught internally.", "labels": []}
{"id": 12825, "text": "If only one is caught, then it is re-thrown.", "labels": []}
{"id": 12826, "text": "If more than one exception is caught, then the second and following exceptions are added as suppressed exceptions of the first one caught, which is then re-thrown.", "labels": []}
{"id": 12827, "text": "if a security manager is set, and it denies RuntimePermission(\"closeClassLoader\")", "labels": []}
{"id": 12828, "text": "if codesource is null.", "labels": []}
{"id": 12829, "text": "if the given key material is null, or starting at offset inclusive, is shorter than 8 bytes.", "labels": []}
{"id": 12830, "text": "if the resources for the default locale cannot be found or cannot be loaded.", "labels": []}
{"id": 12831, "text": "if the resources for the specified locale cannot be found or cannot be loaded.", "labels": []}
{"id": 12832, "text": "if the length of any row in newZoneStrings is less than 5", "labels": []}
{"id": 12833, "text": "if newZoneStrings is null", "labels": []}
{"id": 12834, "text": "if name is empty or actions is not null.", "labels": []}
{"id": 12835, "text": "if no Provider supports a CertificateFactorySpi implementation for the specified type", "labels": []}
{"id": 12836, "text": "if a CertificateFactorySpi implementation for the specified algorithm is not available from the specified provider", "labels": []}
{"id": 12837, "text": "if a CertificateFactorySpi implementation for the specified algorithm is not available from the specified Provider object", "labels": []}
{"id": 12838, "text": "on parsing errors.", "labels": []}
{"id": 12839, "text": "if the given implementation is null, or if the mbeanInterface does not follow JMX design patterns for Management Interfaces, or if the given implementation does not implement the specified interface.", "labels": []}
{"id": 12840, "text": "if the mbeanInterface does not follow JMX design patterns for Management Interfaces, or if this does not implement the specified interface.", "labels": []}
{"id": 12841, "text": "if this is an MXBean and name is null.", "labels": []}
{"id": 12842, "text": "if this is an MXBean and it has already been registered under another name (in this MBean Server or another).", "labels": []}
{"id": 12843, "text": "no other checked exceptions are thrown by this method but Exception is declared so that subclasses can override the method and throw their own exceptions.", "labels": []}
{"id": 12844, "text": "no checked exceptions are throw by this method but Exception is declared so that subclasses can override this method and throw their own exceptions.", "labels": []}
{"id": 12845, "text": "if protectionAlgorithm is null", "labels": []}
{"id": 12846, "text": "if the password has been cleared (destroyed)", "labels": []}
{"id": 12847, "text": "if the option is unrecognized, the socket is closed, or some low-level error occurred", "labels": []}
{"id": 12848, "text": "if the socket is closed", "labels": []}
{"id": 12849, "text": "if optID is unknown along the protocol stack (including the SocketImpl)", "labels": []}
{"id": 12850, "text": "if cd does not represent a GcInfo object with the attributes described above.", "labels": []}
{"id": 12851, "text": "if cd does not represent a LockInfo with the attributes described above.", "labels": []}
{"id": 12852, "text": "if after is null", "labels": []}
{"id": 12853, "text": "If the stream is closed", "labels": []}
{"id": 12854, "text": "if the generic field signature does not conform to the format specified in The Java\u2122 Virtual Machine Specification", "labels": []}
{"id": 12855, "text": "if the generic type signature of the underlying field refers to a non-existent type declaration", "labels": []}
{"id": 12856, "text": "if the generic signature of the underlying field refers to a parameterized type that cannot be instantiated for any reason", "labels": []}
{"id": 12857, "text": "if this Field object is enforcing Java language access control and the underlying field is inaccessible.", "labels": []}
{"id": 12858, "text": "if the specified object is not an instance of the class or interface declaring the underlying field (or a subclass or implementor thereof).", "labels": []}
{"id": 12859, "text": "if the specified object is null and the field is an instance field.", "labels": []}
{"id": 12860, "text": "if this Field object is enforcing Java language access control and the underlying field is either inaccessible or final.", "labels": []}
{"id": 12861, "text": "if the specified object is not an instance of the class or interface declaring the underlying field (or a subclass or implementor thereof), or if an unwrapping conversion fails.", "labels": []}
{"id": 12862, "text": "if any of the list elements are null.", "labels": []}
{"id": 12863, "text": "if any of the bounds refers to a non-existent type declaration", "labels": []}
{"id": 12864, "text": "if any of the bounds refer to a parameterized type that cannot be instantiated for any reason", "labels": []}
{"id": 12865, "text": "if s or charset is null.", "labels": []}
{"id": 12866, "text": "if serialization failed", "labels": []}
{"id": 12867, "text": "if deserialization failed", "labels": []}
{"id": 12868, "text": "if needed classes are not found", "labels": []}
{"id": 12869, "text": "if child implements both BeanContextChild and BeanContextProxy", "labels": []}
{"id": 12870, "text": "If there are fewer than length shorts remaining in this buffer", "labels": []}
{"id": 12871, "text": "If there is insufficient space in this buffer for the remaining shorts in the source buffer", "labels": []}
{"id": 12872, "text": "if a security manager exists and its checkConnect method doesn't allow the operation.", "labels": []}
{"id": 12873, "text": "if the host is not known", "labels": []}
{"id": 12874, "text": "if address is null.", "labels": []}
{"id": 12875, "text": "if the port parameter or clientPort parameter is outside the specified range of valid port values, which is between 0 and 65535, inclusive.", "labels": []}
{"id": 12876, "text": "when one or more of the ciphers named by the parameter is not supported, or when the parameter is null.", "labels": []}
{"id": 12877, "text": "if the underlying provider does not implement the operation.", "labels": []}
{"id": 12878, "text": "on a network level error", "labels": []}
{"id": 12879, "text": "if a mode change is attempted after the initial handshake has begun.", "labels": []}
{"id": 12880, "text": "If getting the schema is not supported.", "labels": []}
{"id": 12881, "text": "If a naming exception occurs while getting the schema.", "labels": []}
{"id": 12882, "text": "If the preconditions on the parameter do not hold", "labels": []}
{"id": 12883, "text": "If the precondition on the parameter does not hold", "labels": []}
{"id": 12884, "text": "If a decoding operation is already in progress and the previous step was an invocation neither of the reset method, nor of this method with a value of false for the endOfInput parameter, nor of this method with a value of true for the endOfInput parameter but a return value indicating an incomplete decoding operation", "labels": []}
{"id": 12885, "text": "If an invocation of the decodeLoop method threw an unexpected exception", "labels": []}
{"id": 12886, "text": "If the previous step of the current decoding operation was an invocation neither of the flush method nor of the three-argument decode method with a value of true for the endOfInput parameter", "labels": []}
{"id": 12887, "text": "If a decoding operation is already in progress", "labels": []}
{"id": 12888, "text": "If the byte sequence starting at the input buffer's current position is not legal for this charset and the current malformed-input action is CodingErrorAction.REPORT", "labels": []}
{"id": 12889, "text": "If the byte sequence starting at the input buffer's current position cannot be mapped to an equivalent character sequence and the current unmappable-character action is CodingErrorAction.REPORT", "labels": []}
{"id": 12890, "text": "If this decoder does not implement an auto-detecting charset", "labels": []}
{"id": 12891, "text": "If insufficient bytes have been read to determine a charset", "labels": []}
{"id": 12892, "text": "if the cookie name contains illegal characters", "labels": []}
{"id": 12893, "text": "if header string violates the cookie specification's syntax or the cookie name contains illegal characters.", "labels": []}
{"id": 12894, "text": "if the header string is null", "labels": []}
{"id": 12895, "text": "if either keyMapper or valueMapper is null", "labels": []}
{"id": 12896, "text": "if the keyMapper, valueMapper, or mergeFunction is null", "labels": []}
{"id": 12897, "text": "If this UUID is not a version 1 UUID", "labels": []}
{"id": 12898, "text": "if a database access error occurs or this method is called while the cursor is on the insert row, before the first row, or after the last row", "labels": []}
{"id": 12899, "text": "if a security manager already exists and its checkPermission method doesn't allow creation of a new security manager.", "labels": []}
{"id": 12900, "text": "if access is not permitted based on the current security policy.", "labels": []}
{"id": 12901, "text": "if the permission argument is null.", "labels": []}
{"id": 12902, "text": "if the specified security context is not an instance of AccessControlContext (e.g., is null), or is denied access to the resource specified by the given permission.", "labels": []}
{"id": 12903, "text": "if the calling thread does not have permission to create a new class loader.", "labels": []}
{"id": 12904, "text": "if the calling thread does not have permission to modify the thread.", "labels": []}
{"id": 12905, "text": "if the thread argument is null.", "labels": []}
{"id": 12906, "text": "if the calling thread does not have permission to modify the thread group.", "labels": []}
{"id": 12907, "text": "if the thread group argument is null.", "labels": []}
{"id": 12908, "text": "if the calling thread does not have permission to halt the Java Virtual Machine with the specified status.", "labels": []}
{"id": 12909, "text": "if the calling thread does not have permission to create a subprocess.", "labels": []}
{"id": 12910, "text": "if the cmd argument is null.", "labels": []}
{"id": 12911, "text": "if the calling thread does not have permission to dynamically link the library.", "labels": []}
{"id": 12912, "text": "if the lib argument is null.", "labels": []}
{"id": 12913, "text": "if the calling thread does not have permission to access the specified file descriptor.", "labels": []}
{"id": 12914, "text": "if the file descriptor argument is null.", "labels": []}
{"id": 12915, "text": "if the calling thread does not have permission to access the specified file.", "labels": []}
{"id": 12916, "text": "if the file argument is null.", "labels": []}
{"id": 12917, "text": "if the specified security context is not an instance of AccessControlContext (e.g., is null), or does not have permission to read the specified file.", "labels": []}
{"id": 12918, "text": "if the calling thread does not have permission to delete the file.", "labels": []}
{"id": 12919, "text": "if the calling thread does not have permission to open a socket connection to the specified host and port.", "labels": []}
{"id": 12920, "text": "if the host argument is null.", "labels": []}
{"id": 12921, "text": "if the specified security context is not an instance of AccessControlContext (e.g., is null), or does not have permission to open a socket connection to the specified host and port.", "labels": []}
{"id": 12922, "text": "if the calling thread does not have permission to listen on the specified port.", "labels": []}
{"id": 12923, "text": "if the calling thread does not have permission to accept the connection.", "labels": []}
{"id": 12924, "text": "if the calling thread is not allowed to use (join/leave/send/receive) IP multicast.", "labels": []}
{"id": 12925, "text": "if the address argument is null.", "labels": []}
{"id": 12926, "text": "if the calling thread does not have permission to access or modify the system properties.", "labels": []}
{"id": 12927, "text": "if the calling thread does not have permission to access the specified system property.", "labels": []}
{"id": 12928, "text": "if the key argument is null.", "labels": []}
{"id": 12929, "text": "if key is empty.", "labels": []}
{"id": 12930, "text": "if the calling thread does not have permission to initiate a print job request.", "labels": []}
{"id": 12931, "text": "if the calling thread does not have permission to access the specified package.", "labels": []}
{"id": 12932, "text": "if the package name argument is null.", "labels": []}
{"id": 12933, "text": "if the calling thread does not have permission to define classes in the specified package.", "labels": []}
{"id": 12934, "text": "if the calling thread does not have permission to specify a socket factory or a stream handler factory.", "labels": []}
{"id": 12935, "text": "if the calling thread does not have permission for the requested access.", "labels": []}
{"id": 12936, "text": "if target is null.", "labels": []}
{"id": 12937, "text": "if target is empty.", "labels": []}
{"id": 12938, "text": "if the task has started", "labels": []}
{"id": 12939, "text": "if an unrecoverable error occurred in a user-supplied component.", "labels": []}
{"id": 12940, "text": "if called more than once", "labels": []}
{"id": 12941, "text": "if object is unknown", "labels": []}
{"id": 12942, "text": "if group is unknown", "labels": []}
{"id": 12943, "text": "if an exception occurs while decoding", "labels": []}
{"id": 12944, "text": "if an exception occurs while decoding or the encoding requested is not supported", "labels": []}
{"id": 12945, "text": "if a database access error occurs or this method is called on a closed result set", "labels": []}
{"id": 12946, "text": "if the columnIndex is not valid; if a database access error occurs or this method is called on a closed result set", "labels": []}
{"id": 12947, "text": "if the columnLabel is not valid; if a database access error occurs or this method is called on a closed result set", "labels": []}
{"id": 12948, "text": "if a database access error occurs; this method is called on a closed result set or the result set type is TYPE_FORWARD_ONLY", "labels": []}
{"id": 12949, "text": "if a database access error occurs; this method is called on a closed result set or the condition rows >= 0 is not satisfied", "labels": []}
{"id": 12950, "text": "if the columnIndex is not valid; if a database access error occurs; the result set concurrency is CONCUR_READ_ONLY or this method is called on a closed result set", "labels": []}
{"id": 12951, "text": "if the columnLabel is not valid; if a database access error occurs; the result set concurrency is CONCUR_READ_ONLY or this method is called on a closed result set", "labels": []}
{"id": 12952, "text": "if a database access error occurs; the result set concurrency is CONCUR_READ_ONLY, this method is called on a closed result set, if this method is called when the cursor is not on the insert row, or if not all of non-nullable columns in the insert row have been given a non-null value", "labels": []}
{"id": 12953, "text": "if a database access error occurs; the result set concurrency is CONCUR_READ_ONLY; this method is called on a closed result set or if this method is called when the cursor is on the insert row", "labels": []}
{"id": 12954, "text": "if a database access error occurs; this method is called on a closed result set; the result set type is TYPE_FORWARD_ONLY or if this method is called when the cursor is on the insert row", "labels": []}
{"id": 12955, "text": "if the JDBC driver does not support this method or this method is not supported for the specified result set type and result set concurrency.", "labels": []}
{"id": 12956, "text": "if a database access error occurs; this method is called on a closed result set; the result set concurrency is CONCUR_READ_ONLY or if this method is called when the cursor is on the insert row", "labels": []}
{"id": 12957, "text": "if a database access error occurs; this method is called on a closed result set or the result set concurrency is CONCUR_READ_ONLY", "labels": []}
{"id": 12958, "text": "if the columnLabel is not valid or if a database access error occurs or this method is called on a closed result set", "labels": []}
{"id": 12959, "text": "if the columnIndex is not valid; if the driver does not support national character sets; if the driver can detect that a data conversion error could occur; this method is called on a closed result set; the result set concurrency is CONCUR_READ_ONLY or if a database access error occurs", "labels": []}
{"id": 12960, "text": "if the columnLabel is not valid; if the driver does not support national character sets; if the driver can detect that a data conversion error could occur; this method is called on a closed result set; the result set concurrency is CONCUR_READ_ONLY or if a database access error occurs", "labels": []}
{"id": 12961, "text": "if the columnIndex is not valid; if the driver does not support national character sets; if the driver can detect that a data conversion error could occur; this method is called on a closed result set; if a database access error occurs or the result set concurrency is CONCUR_READ_ONLY", "labels": []}
{"id": 12962, "text": "if the columnLabel is not valid; if the driver does not support national character sets; if the driver can detect that a data conversion error could occur; this method is called on a closed result set; if a database access error occurs or the result set concurrency is CONCUR_READ_ONLY", "labels": []}
{"id": 12963, "text": "if the columnIndex is not valid; if a database access error occurs; this method is called on a closed result set; the java.xml.transform.Result, Writer or OutputStream has not been closed for the SQLXML object; if there is an error processing the XML value or the result set concurrency is CONCUR_READ_ONLY.", "labels": []}
{"id": 12964, "text": "The getCause method of the exception may provide a more detailed exception, for example, if the stream does not contain valid XML.", "labels": []}
{"id": 12965, "text": "if the columnLabel is not valid; if a database access error occurs; this method is called on a closed result set; the java.xml.transform.Result, Writer or OutputStream has not been closed for the SQLXML object; if there is an error processing the XML value or the result set concurrency is CONCUR_READ_ONLY.", "labels": []}
{"id": 12966, "text": "if the columnIndex is not valid; if the driver does not support national character sets; if the driver can detect that a data conversion error could occur; this method is called on a closed result set, if a database access error occurs or the result set concurrency is CONCUR_READ_ONLY", "labels": []}
{"id": 12967, "text": "if conversion is not supported, type is null or another error occurs.", "labels": []}
{"id": 12968, "text": "The getCause() method of the exception may provide a more detailed exception, for example, if a conversion error occurs", "labels": []}
{"id": 12969, "text": "if the JDBC driver does not support this method; if the JDBC driver does not support the specified targetSqlType", "labels": []}
{"id": 12970, "text": "if the type has not yet been loaded through the appropriate class loader.", "labels": []}
{"id": 12971, "text": "if the stack frame's method does not match this variable's method.", "labels": []}
{"id": 12972, "text": "Wraps an IllegalArgumentException for an invalid Descriptor", "labels": []}
{"id": 12973, "text": "if column or newIndex are not in the valid range", "labels": []}
{"id": 12974, "text": "if identifier is null, or if no TableColumn has this identifier", "labels": []}
{"id": 12975, "text": "if newModel is null", "labels": []}
{"id": 12976, "text": "if behavior is not one of the known values", "labels": []}
{"id": 12977, "text": "if the AbstractFormatter is not able to format the current value", "labels": []}
{"id": 12978, "text": "if any of the restrictions on the parameters are violated", "labels": []}
{"id": 12979, "text": "if the interfaces array argument or any of its elements are null, or if the invocation handler, h, is null", "labels": []}
{"id": 12980, "text": "if cl is null", "labels": []}
{"id": 12981, "text": "The date is null or the period or the number of occurrences is negative.", "labels": []}
{"id": 12982, "text": "The date is null or the period is negative.", "labels": []}
{"id": 12983, "text": "The date is null.", "labels": []}
{"id": 12984, "text": "if cd does not represent a MemoryNotificationInfo object.", "labels": []}
{"id": 12985, "text": "if a parsing error occurs", "labels": []}
{"id": 12986, "text": "if an error occurs serializing the Array object", "labels": []}
{"id": 12987, "text": "if a database access error occurs or if the array or the map values are null", "labels": []}
{"id": 12988, "text": "if a database access error occurs or the array parameter is null.", "labels": []}
{"id": 12989, "text": "if an error occurs releasing the SerialArray's resources", "labels": []}
{"id": 12990, "text": "if an error occurs; if free had previously been called on this object", "labels": []}
{"id": 12991, "text": "if called with the cause set to UnsupportedOperationException", "labels": []}
{"id": 12992, "text": "if an I/O error occurred", "labels": []}
{"id": 12993, "text": "if the specified principals, pubCredentials, or privCredentials are null, or a null value exists within any of these three Sets.", "labels": []}
{"id": 12994, "text": "if a security manager is installed and the caller does not have an AuthPermission(\"setReadOnly\") permission to set this Subject to be read-only.", "labels": []}
{"id": 12995, "text": "if the PrivilegedExceptionAction.run method throws a checked exception.", "labels": []}
{"id": 12996, "text": "if the specified PrivilegedExceptionAction is null.", "labels": []}
{"id": 12997, "text": "if a security manager is installed and the caller does not have an AuthPermission(\"doAs\") permission to invoke this method.", "labels": []}
{"id": 12998, "text": "if the PrivilegedAction is null.", "labels": []}
{"id": 12999, "text": "if a security manager is installed and the caller does not have a AuthPermission(\"doAsPrivileged\") permission to invoke this method.", "labels": []}
{"id": 13000, "text": "if the specified Class is null.", "labels": []}
{"id": 13001, "text": "if a security manager is installed and the caller does not have a PrivateCredentialPermission permission to access the private credentials for this Subject or the provided Subject.", "labels": []}
{"id": 13002, "text": "if an input or output error occurs.", "labels": []}
{"id": 13003, "text": "if the implementation of this method does not support one or more of the Callbacks specified in the callbacks parameter.", "labels": []}
{"id": 13004, "text": "when the Connector encapsulates a transport that supports a timeout when attaching, a Connector.Argument representing a timeout has been set in the argument map, and a timeout occurs when trying to attach to the target VM.", "labels": []}
{"id": 13005, "text": "when unable to attach.", "labels": []}
{"id": 13006, "text": "if an illegal file dialog mode is supplied", "labels": []}
{"id": 13007, "text": "if an illegal file dialog mode is supplied;", "labels": []}
{"id": 13008, "text": "if the parent's GraphicsConfiguration is not from a screen device;", "labels": []}
{"id": 13009, "text": "if parent is null; this exception is always thrown when GraphicsEnvironment.isHeadless returns true", "labels": []}
{"id": 13010, "text": "if this DropTarget is active and dtde is null", "labels": []}
{"id": 13011, "text": "if dtde is null and at least one of the following is true: this DropTarget is not active, or there is no a DropTargetListener registered.", "labels": []}
{"id": 13012, "text": "if newMethodType is null.", "labels": []}
{"id": 13013, "text": "if newOperation is null.", "labels": []}
{"id": 13014, "text": "if the descriptor's lookup isn't the MethodHandles.publicLookup(), and a security manager is present, and a check for RuntimePermission(\"dynalink.getLookup\") fails.", "labels": []}
{"id": 13015, "text": "if the provided array offset and length would cause an index into the byte array to be negative or greater than or equal to the array length.", "labels": []}
{"id": 13016, "text": "if this is negative.", "labels": []}
{"id": 13017, "text": "if the value of this will not exactly fit in a long.", "labels": []}
{"id": 13018, "text": "if the value of this will not exactly fit in an int.", "labels": []}
{"id": 13019, "text": "if the value of this will not exactly fit in a short.", "labels": []}
{"id": 13020, "text": "if the value of this will not exactly fit in a byte.", "labels": []}
{"id": 13021, "text": "if recording is already started or is in the CLOSED state", "labels": []}
{"id": 13022, "text": "if the recording is not it the NEW state", "labels": []}
{"id": 13023, "text": "if the recording is not started or is already stopped", "labels": []}
{"id": 13024, "text": "if a security manager exists and the caller doesn't have FilePermission to write to the destination path", "labels": []}
{"id": 13025, "text": "if the recording can't be copied to the specified location", "labels": []}
{"id": 13026, "text": "if maxSize is negative", "labels": []}
{"id": 13027, "text": "if the recording is in CLOSED state", "labels": []}
{"id": 13028, "text": "if maxAge is negative", "labels": []}
{"id": 13029, "text": "if the recording is in the CLOSED state", "labels": []}
{"id": 13030, "text": "if recording is in the STOPPED or CLOSED state.", "labels": []}
{"id": 13031, "text": "if a security manager exists and the caller doesn't have FilePermission to read, write, and delete the destination file", "labels": []}
{"id": 13032, "text": "if the path is not writable", "labels": []}
{"id": 13033, "text": "if recording is in the STOPPED or CLOSED state", "labels": []}
{"id": 13034, "text": "if a database access error occurs.", "labels": []}
{"id": 13035, "text": "if the data source does not use java.util.logging", "labels": []}
{"id": 13036, "text": "if parties less than zero or greater than the maximum number of parties supported", "labels": []}
{"id": 13037, "text": "if attempting to register more than the maximum supported number of parties", "labels": []}
{"id": 13038, "text": "if parties < 0", "labels": []}
{"id": 13039, "text": "if not terminated and the number of unarrived parties would become negative", "labels": []}
{"id": 13040, "text": "if not terminated and the number of registered or unarrived parties would become negative", "labels": []}
{"id": 13041, "text": "if thread interrupted while waiting", "labels": []}
{"id": 13042, "text": "if timed out while waiting", "labels": []}
{"id": 13043, "text": "if x <= 0, y <= 0, or units < 1", "labels": []}
{"id": 13044, "text": "if GraphicsEnvironment.isHeadless() returns true.", "labels": []}
{"id": 13045, "text": "if gc is not from a screen device.", "labels": []}
{"id": 13046, "text": "If the bits array argument is not null, its length is less than the number of color and alpha components, and transferType is one of DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT, or DataBuffer.TYPE_INT.", "labels": []}
{"id": 13047, "text": "If transferType is not one of DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT, DataBuffer.TYPE_INT, DataBuffer.TYPE_SHORT, DataBuffer.TYPE_FLOAT, or DataBuffer.TYPE_DOUBLE.", "labels": []}
{"id": 13048, "text": "If there is more than one component in this ColorModel.", "labels": []}
{"id": 13049, "text": "If the component value for this ColorModel is signed", "labels": []}
{"id": 13050, "text": "If inData is not a primitive array of type transferType.", "labels": []}
{"id": 13051, "text": "if inData is not large enough to hold a pixel value for this ColorModel.", "labels": []}
{"id": 13052, "text": "If the transfer type of this ComponentColorModel is not one of the supported transfer types: DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT, DataBuffer.TYPE_INT, DataBuffer.TYPE_SHORT, DataBuffer.TYPE_FLOAT, or DataBuffer.TYPE_DOUBLE.", "labels": []}
{"id": 13053, "text": "If pixel is not null and is not a primitive array of type transferType.", "labels": []}
{"id": 13054, "text": "If pixel is not large enough to hold a pixel value for this ColorModel.", "labels": []}
{"id": 13055, "text": "If this ColorModel does not support the unnormalized form", "labels": []}
{"id": 13056, "text": "If the components array is not null and is not large enough to hold all the color and alpha components (starting at offset).", "labels": []}
{"id": 13057, "text": "If this ComponentColorModel does not support the unnormalized form", "labels": []}
{"id": 13058, "text": "If pixel is not a primitive array of type transferType.", "labels": []}
{"id": 13059, "text": "If the components array is not null and is not large enough to hold all the color and alpha components (starting at offset), or if pixel is not large enough to hold a pixel value for this ColorModel.", "labels": []}
{"id": 13060, "text": "if the length of normComponents minus normOffset is less than numComponents", "labels": []}
{"id": 13061, "text": "if pixel values for this ColorModel are not conveniently representable as a single int", "labels": []}
{"id": 13062, "text": "if the normComponents array is not large enough to hold all of the color and alpha components starting at normOffset", "labels": []}
{"id": 13063, "text": "if obj is not a primitive array of type transferType", "labels": []}
{"id": 13064, "text": "if obj is not large enough to hold a pixel value for this ColorModel or the normComponents array is not large enough to hold all of the color and alpha components starting at normOffset", "labels": []}
{"id": 13065, "text": "if pixel is not a primitive array of type transferType", "labels": []}
{"id": 13066, "text": "if normComponents is not large enough to hold all color and alpha components starting at normOffset", "labels": []}
{"id": 13067, "text": "if pixel is not large enough to hold a pixel value for this ColorModel.", "labels": []}
{"id": 13068, "text": "if raster is null and data coercion is required.", "labels": []}
{"id": 13069, "text": "if the transfer type of this ComponentColorModel is not one of the supported transfer types: DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT, DataBuffer.TYPE_INT, DataBuffer.TYPE_SHORT, DataBuffer.TYPE_FLOAT, or DataBuffer.TYPE_DOUBLE.", "labels": []}
{"id": 13070, "text": "if an I/O error occurred, or if close() has been called and this file manager cannot be reopened", "labels": []}
{"id": 13071, "text": "if the location is a module-oriented location", "labels": []}
{"id": 13072, "text": "if close() has been called and this file manager cannot be reopened", "labels": []}
{"id": 13073, "text": "if either of the arguments were created with another file manager and this file manager does not support foreign file objects", "labels": []}
{"id": 13074, "text": "if this option to this file manager is used incorrectly", "labels": []}
{"id": 13075, "text": "if sibling is not known to this file manager, or if the location is not known to this file manager and the file manager does not support unknown locations, or if the kind is not valid, or if the location is not an output location", "labels": []}
{"id": 13076, "text": "if the location is not known to this file manager and the file manager does not support unknown locations, or if relativeName is not valid, or if the location is a module-oriented location", "labels": []}
{"id": 13077, "text": "if sibling is not known to this file manager, or if the location is not known to this file manager and the file manager does not support unknown locations, or if relativeName is not valid, or if the location is not an output location", "labels": []}
{"id": 13078, "text": "if this operation if not supported by this file manager", "labels": []}
{"id": 13079, "text": "if the location is neither an output location nor a module-oriented location", "labels": []}
{"id": 13080, "text": "if the location is not a module-oriented location", "labels": []}
{"id": 13081, "text": "if there is a problem determining the result", "labels": []}
{"id": 13082, "text": "if destinationBands contains a negative or duplicate value.", "labels": []}
{"id": 13083, "text": "if either the width or the height is negative or 0.", "labels": []}
{"id": 13084, "text": "if image resizing is not supported by this plug-in.", "labels": []}
{"id": 13085, "text": "if minPass is negative, numPasses is negative or 0, or numPasses is smaller than Integer.MAX_VALUE but minPass + numPasses - 1 is greater than INTEGER.MAX_VALUE.", "labels": []}
{"id": 13086, "text": "if computing either origin.x + sampleModel.getWidth() or origin.y + sampleModel.getHeight() results in integer overflow", "labels": []}
{"id": 13087, "text": "either sampleModel or origin is null", "labels": []}
{"id": 13088, "text": "if any of sampleModel, dataBuffer, aRegion or sampleModelTranslate is null", "labels": []}
{"id": 13089, "text": "if aRegion has width or height less than or equal to zero, or computing either aRegion.x + aRegion.width or aRegion.y + aRegion.height results in integer overflow", "labels": []}
{"id": 13090, "text": "if w or h is less than or equal to zero, or computing either location.x + w or location.y + h results in integer overflow", "labels": []}
{"id": 13091, "text": "if dataType is not one of the supported data types, which are DataBuffer.TYPE_BYTE, or DataBuffer.TYPE_USHORT.", "labels": []}
{"id": 13092, "text": "if bands is less than 1", "labels": []}
{"id": 13093, "text": "if dataType is not one of the supported data types, which are DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT or DataBuffer.TYPE_INT", "labels": []}
{"id": 13094, "text": "if bankIndices or bandOffsets is null", "labels": []}
{"id": 13095, "text": "if the product of bitsPerBand and bands is greater than the number of bits held by dataType", "labels": []}
{"id": 13096, "text": "if bitsPerBand or bands is not greater than zero", "labels": []}
{"id": 13097, "text": "if dataType is not one of the supported data types, which are DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT", "labels": []}
{"id": 13098, "text": "if dataBuffer has more than one bank.", "labels": []}
{"id": 13099, "text": "if dataBuffer is null", "labels": []}
{"id": 13100, "text": "if computing either location.x + sm.getWidth() or location.y + sm.getHeight() results in integer overflow", "labels": []}
{"id": 13101, "text": "if db has more than one bank and sm is a PixelInterleavedSampleModel, SinglePixelPackedSampleModel, or MultiPixelPackedSampleModel.", "labels": []}
{"id": 13102, "text": "if either SampleModel or DataBuffer is null", "labels": []}
{"id": 13103, "text": "if the specified subregion is outside of the raster bounds.", "labels": []}
{"id": 13104, "text": "if width or height is less than or equal to zero, or computing any of parentX + width, parentY + height, childMinX + width, or childMinY + height results in integer overflow", "labels": []}
{"id": 13105, "text": "if the coordinates are not in bounds, or if outData is too small to hold the output.", "labels": []}
{"id": 13106, "text": "if the coordinates are not in bounds, or if fArray is too small to hold the output.", "labels": []}
{"id": 13107, "text": "if the coordinates are not in bounds, or if dArray is too small to hold the output.", "labels": []}
{"id": 13108, "text": "if the coordinates or the band index are not in bounds.", "labels": []}
{"id": 13109, "text": "if the coordinates or the band index are not in bounds, or if iArray is too small to hold the output.", "labels": []}
{"id": 13110, "text": "if the coordinates or the band index are not in bounds, or if fArray is too small to hold the output.", "labels": []}
{"id": 13111, "text": "if the coordinates or the band index are not in bounds, or if dArray is too small to hold the output.", "labels": []}
{"id": 13112, "text": "if the model is null", "labels": []}
{"id": 13113, "text": "if layoutOrientation isn't one of the allowable values", "labels": []}
{"id": 13114, "text": "if selectionModel is null", "labels": []}
{"id": 13115, "text": "if visibleRect is null, or orientation isn't one of SwingConstants.VERTICAL or SwingConstants.HORIZONTAL", "labels": []}
{"id": 13116, "text": "If an error occurred while processing the response or generating a challenge.", "labels": []}
{"id": 13117, "text": "if this authentication session has not completed", "labels": []}
{"id": 13118, "text": "if incoming cannot be successfully unwrapped.", "labels": []}
{"id": 13119, "text": "if the authentication exchange has not completed, or if the negotiated quality of protection has neither integrity nor privacy", "labels": []}
{"id": 13120, "text": "if outgoing cannot be successfully wrapped.", "labels": []}
{"id": 13121, "text": "if the authentication exchange has not completed, or if the negotiated quality of protection has neither integrity nor privacy.", "labels": []}
{"id": 13122, "text": "if this authentication exchange has not completed", "labels": []}
{"id": 13123, "text": "if an I/O error occurs during socket creation", "labels": []}
{"id": 13124, "text": "if something goes wrong", "labels": []}
{"id": 13125, "text": "The specified object is null.", "labels": []}
{"id": 13126, "text": "The specified attribute is null.", "labels": []}
{"id": 13127, "text": "if this Permissions object is marked as readonly.", "labels": []}
{"id": 13128, "text": "If there is an error setting up the new input source.", "labels": []}
{"id": 13129, "text": "INDEX_SIZE_ERR: Raised if the specified index is greater than the number of cells or if the index is negative.", "labels": []}
{"id": 13130, "text": "if the value of any field is out of range, or if the day-of-month is invalid for the month-year", "labels": []}
{"id": 13131, "text": "if the value of any field is out of range, or if the day-of-year is invalid for the year", "labels": []}
{"id": 13132, "text": "if the amount cannot be calculated, or the end temporal cannot be converted to a LocalDate", "labels": []}
{"id": 13133, "text": "if step is zero, or step.getDays() and step.toTotalMonths() have opposite sign, or end date is before this date and step is positive, or end date is after this date and step is negative", "labels": []}
{"id": 13134, "text": "if the value of any field is out of range", "labels": []}
{"id": 13135, "text": "if the amount cannot be calculated, or the end temporal cannot be converted to an OffsetTime", "labels": []}
{"id": 13136, "text": "If the given object is null", "labels": []}
{"id": 13137, "text": "if r,g,b values are out of range", "labels": []}
{"id": 13138, "text": "if no Provider supports an ExemptionMechanismSpi implementation for the specified algorithm", "labels": []}
{"id": 13139, "text": "if an ExemptionMechanismSpi implementation for the specified algorithm is not available from the specified provider", "labels": []}
{"id": 13140, "text": "if an ExemptionMechanismSpi implementation for the specified algorithm is not available from the specified Provider object", "labels": []}
{"id": 13141, "text": "if problem(s) encountered while determining whether the result blob has been generated successfully by this exemption mechanism object.", "labels": []}
{"id": 13142, "text": "if this exemption mechanism is in a wrong state (e.g., has not yet been initialized)", "labels": []}
{"id": 13143, "text": "if the given key is inappropriate for this exemption mechanism.", "labels": []}
{"id": 13144, "text": "if problem(s) encountered in the process of initializing.", "labels": []}
{"id": 13145, "text": "if the given algorithm parameters are inappropriate for this exemption mechanism.", "labels": []}
{"id": 13146, "text": "if this exemption mechanism is in a wrong state (e.g., has not been initialized).", "labels": []}
{"id": 13147, "text": "if the given output buffer is too small to hold the result.", "labels": []}
{"id": 13148, "text": "if problem(s) encountered in the process of generating.", "labels": []}
{"id": 13149, "text": "if radix is out of range", "labels": []}
{"id": 13150, "text": "If no match result is available", "labels": []}
{"id": 13151, "text": "if this scanner is closed", "labels": []}
{"id": 13152, "text": "if no more tokens are available", "labels": []}
{"id": 13153, "text": "if no such tokens are available", "labels": []}
{"id": 13154, "text": "if no line was found", "labels": []}
{"id": 13155, "text": "if horizon is negative", "labels": []}
{"id": 13156, "text": "if the specified pattern is not found", "labels": []}
{"id": 13157, "text": "if the next token is not a valid boolean", "labels": []}
{"id": 13158, "text": "if input is exhausted", "labels": []}
{"id": 13159, "text": "if the radix is out of range", "labels": []}
{"id": 13160, "text": "if the next token does not match the Integer regular expression, or is out of range", "labels": []}
{"id": 13161, "text": "if the next token does not match the Float regular expression, or is out of range", "labels": []}
{"id": 13162, "text": "if the input is exhausted", "labels": []}
{"id": 13163, "text": "if the next token does not match the Decimal regular expression, or is out of range", "labels": []}
{"id": 13164, "text": "If the encoded value cannot be retrieved because the request contains insufficient or invalid data/state.", "labels": []}
{"id": 13165, "text": "if cannot create extended response due to an error.", "labels": []}
{"id": 13166, "text": "If no implementation of the schema language is available.", "labels": []}
{"id": 13167, "text": "If the schemaLanguage parameter is null.", "labels": []}
{"id": 13168, "text": "If a configuration error is encountered.", "labels": []}
{"id": 13169, "text": "if factoryClassName is null, or the factory class cannot be loaded, instantiated or doesn't support the schema language specified in schemLanguage parameter.", "labels": []}
{"id": 13170, "text": "When the SchemaFactory recognizes the feature name but cannot set the requested value.", "labels": []}
{"id": 13171, "text": "If name is null.", "labels": []}
{"id": 13172, "text": "When the SchemaFactory recognizes the property name but cannot set the requested value.", "labels": []}
{"id": 13173, "text": "If an error is found during processing the specified inputs.", "labels": []}
{"id": 13174, "text": "When an ErrorHandler is set, errors are reported to there first.", "labels": []}
{"id": 13175, "text": "See setErrorHandler(ErrorHandler).", "labels": []}
{"id": 13176, "text": "If the schemas parameter itself is null or any item in the array is null.", "labels": []}
{"id": 13177, "text": "If any item in the array is not recognized by this method.", "labels": []}
{"id": 13178, "text": "If the schema language doesn't support this operation.", "labels": []}
{"id": 13179, "text": "If this operation is not supported by the callee.", "labels": []}
{"id": 13180, "text": "If this operation is supported but failed for some reason.", "labels": []}
{"id": 13181, "text": "if the recipient wishes the property change to be rolled back.", "labels": []}
{"id": 13182, "text": "If an error occurs finding the module", "labels": []}
{"id": 13183, "text": "If denied by the security manager", "labels": []}
{"id": 13184, "text": "If an error occurs finding all modules", "labels": []}
{"id": 13185, "text": "if the value of any field is out of range, or if the day-of-month is invalid for the month-year, or if the date is not a Japanese era", "labels": []}
{"id": 13186, "text": "if param is null or is not an instance of the correct class.", "labels": []}
{"id": 13187, "text": "if the linkage fails", "labels": []}
{"id": 13188, "text": "if the initialization provoked by this method fails", "labels": []}
{"id": 13189, "text": "if the class cannot be located by the specified class loader", "labels": []}
{"id": 13190, "text": "if a security manager is present, and the loader is null, and the caller's class loader is not null, and the caller does not have the RuntimePermission(\"getClassLoader\")", "labels": []}
{"id": 13191, "text": "if the given module or name is null", "labels": []}
{"id": 13192, "text": "if the caller is not the specified module and RuntimePermission(\"getClassLoader\") permission is denied; or access to the module content is denied.", "labels": []}
{"id": 13193, "text": "For example, permission check will be performed when a class loader calls ModuleReader.open(String) to read the bytes of a class file in a module.", "labels": []}
{"id": 13194, "text": "if the specified Class parameter is null.", "labels": []}
{"id": 13195, "text": "if a security manager is present, and the caller's class loader is not null and is not the same as or an ancestor of the class loader for the class whose class loader is requested, and the caller does not have the RuntimePermission(\"getClassLoader\")", "labels": []}
{"id": 13196, "text": "if the generic class signature does not conform to the format specified in The Java\u2122 Virtual Machine Specification", "labels": []}
{"id": 13197, "text": "if the generic superclass refers to a non-existent type declaration", "labels": []}
{"id": 13198, "text": "if the generic superclass refers to a parameterized type that cannot be instantiated for any reason", "labels": []}
{"id": 13199, "text": "if any of the generic superinterfaces refers to a non-existent type declaration", "labels": []}
{"id": 13200, "text": "if any of the generic superinterfaces refer to a parameterized type that cannot be instantiated for any reason", "labels": []}
{"id": 13201, "text": "If a security manager, s, is present and the caller's class loader is not the same as or an ancestor of the class loader for the declaring class and invocation of s.checkPackageAccess() denies access to the package of the declaring class", "labels": []}
{"id": 13202, "text": "If a security manager, s, is present and the caller's class loader is not the same as or an ancestor of the class loader for the enclosing class and invocation of s.checkPackageAccess() denies access to the package of the enclosing class", "labels": []}
{"id": 13203, "text": "If a security manager, s, is present and the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of s.checkPackageAccess() denies access to the package of this class.", "labels": []}
{"id": 13204, "text": "if a field with the specified name is not found.", "labels": []}
{"id": 13205, "text": "if a matching method is not found or if the name is \"<init>\"or \"<clinit>\".", "labels": []}
{"id": 13206, "text": "if a matching method is not found.", "labels": []}
{"id": 13207, "text": "if a security manager exists and its checkPermission method doesn't allow getting the ProtectionDomain.", "labels": []}
{"id": 13208, "text": "if this Class object does not represent a subclass of the specified class (here \"subclass\" includes the class itself).", "labels": []}
{"id": 13209, "text": "If the returned class is not the current class, and if a security manager, s, is present and the caller's class loader is not the same as or an ancestor of the class loader for the returned class and invocation of s.checkPackageAccess() denies access to the package of the returned class", "labels": []}
{"id": 13210, "text": "If there is any problem loading or validating a nest member or its nest host", "labels": []}
{"id": 13211, "text": "If any returned class is not the current class, and if a security manager, s, is present and the caller's class loader is not the same as or an ancestor of the class loader for that returned class and invocation of s.checkPackageAccess() denies access to the package of that returned class", "labels": []}
{"id": 13212, "text": "if collection is null", "labels": []}
{"id": 13213, "text": "When there is a failure in creating an XPathFactory for the default object model.", "labels": []}
{"id": 13214, "text": "If the specified object model is unavailable, or if there is a configuration error.", "labels": []}
{"id": 13215, "text": "If uri is null.", "labels": []}
{"id": 13216, "text": "If uri is null or uri.length() == 0.", "labels": []}
{"id": 13217, "text": "if factoryClassName is null, or the factory class cannot be loaded, instantiated or the factory class does not support the object model specified in the uri parameter.", "labels": []}
{"id": 13218, "text": "if this XPathFactory or the XPaths it creates cannot support this feature.", "labels": []}
{"id": 13219, "text": "If resolver is null.", "labels": []}
{"id": 13220, "text": "if the caller does not have permission to refresh its Configuration.", "labels": []}
{"id": 13221, "text": "if passed a null transformer", "labels": []}
{"id": 13222, "text": "if canRetransform is true and the current configuration of the JVM does not allow retransformation (isRetransformClassesSupported() is false)", "labels": []}
{"id": 13223, "text": "if a specified class cannot be modified (isModifiableClass(java.lang.Class<?>) would return false)", "labels": []}
{"id": 13224, "text": "if the current configuration of the JVM does not allow retransformation (isRetransformClassesSupported() is false) or the retransformation attempted to make unsupported changes", "labels": []}
{"id": 13225, "text": "if the data did not contain a valid class", "labels": []}
{"id": 13226, "text": "if the name in the class file is not equal to the name of the class", "labels": []}
{"id": 13227, "text": "if the class file version numbers are not supported", "labels": []}
{"id": 13228, "text": "if the new classes contain a circularity", "labels": []}
{"id": 13229, "text": "if a linkage error occurs", "labels": []}
{"id": 13230, "text": "if the supplied classes array or any of its components is null.", "labels": []}
{"id": 13231, "text": "if the current configuration of the JVM does not allow redefinition (isRedefineClassesSupported() is false) or the redefinition attempted to make unsupported changes", "labels": []}
{"id": 13232, "text": "if the supplied definitions array or any of its components is null", "labels": []}
{"id": 13233, "text": "Can never be thrown (present for compatibility reasons only)", "labels": []}
{"id": 13234, "text": "if the specified class is null.", "labels": []}
{"id": 13235, "text": "If jarfile is null.", "labels": []}
{"id": 13236, "text": "If the system class loader does not support appending a a JAR file to be searched.", "labels": []}
{"id": 13237, "text": "if passed a null transformer.", "labels": []}
{"id": 13238, "text": "if the current configuration of the JVM does not allow setting a native method prefix (isNativeMethodPrefixSupported() is false).", "labels": []}
{"id": 13239, "text": "if the transformer is not registered (see addTransformer).", "labels": []}
{"id": 13240, "text": "If extraExports or extraOpens contains a key that is not a package in the module; if extraExports or extraOpens maps a key to an empty set; if a value in the extraProvides map contains a service provider type that is not a member of the module or an implementation of the service; or extraProvides maps a key to an empty list", "labels": []}
{"id": 13241, "text": "if the module cannot be modified", "labels": []}
{"id": 13242, "text": "if any of the arguments are null or any of the Sets or Maps contains a null key or value", "labels": []}
{"id": 13243, "text": "if the module is null", "labels": []}
{"id": 13244, "text": "if cursorLocn is null", "labels": []}
{"id": 13245, "text": "if dropAction is not one of DnDConstants.", "labels": []}
{"id": 13246, "text": "if srcActions is not a bitwise mask of DnDConstants.", "labels": []}
{"id": 13247, "text": "if dtc is null.", "labels": []}
{"id": 13248, "text": "if component, region of style is null.", "labels": []}
{"id": 13249, "text": "if the new client object cannot be created or exported.", "labels": []}
{"id": 13250, "text": "if the given credentials do not allow the server to authenticate the user successfully.", "labels": []}
{"id": 13251, "text": "if getMBeanServer() is null.", "labels": []}
{"id": 13252, "text": "if closeClient(javax.management.remote.rmi.RMIConnection) throws this exception.", "labels": []}
{"id": 13253, "text": "if client is null.", "labels": []}
{"id": 13254, "text": "if closeServer() or one of the RMIConnection.close() calls threw IOException.", "labels": []}
{"id": 13255, "text": "if the attempt to close the connector server failed.", "labels": []}
{"id": 13256, "text": "if no Provider supports a KeyAgreementSpi implementation for the specified algorithm", "labels": []}
{"id": 13257, "text": "if a KeyAgreementSpi implementation for the specified algorithm is not available from the specified provider", "labels": []}
{"id": 13258, "text": "if a KeyAgreementSpi implementation for the specified algorithm is not available from the specified Provider object", "labels": []}
{"id": 13259, "text": "if the given key is inappropriate for this key agreement, e.g., is of the wrong type or has an incompatible algorithm type.", "labels": []}
{"id": 13260, "text": "if the given parameters are inappropriate for this key agreement.", "labels": []}
{"id": 13261, "text": "if this key agreement has not been initialized or if doPhase has not been called to supply the keys for all parties in the agreement", "labels": []}
{"id": 13262, "text": "if the given output buffer is too small to hold the secret", "labels": []}
{"id": 13263, "text": "if the specified secret-key algorithm is not available", "labels": []}
{"id": 13264, "text": "if the shared secret-key material cannot be used to generate a secret key of the specified algorithm (e.g., the key material is too short)", "labels": []}
{"id": 13265, "text": "If cspace is not one of the predefined color space types", "labels": []}
{"id": 13266, "text": "If the specified file cannot be opened or an I/O error occurs while reading the file", "labels": []}
{"id": 13267, "text": "If the file does not contain valid ICC Profile data", "labels": []}
{"id": 13268, "text": "If a security manager is installed and it does not permit read access to the given file", "labels": []}
{"id": 13269, "text": "If an I/O error occurs while reading the stream", "labels": []}
{"id": 13270, "text": "If the stream does not contain valid ICC Profile data", "labels": []}
{"id": 13271, "text": "if tagSignature is not a signature as defined in the ICC specification.", "labels": []}
{"id": 13272, "text": "if a content of the tagData array can not be interpreted as valid tag data, corresponding to the tagSignature", "labels": []}
{"id": 13273, "text": "if color space is in the profile is invalid", "labels": []}
{"id": 13274, "text": "If any of the linkage invariants described above are violated, or the lookup context does not have private access privileges.", "labels": []}
{"id": 13275, "text": "if the pool is null", "labels": []}
{"id": 13276, "text": "if the amount cannot be calculated, or the end temporal cannot be converted to a ChronoLocalDate", "labels": []}
{"id": 13277, "text": "if the period cannot be calculated", "labels": []}
{"id": 13278, "text": "if apdu is null", "labels": []}
{"id": 13279, "text": "if apdu does not contain a valid command APDU", "labels": []}
{"id": 13280, "text": "if apduOffset or apduLength are negative or if apduOffset + apduLength are greater than apdu.length, or if the specified bytes are not a valid APDU", "labels": []}
{"id": 13281, "text": "if ne is negative or greater than 65536", "labels": []}
{"id": 13282, "text": "if data.length is greater than 65535", "labels": []}
{"id": 13283, "text": "if data is null and dataLength is not 0", "labels": []}
{"id": 13284, "text": "if dataOffset or dataLength are negative or if dataOffset + dataLength are greater than data.length or if dataLength is greater than 65535", "labels": []}
{"id": 13285, "text": "if data.length is greater than 65535 or if ne is negative or greater than 65536", "labels": []}
{"id": 13286, "text": "if dataOffset or dataLength are negative or if dataOffset + dataLength are greater than data.length, or if ne is negative or greater than 65536, or if dataLength is greater than 65535", "labels": []}
{"id": 13287, "text": "If the first byte cannot be read for any reason other than the end of the file, if the input stream has been closed, or if some other I/O error occurs.", "labels": []}
{"id": 13288, "text": "If the first byte cannot be read for any reason other than end of file, or if the input stream has been closed, or if some other I/O error occurs.", "labels": []}
{"id": 13289, "text": "if an array of the required size cannot be allocated.", "labels": []}
{"id": 13290, "text": "if length is negative", "labels": []}
{"id": 13291, "text": "if b is null", "labels": []}
{"id": 13292, "text": "if end of stream is encountered before the stream can be positioned n bytes beyond its position when this method was invoked.", "labels": []}
{"id": 13293, "text": "if the stream cannot be positioned properly or if an I/O error occurs.", "labels": []}
{"id": 13294, "text": "if this stream has not been marked or if the mark has been invalidated.", "labels": []}
{"id": 13295, "text": "if services is null or empty, or attributes is null, or the initial PrintService is not in the list of browsable services", "labels": []}
{"id": 13296, "text": "If this channel is already bound", "labels": []}
{"id": 13297, "text": "If this channel is not yet bound", "labels": []}
{"id": 13298, "text": "If this channel is already bound to the given address", "labels": []}
{"id": 13299, "text": "If address is null or the wildcard address", "labels": []}
{"id": 13300, "text": "address is not bound to the channel's socket, or the channel has only one address bound to it", "labels": []}
{"id": 13301, "text": "If the socket option is not supported by this channel", "labels": []}
{"id": 13302, "text": "If the value is not a valid value for this socket option", "labels": []}
{"id": 13303, "text": "If the given handler invokes the receive method of this channel", "labels": []}
{"id": 13304, "text": "If a security manager has been installed and it does not permit new associations to be accepted from the message's sender", "labels": []}
{"id": 13305, "text": "If streamNumber is negative, or if an association already exists and streamNumber is greater than the maximum number of outgoing streams", "labels": []}
{"id": 13306, "text": "If a security manager has been installed and it does not permit new associations to be setup with the messages's address", "labels": []}
{"id": 13307, "text": "if a network error occurs", "labels": []}
{"id": 13308, "text": "if timeout is negative.", "labels": []}
{"id": 13309, "text": "if either timeout or ttl are negative.", "labels": []}
{"id": 13310, "text": "if IP address is of illegal length", "labels": []}
{"id": 13311, "text": "if no IP address for the host could be found, or if a scope_id was specified for a global IPv6 address.", "labels": []}
{"id": 13312, "text": "if a security manager exists and its checkConnect method doesn't allow the operation", "labels": []}
{"id": 13313, "text": "if the local host name could not be resolved into an address.", "labels": []}
{"id": 13314, "text": "if there are an odd number of parameters, or if a header name or value is not valid, see RFC 7230 section-3.2, or a header name or value is restricted by the implementation.", "labels": []}
{"id": 13315, "text": "if the duration is non-positive", "labels": []}
{"id": 13316, "text": "The prefix parameter is null.", "labels": []}
{"id": 13317, "text": "if any of the non-ignored arguments are null", "labels": []}
{"id": 13318, "text": "if any non-ignored arguments are null", "labels": []}
{"id": 13319, "text": "if the name has the incorrect format, or the kind is invalid", "labels": []}
{"id": 13320, "text": "If a security manager has been installed and it denies RuntimePermission(\"fileSystemProvider\")", "labels": []}
{"id": 13321, "text": "When an error occurs while loading a service provider", "labels": []}
{"id": 13322, "text": "If the pre-conditions for the uri parameter aren't met, or the env parameter does not contain properties required by the provider, or a property value is invalid", "labels": []}
{"id": 13323, "text": "An I/O error occurs creating the file system", "labels": []}
{"id": 13324, "text": "If a security manager is installed and it denies an unspecified permission required by the file system provider implementation", "labels": []}
{"id": 13325, "text": "If the file system has already been created", "labels": []}
{"id": 13326, "text": "If the pre-conditions for the uri parameter aren't met", "labels": []}
{"id": 13327, "text": "If the file system does not exist", "labels": []}
{"id": 13328, "text": "If a security manager is installed and it denies an unspecified permission.", "labels": []}
{"id": 13329, "text": "If the URI scheme does not identify this provider or other preconditions on the uri parameter do not hold", "labels": []}
{"id": 13330, "text": "If this provider does not support access to the contents as a file system or it does not recognize the file type of the given file", "labels": []}
{"id": 13331, "text": "If the env parameter does not contain properties required by the provider, or a property value is invalid", "labels": []}
{"id": 13332, "text": "if an invalid combination of options is specified", "labels": []}
{"id": 13333, "text": "if an unsupported option is specified", "labels": []}
{"id": 13334, "text": "if options contains an invalid combination of options", "labels": []}
{"id": 13335, "text": "The checkDelete method is invoked to check delete access if the file is opened with the DELETE_ON_CLOSE option.", "labels": []}
{"id": 13336, "text": "If this provider that does not support creating file channels, or an unsupported open option or file attribute is specified", "labels": []}
{"id": 13337, "text": "In the case of the default file system, the SecurityManager.checkRead(String) method is invoked to check read access if the file is opened for reading.", "labels": []}
{"id": 13338, "text": "If this provider that does not support creating asynchronous file channels, or an unsupported open option or file attribute is specified", "labels": []}
{"id": 13339, "text": "if the implementation does not support symbolic links or the array contains an attribute that cannot be set atomically when creating the symbolic link", "labels": []}
{"id": 13340, "text": "if a file with the name already exists (optional specific exception)", "labels": []}
{"id": 13341, "text": "if the implementation does not support adding an existing file to a directory", "labels": []}
{"id": 13342, "text": "if the entry could not otherwise be created because a file of that name already exists (optional specific exception)", "labels": []}
{"id": 13343, "text": "if the file is a directory and could not otherwise be deleted because the directory is not empty (optional specific exception)", "labels": []}
{"id": 13344, "text": "if the implementation does not support symbolic links", "labels": []}
{"id": 13345, "text": "if the target could otherwise not be read because the file is not a symbolic link (optional specific exception)", "labels": []}
{"id": 13346, "text": "if the array contains a copy option that is not supported", "labels": []}
{"id": 13347, "text": "if the target file exists but cannot be replaced because the REPLACE_EXISTING option is not specified (optional specific exception)", "labels": []}
{"id": 13348, "text": "the REPLACE_EXISTING option is specified but the file cannot be replaced because it is a non-empty directory (optional specific exception)", "labels": []}
{"id": 13349, "text": "If a symbolic link is copied the security manager is invoked to check LinkPermission(\"symbolic\").", "labels": []}
{"id": 13350, "text": "if the options array contains the ATOMIC_MOVE option but the file cannot be moved as an atomic file system operation.", "labels": []}
{"id": 13351, "text": "This exception is specified to allow for the Access enum to be extended in future releases.", "labels": []}
{"id": 13352, "text": "if a file does not exist (optional specific exception)", "labels": []}
{"id": 13353, "text": "(optional specific exception)", "labels": []}
{"id": 13354, "text": "In the case of the default provider, and a security manager is installed, the checkRead is invoked when checking read access to the file or only the existence of the file, the checkWrite is invoked when checking write access to the file, and checkExec is invoked when checking execute access.", "labels": []}
{"id": 13355, "text": "When message is null.", "labels": []}
{"id": 13356, "text": "if cause is null.", "labels": []}
{"id": 13357, "text": "if columnIndex or newIndex are not in the valid range", "labels": []}
{"id": 13358, "text": "if identifier is null, or no TableColumn has this identifier", "labels": []}
{"id": 13359, "text": "if no Provider supports a KeyManagerFactorySpi implementation for the specified algorithm", "labels": []}
{"id": 13360, "text": "if a KeyManagerFactorySpi implementation for the specified algorithm is not available from the specified provider", "labels": []}
{"id": 13361, "text": "if provider is null", "labels": []}
{"id": 13362, "text": "if a @KeyManagerFactorySpi implementation for the specified algorithm is not available from the specified Provider object", "labels": []}
{"id": 13363, "text": "if cd does not represent a VMOption with the attributes described above.", "labels": []}
{"id": 13364, "text": "If there is a problem reading the raw content of the document.", "labels": []}
{"id": 13365, "text": "If there is a problem processing the document.", "labels": []}
{"id": 13366, "text": "if an error occurs", "labels": []}
{"id": 13367, "text": "exception occurred redefining the classes, some or all were not redefined", "labels": []}
{"id": 13368, "text": "let exceptions pass up the stack", "labels": []}
{"id": 13369, "text": "if exchange is null", "labels": []}
{"id": 13370, "text": "if d is less than 0", "labels": []}
{"id": 13371, "text": "if the value of pos < 0", "labels": []}
{"id": 13372, "text": "if invoked -- this method is not yet implemented", "labels": []}
{"id": 13373, "text": "if a database access error occurs or the given index is out of bounds", "labels": []}
{"id": 13374, "text": "if a database access error occurs or the given column number is out of bounds", "labels": []}
{"id": 13375, "text": "if a database access error occurs, the given column number is out of bounds, or the value supplied for the property parameter is not one of the following constants: ResultSetMetaData.columnNoNulls, ResultSetMetaData.columnNullable, or ResultSetMetaData.columnNullableUnknown", "labels": []}
{"id": 13376, "text": "if a database access error occurs or the given column index is out of bounds", "labels": []}
{"id": 13377, "text": "If no object found that implements the interface", "labels": []}
{"id": 13378, "text": "if an error occurs while determining whether this is a wrapper for an object with the given interface.", "labels": []}
{"id": 13379, "text": "if type, source, or connectionId is null.", "labels": []}
{"id": 13380, "text": "if sequenceNumber is negative.", "labels": []}
{"id": 13381, "text": "if f is null.", "labels": []}
{"id": 13382, "text": "if a security manager exists and does not allow read access to the file.", "labels": []}
{"id": 13383, "text": "if f is a directory or cannot be opened for reading for any other reason.", "labels": []}
{"id": 13384, "text": "if raf is null.", "labels": []}
{"id": 13385, "text": "If the pushback buffer is full, or if some other I/O error occurs", "labels": []}
{"id": 13386, "text": "If there is insufficient room in the pushback buffer, or if some other I/O error occurs", "labels": []}
{"id": 13387, "text": "Always, since mark is not supported", "labels": []}
{"id": 13388, "text": "Always, since reset is not supported", "labels": []}
{"id": 13389, "text": "if the current event is not a START_ELEMENT or if a non text element is encountered", "labels": []}
{"id": 13390, "text": "if anything other than space characters are encountered", "labels": []}
{"id": 13391, "text": "if parameters is null", "labels": []}
{"id": 13392, "text": "if parameters is an empty list", "labels": []}
{"id": 13393, "text": "if the GraphicsEnvironment.isHeadless() method returns true", "labels": []}
{"id": 13394, "text": "if a toolkit could not be found, or if one could not be accessed or instantiated.", "labels": []}
{"id": 13395, "text": "if a security manager exists and its checkRead method doesn't allow the operation.", "labels": []}
{"id": 13396, "text": "if a security manager exists and its checkPermission method doesn't allow the operation.", "labels": []}
{"id": 13397, "text": "if frame is null", "labels": []}
{"id": 13398, "text": "if this thread is not allowed to initiate a print job request", "labels": []}
{"id": 13399, "text": "if pageAttributes specifies differing cross feed and feed resolutions.", "labels": []}
{"id": 13400, "text": "Also if this thread has access to the file system and jobAttributes specifies print to file, and the specified destination file exists but is a directory rather than a regular file, does not exist but cannot be created, or cannot be opened for any other reason.", "labels": []}
{"id": 13401, "text": "However in the case of print to file, if a dialog is also requested to be displayed then the user will be given an opportunity to select a file and proceed with printing.", "labels": []}
{"id": 13402, "text": "The dialog will ensure that the selected output file is valid before returning from this method.", "labels": []}
{"id": 13403, "text": "if this thread is not allowed to initiate a print job request, or if jobAttributes specifies print to file, and this thread is not allowed to access the file system", "labels": []}
{"id": 13404, "text": "if keyCode is not one of the valid key codes", "labels": []}
{"id": 13405, "text": "if the host system doesn't allow getting the state of this key programmatically, or if the keyboard doesn't have this key", "labels": []}
{"id": 13406, "text": "if the hotSpot values are outside the bounds of the cursor", "labels": []}
{"id": 13407, "text": "if a security manager is set and it denies access to the EventQueue", "labels": []}
{"id": 13408, "text": "if not implemented", "labels": []}
{"id": 13409, "text": "if tagName is null.", "labels": []}
{"id": 13410, "text": "if the value is invalid", "labels": []}
{"id": 13411, "text": "if the specified componentType parameter is null", "labels": []}
{"id": 13412, "text": "if componentType is Void.TYPE or if the number of dimensions of the requested array instance exceed 255.", "labels": []}
{"id": 13413, "text": "if the specified length is negative", "labels": []}
{"id": 13414, "text": "if the specified componentType argument is null", "labels": []}
{"id": 13415, "text": "if the specified dimensions argument is a zero-dimensional array, if componentType is Void.TYPE, or if the number of dimensions of the requested array instance exceed 255.", "labels": []}
{"id": 13416, "text": "if any of the components in the specified dimensions argument is negative.", "labels": []}
{"id": 13417, "text": "If the specified object is null", "labels": []}
{"id": 13418, "text": "If the specified object is not an array", "labels": []}
{"id": 13419, "text": "If the specified index argument is negative, or if it is greater than or equal to the length of the specified array", "labels": []}
{"id": 13420, "text": "If the specified object argument is null", "labels": []}
{"id": 13421, "text": "If the specified object argument is not an array, or if the array component type is primitive and an unwrapping conversion fails", "labels": []}
{"id": 13422, "text": "if a drop is not outstanding/extant", "labels": []}
{"id": 13423, "text": "if the specified fm is null", "labels": []}
{"id": 13424, "text": "if value is null", "labels": []}
{"id": 13425, "text": "if the predicate is null", "labels": []}
{"id": 13426, "text": "if the mapping function is null", "labels": []}
{"id": 13427, "text": "if the mapping function is null or returns a null result", "labels": []}
{"id": 13428, "text": "if the supplying function is null or produces a null result", "labels": []}
{"id": 13429, "text": "if offset is is less than 0 or if the length of data is less than 1", "labels": []}
{"id": 13430, "text": "if invocation results in a RemoteException", "labels": []}
{"id": 13431, "text": "if invocation results in an ActivationException", "labels": []}
{"id": 13432, "text": "If a security manager has been installed and it denies RuntimePermission(\"inheritedChannel\")", "labels": []}
{"id": 13433, "text": "if stepSize or value is null or if the following expression is false: minimum <= value <= maximum", "labels": []}
{"id": 13434, "text": "if value is null or not a Number", "labels": []}
{"id": 13435, "text": "if failed to export object", "labels": []}
{"id": 13436, "text": "if export fails", "labels": []}
{"id": 13437, "text": "if the remote object is not currently exported", "labels": []}
{"id": 13438, "text": "if a rowset implementation is unable to to determine whether rows marked for deletion remain visible", "labels": []}
{"id": 13439, "text": "if a rowset implementation is unable to to reset whether deleted rows should be visible", "labels": []}
{"id": 13440, "text": "if this method is called on a closed JdbcRowSet object", "labels": []}
{"id": 13441, "text": "if a database access error occurs or this Connection object within this JdbcRowSet is in auto-commit mode", "labels": []}
{"id": 13442, "text": "if a database access error occurs or this Connection object within this JdbcRowSet is in auto-commit mode.", "labels": []}
{"id": 13443, "text": "if validateContext is null", "labels": []}
{"id": 13444, "text": "if an unexpected exception occurs while validating the signature", "labels": []}
{"id": 13445, "text": "if a parsing error occurs (incorrect form for DN)", "labels": []}
{"id": 13446, "text": "if an encoding error occurs (incorrect form for DN)", "labels": []}
{"id": 13447, "text": "if the OID is invalid, such as the first component being not 0, 1 or 2 or the second component being greater than 39.", "labels": []}
{"id": 13448, "text": "if an encoding error occurs (incorrect form for subject public key)", "labels": []}
{"id": 13449, "text": "if the value is less than -2", "labels": []}
{"id": 13450, "text": "if a parsing error occurs on the OID such as the first component is not 0, 1 or 2 or the second component is greater than 39.", "labels": []}
{"id": 13451, "text": "if an encoding error occurs", "labels": []}
{"id": 13452, "text": "if the day of month indicator is invalid", "labels": []}
{"id": 13453, "text": "if the end of day flag is true when the time is not midnight", "labels": []}
{"id": 13454, "text": "if time.getNano() returns non-zero value", "labels": []}
{"id": 13455, "text": "if the specified compression method is invalid", "labels": []}
{"id": 13456, "text": "if an I/O exception has occurred", "labels": []}
{"id": 13457, "text": "if formats is null", "labels": []}
{"id": 13458, "text": "if formats is unknown", "labels": []}
{"id": 13459, "text": "if baseName or locale is null", "labels": []}
{"id": 13460, "text": "if bundleName, locale, format, or loader is null, or if null is returned by toBundleName", "labels": []}
{"id": 13461, "text": "if format is unknown, or if the resource found for the given parameters contains malformed data.", "labels": []}
{"id": 13462, "text": "if the loaded class cannot be cast to ResourceBundle", "labels": []}
{"id": 13463, "text": "if the class or its nullary constructor is not accessible.", "labels": []}
{"id": 13464, "text": "if the instantiation of a class fails for some other reason.", "labels": []}
{"id": 13465, "text": "If a security manager is present and creation of new instances is denied.", "labels": []}
{"id": 13466, "text": "if an error occurred when reading resources using any I/O operations", "labels": []}
{"id": 13467, "text": "if baseName, locale, format, loader, or bundle is null", "labels": []}
{"id": 13468, "text": "if bundleName or suffix is null", "labels": []}
{"id": 13469, "text": "if style is invalid, or locale isn't one of the locales returned from getAvailableLocales().", "labels": []}
{"id": 13470, "text": "if ID or locale is null", "labels": []}
{"id": 13471, "text": "if url is null.", "labels": []}
{"id": 13472, "text": "if url does not conform to the syntax for an RMI connector, or if its protocol is not recognized by this implementation.", "labels": []}
{"id": 13473, "text": "Only \"rmi\" is valid when this constructor is used.", "labels": []}
{"id": 13474, "text": "if the connector server cannot be created for some reason or if it is inevitable that its start method will fail.", "labels": []}
{"id": 13475, "text": "if the connector server cannot be started.", "labels": []}
{"id": 13476, "text": "if the server cannot be closed cleanly, or if the RMIServerImpl cannot be unbound from the directory.", "labels": []}
{"id": 13477, "text": "When this exception is thrown, the server has already attempted to close all client connections, if appropriate; to call RMIServerImpl.close(); and to unbind the RMIServerImpl from its directory, if appropriate.", "labels": []}
{"id": 13478, "text": "if a security manager exists and its SecurityManager.checkSecurityAccess(java.lang.String) method denies access to add a new provider", "labels": []}
{"id": 13479, "text": "if a security manager exists and its SecurityManager.checkSecurityAccess(java.lang.String) method denies access to remove the provider", "labels": []}
{"id": 13480, "text": "if the filter is not in the required format", "labels": []}
{"id": 13481, "text": "if filter is null", "labels": []}
{"id": 13482, "text": "if a security manager exists and its SecurityManager.checkPermission(java.security.Permission) method denies access to retrieve the specified security property value", "labels": []}
{"id": 13483, "text": "is key is null", "labels": []}
{"id": 13484, "text": "if a security manager exists and its SecurityManager.checkPermission(java.security.Permission) method denies access to set the specified security property value", "labels": []}
{"id": 13485, "text": "if key or datum is null", "labels": []}
{"id": 13486, "text": "if the number of bands requested is not one.", "labels": []}
{"id": 13487, "text": "if w or h is not greater than 0", "labels": []}
{"id": 13488, "text": "if the specified coordinates are not in bounds.", "labels": []}
{"id": 13489, "text": "if the coordinates are not in bounds.", "labels": []}
{"id": 13490, "text": "if obj is not a primitive array of type TransferType or is not null", "labels": []}
{"id": 13491, "text": "if the coordinates are not in bounds, or if obj is not null or not large enough to hold the pixel data", "labels": []}
{"id": 13492, "text": "if the coordinates are not in bounds", "labels": []}
{"id": 13493, "text": "if the attribute is not an instance of interface DocAttribute", "labels": []}
{"id": 13494, "text": "if some element in the specified set is not an instance of interface DocAttribute", "labels": []}
{"id": 13495, "text": "if there are too many listeners", "labels": []}
{"id": 13496, "text": "if the range is non-null and lowerBound is less than zero", "labels": []}
{"id": 13497, "text": "if iv is null or (iv.length < 2 * (wordSize / 8))", "labels": []}
{"id": 13498, "text": "if iv is null or (iv.length - offset < 2 * (wordSize / 8))", "labels": []}
{"id": 13499, "text": "if the server is already started", "labels": []}
{"id": 13500, "text": "if delay is less than zero.", "labels": []}
{"id": 13501, "text": "if path is invalid, or if a context already exists for this path", "labels": []}
{"id": 13502, "text": "if either path, or handler are null", "labels": []}
{"id": 13503, "text": "if path is null", "labels": []}
{"id": 13504, "text": "if this method is called more than once.", "labels": []}
{"id": 13505, "text": "if privateKey or chain is null", "labels": []}
{"id": 13506, "text": "if the specified chain has a length of 0, if the specified chain does not contain Certificates of the same type, or if the PrivateKey algorithm does not match the algorithm of the PublicKey in the end entity Certificate (at index 0)", "labels": []}
{"id": 13507, "text": "if privateKey, chain or attributes is null", "labels": []}
{"id": 13508, "text": "if the parameterIndex is not valid; if a database access error occurs or this method is called on a closed CallableStatement", "labels": []}
{"id": 13509, "text": "if sqlType is a ARRAY, BLOB, CLOB, DATALINK, JAVA_OBJECT, NCHAR, NCLOB, NVARCHAR, LONGNVARCHAR, REF, ROWID, SQLXML or STRUCT data type and the JDBC driver does not support this data type", "labels": []}
{"id": 13510, "text": "if a database access error occurs or this method is called on a closed CallableStatement", "labels": []}
{"id": 13511, "text": "if parameterName does not correspond to a named parameter; if a database access error occurs or this method is called on a closed CallableStatement", "labels": []}
{"id": 13512, "text": "if sqlType is a ARRAY, BLOB, CLOB, DATALINK, JAVA_OBJECT, NCHAR, NCLOB, NVARCHAR, LONGNVARCHAR, REF, ROWID, SQLXML or STRUCT data type and the JDBC driver does not support this data type or if the JDBC driver does not support this method", "labels": []}
{"id": 13513, "text": "if parameterName does not correspond to a named parameter; if a database access error occurs; this method is called on a closed CallableStatement or if a URL is malformed", "labels": []}
{"id": 13514, "text": "if the JDBC driver does not support the specified targetSqlType", "labels": []}
{"id": 13515, "text": "if parameterName does not correspond to a named parameter; if a database access error occurs, this method is called on a closed CallableStatement or if the given Object parameter is ambiguous", "labels": []}
{"id": 13516, "text": "if parameterName does not correspond to a named parameter; if the length specified is less than zero; a database access error occurs or this method is called on a closed CallableStatement", "labels": []}
{"id": 13517, "text": "if parameterName does not correspond to a named parameter; if the length specified is less than zero; if the number of bytes in the InputStream does not match the specified length; if a database access error occurs or this method is called on a closed CallableStatement", "labels": []}
{"id": 13518, "text": "if parameterName does not correspond to a named parameter; if the length specified is less than zero; if the driver does not support national character sets; if the driver can detect that a data conversion error could occur; if a database access error occurs or this method is called on a closed CallableStatement", "labels": []}
{"id": 13519, "text": "if parameterName does not correspond to a named parameter; if a database access error occurs; this method is called on a closed CallableStatement or the java.xml.transform.Result, Writer or OutputStream has not been closed for the SQLXML object", "labels": []}
{"id": 13520, "text": "if parameterName does not correspond to a named parameter; if the driver does not support national character sets; if the driver can detect that a data conversion error could occur; if a database access error occurs; or this method is called on a closed CallableStatement", "labels": []}
{"id": 13521, "text": "if parameterName does not correspond to a named parameter; if the driver does not support national character sets; if the driver can detect that a data conversion error could occur; if a database access error occurs or this method is called on a closed CallableStatement", "labels": []}
{"id": 13522, "text": "if parameterName does not correspond to a named parameter; if a database access error occurs or this method is called on a closed CallableStatement or if the Java Object specified by x is an InputStream or Reader object and the value of the scale parameter is less than zero", "labels": []}
{"id": 13523, "text": "if the JDBC driver does not support the specified sqlType", "labels": []}
{"id": 13524, "text": "if the JDBC driver does not support the specified sqlType or if the JDBC driver does not support this method", "labels": []}
{"id": 13525, "text": "The location in the exception is the first bad position encountered.", "labels": []}
{"id": 13526, "text": "if cd does not represent a GarbaageCollectionNotificationInfo object.", "labels": []}
{"id": 13527, "text": "if the given formats is null", "labels": []}
{"id": 13528, "text": "if the given formats is not \"java.class\" or \"java.properties\".", "labels": []}
{"id": 13529, "text": "if keyChar is null", "labels": []}
{"id": 13530, "text": "if s is null, or is formatted incorrectly", "labels": []}
{"id": 13531, "text": "if a database access error occurs; this method is called on a closed PreparedStatement or the SQL statement returns a ResultSet object", "labels": []}
{"id": 13532, "text": "when the driver has determined that the timeout value that was specified by the setQueryTimeout method has been exceeded and has at least attempted to cancel the currently running Statement", "labels": []}
{"id": 13533, "text": "if parameterIndex does not correspond to a parameter marker in the SQL statement; if a database access error occurs or this method is called on a closed PreparedStatement", "labels": []}
{"id": 13534, "text": "if parameterIndex does not correspond to a parameter marker in the SQL statement; if a database access error occurs; this method is called on a closed PreparedStatement or the type of the given object is ambiguous", "labels": []}
{"id": 13535, "text": "if a database access error occurs; this method is called on a closed PreparedStatement or an argument is supplied to this method", "labels": []}
{"id": 13536, "text": "if a database access error occurs or this method is called on a closed PreparedStatement", "labels": []}
{"id": 13537, "text": "if parameterIndex does not correspond to a parameter marker in the SQL statement; if the driver does not support national character sets; if the driver can detect that a data conversion error could occur; if a database access error occurs; or this method is called on a closed PreparedStatement", "labels": []}
{"id": 13538, "text": "if parameterIndex does not correspond to a parameter marker in the SQL statement; if a database access error occurs; this method is called on a closed PreparedStatement or if the length specified is less than zero.", "labels": []}
{"id": 13539, "text": "if parameterIndex does not correspond to a parameter marker in the SQL statement; if a database access error occurs; this method is called on a closed PreparedStatement; if the length specified is less than zero or if the number of bytes in the InputStream does not match the specified length.", "labels": []}
{"id": 13540, "text": "if parameterIndex does not correspond to a parameter marker in the SQL statement; if the length specified is less than zero; if the driver does not support national character sets; if the driver can detect that a data conversion error could occur; if a database access error occurs or this method is called on a closed PreparedStatement", "labels": []}
{"id": 13541, "text": "if parameterIndex does not correspond to a parameter marker in the SQL statement; if a database access error occurs; this method is called on a closed PreparedStatement or the java.xml.transform.Result, Writer or OutputStream has not been closed for the SQLXML object", "labels": []}
{"id": 13542, "text": "if parameterIndex does not correspond to a parameter marker in the SQL statement; if a database access error occurs; this method is called on a closed PreparedStatement or if the Java Object specified by x is an InputStream or Reader object and the value of the scale parameter is less than zero", "labels": []}
{"id": 13543, "text": "if parameterIndex does not correspond to a parameter marker in the SQL statement; if a database access error occurs; this method is called on a closed PreparedStatementor if parameterIndex does not correspond to a parameter marker in the SQL statement", "labels": []}
{"id": 13544, "text": "if parameterIndex does not correspond to a parameter marker in the SQL statement; if a database access error occurs; this method is called on a closed PreparedStatement or if parameterIndex does not correspond to a parameter marker in the SQL statement,", "labels": []}
{"id": 13545, "text": "if parameterIndex does not correspond to a parameter marker in the SQL statement; if the driver does not support national character sets; if the driver can detect that a data conversion error could occur; if a database access error occurs or this method is called on a closed PreparedStatement", "labels": []}
{"id": 13546, "text": "if parameterIndex does not correspond to a parameter marker in the SQL statement; if a database access error occurs or this method is called on a closed PreparedStatement or if the Java Object specified by x is an InputStream or Reader object and the value of the scale parameter is less than zero", "labels": []}
{"id": 13547, "text": "If no Bindings is defined for the specified scope value in ScriptContexts of this type.", "labels": []}
{"id": 13548, "text": "if value of scope is ENGINE_SCOPE and the specified Bindings is null.", "labels": []}
{"id": 13549, "text": "if the name is empty or if the scope is invalid.", "labels": []}
{"id": 13550, "text": "if mzl is < 1", "labels": []}
{"id": 13551, "text": "if interrupted while waiting, in which case unfinished tasks are cancelled", "labels": []}
{"id": 13552, "text": "if tasks or any of its elements are null", "labels": []}
{"id": 13553, "text": "if any task cannot be scheduled for execution", "labels": []}
{"id": 13554, "text": "if tasks, any of its elements, or unit are null", "labels": []}
{"id": 13555, "text": "if tasks or any element task subject to execution is null", "labels": []}
{"id": 13556, "text": "if tasks is empty", "labels": []}
{"id": 13557, "text": "if no task successfully completes", "labels": []}
{"id": 13558, "text": "if tasks cannot be scheduled for execution", "labels": []}
{"id": 13559, "text": "if tasks, or unit, or any element task subject to execution is null", "labels": []}
{"id": 13560, "text": "if the given timeout elapses before any task successfully completes", "labels": []}
{"id": 13561, "text": "if no rules can be found for the zone", "labels": []}
{"id": 13562, "text": "if no rules are valid for this date-time", "labels": []}
{"id": 13563, "text": "if one of listeners vetoes the property update", "labels": []}
{"id": 13564, "text": "if the field is not supported by the temporal", "labels": []}
{"id": 13565, "text": "if resolving results in an error.", "labels": []}
{"id": 13566, "text": "This must not be thrown by querying a field on the temporal without first checking if it is supported", "labels": []}
{"id": 13567, "text": "if the specified element cannot be compared with the elements currently in this set", "labels": []}
{"id": 13568, "text": "if e cannot be compared with the elements currently in this set", "labels": []}
{"id": 13569, "text": "if o cannot be compared with the elements currently in this set", "labels": []}
{"id": 13570, "text": "if the class of an element of this set is incompatible with the specified collection (optional)", "labels": []}
{"id": 13571, "text": "if key is not String", "labels": []}
{"id": 13572, "text": "if key is empty String", "labels": []}
{"id": 13573, "text": "if the path string cannot be converted to a Path", "labels": []}
{"id": 13574, "text": "If an encoding operation is already in progress and the previous step was an invocation neither of the reset method, nor of this method with a value of false for the endOfInput parameter, nor of this method with a value of true for the endOfInput parameter but a return value indicating an incomplete encoding operation", "labels": []}
{"id": 13575, "text": "If an invocation of the encodeLoop method threw an unexpected exception", "labels": []}
{"id": 13576, "text": "If the previous step of the current encoding operation was an invocation neither of the flush method nor of the three-argument encode method with a value of true for the endOfInput parameter", "labels": []}
{"id": 13577, "text": "If an encoding operation is already in progress", "labels": []}
{"id": 13578, "text": "If the character sequence starting at the input buffer's current position is not a legal sixteen-bit Unicode sequence and the current malformed-input action is CodingErrorAction.REPORT", "labels": []}
{"id": 13579, "text": "If the character sequence starting at the input buffer's current position cannot be mapped to an equivalent byte sequence and the current unmappable-character action is CodingErrorAction.REPORT", "labels": []}
{"id": 13580, "text": "if aContainer is not a focus cycle root of aComponent or focus traversal policy provider, or if either aContainer or aComponent is null", "labels": []}
{"id": 13581, "text": "if aContainer is null", "labels": []}
{"id": 13582, "text": "if the stream header is incorrect", "labels": []}
{"id": 13583, "text": "if an I/O error occurs while reading stream header", "labels": []}
{"id": 13584, "text": "if in is null", "labels": []}
{"id": 13585, "text": "Primitive data was found in the stream instead of objects.", "labels": []}
{"id": 13586, "text": "Any of the usual Input/Output related exceptions.", "labels": []}
{"id": 13587, "text": "if class of an object to deserialize cannot be found", "labels": []}
{"id": 13588, "text": "if control information in the stream is inconsistent", "labels": []}
{"id": 13589, "text": "if object to deserialize has already appeared in stream", "labels": []}
{"id": 13590, "text": "if primitive data is next in stream", "labels": []}
{"id": 13591, "text": "if an I/O error occurs during deserialization", "labels": []}
{"id": 13592, "text": "if the class of a serialized object could not be found.", "labels": []}
{"id": 13593, "text": "if the stream is not currently reading objects.", "labels": []}
{"id": 13594, "text": "The validation object is null.", "labels": []}
{"id": 13595, "text": "any of the usual Input/Output exceptions.", "labels": []}
{"id": 13596, "text": "if class of a serialized object cannot be found.", "labels": []}
{"id": 13597, "text": "any exception thrown by the underlying InputStream", "labels": []}
{"id": 13598, "text": "if the proxy class or any of the named interfaces could not be found", "labels": []}
{"id": 13599, "text": "Any of the usual Input/Output exceptions.", "labels": []}
{"id": 13600, "text": "if a security manager exists and its checkPermission method denies enabling the stream to do replacement of objects read from the stream.", "labels": []}
{"id": 13601, "text": "If the Class of a serialized object used in the class descriptor representation cannot be found", "labels": []}
{"id": 13602, "text": "if the current filter is not null and is not the process-wide filter", "labels": []}
{"id": 13603, "text": "if the current thread is interrupted by another thread while it is waiting, then the wait is ended and an InterruptedException is thrown.", "labels": []}
{"id": 13604, "text": "if the current thread is interrupted while waiting.", "labels": []}
{"id": 13605, "text": "if unit is null", "labels": []}
{"id": 13606, "text": "if the Process implementation does not support this operation", "labels": []}
{"id": 13607, "text": "if a security manager has been installed and it denies RuntimePermission(\"manageProcess\")", "labels": []}
{"id": 13608, "text": "if the connection is not open", "labels": []}
{"id": 13609, "text": "if an argument is null and this comparator does not permit null arguments", "labels": []}
{"id": 13610, "text": "if the arguments' types prevent them from being compared by this comparator.", "labels": []}
{"id": 13611, "text": "if before is null", "labels": []}
{"id": 13612, "text": "if any task is null", "labels": []}
{"id": 13613, "text": "if tasks or any element are null", "labels": []}
{"id": 13614, "text": "if the current thread is not a member of a ForkJoinPool and was interrupted while waiting", "labels": []}
{"id": 13615, "text": "if getting the JAR file for this connection causes an IOException to be thrown.", "labels": []}
{"id": 13616, "text": "if getting the JAR entry causes an IOException to be thrown.", "labels": []}
{"id": 13617, "text": "if the specified listenertype parameter is null", "labels": []}
{"id": 13618, "text": "if the field is not valid for this object's class.", "labels": []}
{"id": 13619, "text": "if any field is not valid for this object's class.", "labels": []}
{"id": 13620, "text": "if the value's type does not match the field's type.", "labels": []}
{"id": 13621, "text": "if 'value' is not null, and the field type has not yet been loaded through the appropriate class loader.", "labels": []}
{"id": 13622, "text": "if the method is not a member of this object's class, if the size of the argument list does not match the number of declared arguments for the method, if the method is a constructor or static initializer, or if INVOKE_NONVIRTUAL is specified and the method is abstract.", "labels": []}
{"id": 13623, "text": "This implies that the argument type must be loaded through the enclosing class's class loader.", "labels": []}
{"id": 13624, "text": "if the VirtualMachine is read-only -see VirtualMachine.canBeModified().", "labels": []}
{"id": 13625, "text": "if the target VM does not support this operation.", "labels": []}
{"id": 13626, "text": "if any waiting thread is not suspended in the target VM", "labels": []}
{"id": 13627, "text": "if the owning thread is not suspended in the target VM", "labels": []}
{"id": 13628, "text": "if the target virtual machine does not support this operation - see canGetInstanceInfo()", "labels": []}
{"id": 13629, "text": "if maxReferrers is less than zero.", "labels": []}
{"id": 13630, "text": "if the stub for the remote object could not be found.", "labels": []}
{"id": 13631, "text": "if icm is null", "labels": []}
{"id": 13632, "text": "If either the input or reason strings are null", "labels": []}
{"id": 13633, "text": "If the error index is less than -1", "labels": []}
{"id": 13634, "text": "if the SSLContext.getInstance() call fails", "labels": []}
{"id": 13635, "text": "if context is null", "labels": []}
{"id": 13636, "text": "if a security manager exists and its checkPermission method does not allow SSLPermission(\"setDefaultSSLContext\")", "labels": []}
{"id": 13637, "text": "if no Provider supports a SSLContextSpi implementation for the specified protocol", "labels": []}
{"id": 13638, "text": "if a SSLContextSpi implementation for the specified protocol is not available from the specified provider", "labels": []}
{"id": 13639, "text": "if a SSLContextSpi implementation for the specified protocol is not available from the specified Provider object", "labels": []}
{"id": 13640, "text": "if this operation fails", "labels": []}
{"id": 13641, "text": "if the SSLContextImpl requires initialization and the init() has not been called", "labels": []}
{"id": 13642, "text": "if the default SSL parameters could not be obtained.", "labels": []}
{"id": 13643, "text": "if the supported SSL parameters could not be obtained.", "labels": []}
{"id": 13644, "text": "if no Provider supports a TrustManagerFactorySpi implementation for the specified algorithm", "labels": []}
{"id": 13645, "text": "if a TrustManagerFactorySpi implementation for the specified algorithm is not available from the specified provider", "labels": []}
{"id": 13646, "text": "if a TrustManagerFactorySpi implementation for the specified algorithm is not available from the specified Provider object", "labels": []}
{"id": 13647, "text": "if the name constraints cannot be decoded", "labels": []}
{"id": 13648, "text": "if the specified X509Certificate is null", "labels": []}
{"id": 13649, "text": "if the specified caPrincipal or pubKey parameter is null", "labels": []}
{"id": 13650, "text": "if the specified caName parameter is empty (caName.length() == 0) or incorrectly formatted or the name constraints cannot be decoded", "labels": []}
{"id": 13651, "text": "if the specified caName or pubKey parameter is null", "labels": []}
{"id": 13652, "text": "for networking errors", "labels": []}
{"id": 13653, "text": "if theEvent is null", "labels": []}
{"id": 13654, "text": "if no previous push was made on this EventQueue", "labels": []}
{"id": 13655, "text": "if any thread has interrupted this thread", "labels": []}
{"id": 13656, "text": "if an throwable is thrown when running runnable", "labels": []}
{"id": 13657, "text": "if cd does not represent a valid EventTypeInfo", "labels": []}
{"id": 13658, "text": "INVALID_STATE_ERR: Raised if this method is called after the detach method was invoked.", "labels": []}
{"id": 13659, "text": "if an I/O error occurs while reading the object.", "labels": []}
{"id": 13660, "text": "if the proxy is of an invalid type or null.", "labels": []}
{"id": 13661, "text": "if a security manager is present and permission to connect to the proxy is denied.", "labels": []}
{"id": 13662, "text": "if the IP address of the host could not be determined.", "labels": []}
{"id": 13663, "text": "if an I/O error occurs when creating the socket.", "labels": []}
{"id": 13664, "text": "if a security manager exists and its checkConnect method doesn't allow the connection to the destination, or if its checkListen method doesn't allow the bind to the local port.", "labels": []}
{"id": 13665, "text": "if the port parameter or localPort parameter is outside the specified range of valid port values, which is between 0 and 65535, inclusive.", "labels": []}
{"id": 13666, "text": "if an error occurs during the connection", "labels": []}
{"id": 13667, "text": "if timeout expires before connecting", "labels": []}
{"id": 13668, "text": "if this socket has an associated channel, and the channel is in non-blocking mode", "labels": []}
{"id": 13669, "text": "if endpoint is null or is a SocketAddress subclass not supported by this socket", "labels": []}
{"id": 13670, "text": "if the bind operation fails, or if the socket is already bound.", "labels": []}
{"id": 13671, "text": "if bindpoint is a SocketAddress subclass not supported by this socket", "labels": []}
{"id": 13672, "text": "if a security manager exists and its checkListen method doesn't allow the bind to the local port.", "labels": []}
{"id": 13673, "text": "if an I/O error occurs when creating the input stream, the socket is closed, the socket is not connected, or the socket input has been shutdown using shutdownInput()", "labels": []}
{"id": 13674, "text": "if an I/O error occurs when creating the output stream or if the socket is not connected.", "labels": []}
{"id": 13675, "text": "if there is an error in the underlying protocol, such as a TCP error.", "labels": []}
{"id": 13676, "text": "if the linger value is negative.", "labels": []}
{"id": 13677, "text": "if there is an error sending the data.", "labels": []}
{"id": 13678, "text": "if an I/O error occurs when closing this socket.", "labels": []}
{"id": 13679, "text": "if an I/O error occurs when setting the socket factory.", "labels": []}
{"id": 13680, "text": "if a bad location is encountered", "labels": []}
{"id": 13681, "text": "if width or height are less than zero.", "labels": []}
{"id": 13682, "text": "if there was a problem calling the filter method of the BufferedImageOp associated with this instance.", "labels": []}
{"id": 13683, "text": "if an unknown orientation was requested", "labels": []}
{"id": 13684, "text": "if there is a communication exception during the remote method call.", "labels": []}
{"id": 13685, "text": "if this deque is full", "labels": []}
{"id": 13686, "text": "if the current thread is not allowed to create or start the thread.", "labels": []}
{"id": 13687, "text": "if the thread from the thread factory was not a new thread.", "labels": []}
{"id": 13688, "text": "if source equals null", "labels": []}
{"id": 13689, "text": "if source equals null or if cause equals null", "labels": []}
{"id": 13690, "text": "If the channel group is shutdown", "labels": []}
{"id": 13691, "text": "If this channel is not yet connected", "labels": []}
{"id": 13692, "text": "If a connection operation is already in progress on this channel", "labels": []}
{"id": 13693, "text": "If the channel group has terminated", "labels": []}
{"id": 13694, "text": "If a security manager has been installed and it does not permit access to the given remote endpoint", "labels": []}
{"id": 13695, "text": "If the buffer is read-only", "labels": []}
{"id": 13696, "text": "If a read operation is already in progress on this channel", "labels": []}
{"id": 13697, "text": "If the pre-conditions for the offset and length parameter aren't met", "labels": []}
{"id": 13698, "text": "If a write operation is already in progress on this channel", "labels": []}
{"id": 13699, "text": "if the read method is invalid", "labels": []}
{"id": 13700, "text": "if the write method is invalid", "labels": []}
{"id": 13701, "text": "If an I/O error occurs or the module reader is closed", "labels": []}
{"id": 13702, "text": "If the resource is larger than Integer.MAX_VALUE, the maximum capacity of a byte buffer", "labels": []}
{"id": 13703, "text": "if prompt is null or if prompt has a length of 0.", "labels": []}
{"id": 13704, "text": "if an I/O exception occurs during reading of the stream", "labels": []}
{"id": 13705, "text": "if the stream's audio format is not fully specified or invalid", "labels": []}
{"id": 13706, "text": "if the requested loop points cannot be set, usually because one or both falls outside the media's duration or because the ending point is before the starting point", "labels": []}
{"id": 13707, "text": "if column is not valid", "labels": []}
{"id": 13708, "text": "if systemColors is null; or systemColors is not empty, and table is null; or one of the names of the name-color pairs is null; or useNative is false and one of the colors of the name-color pairs is null", "labels": []}
{"id": 13709, "text": "if useNative is false and systemColors.length is odd", "labels": []}
{"id": 13710, "text": "if the value of the default \"AuditoryCues.actionMap\" is not an ActionMap, or the value of the default \"AuditoryCues.cueList\" is not an Object[]", "labels": []}
{"id": 13711, "text": "if audioAction is non-null and the value of the default \"AuditoryCues.playList\" is not an Object[]", "labels": []}
{"id": 13712, "text": "If source is not in the module layer", "labels": []}
{"id": 13713, "text": "If source is not in the module layer or the package is not in the source module", "labels": []}
{"id": 13714, "text": "if acquiring would place this synchronizer in an illegal state.", "labels": []}
{"id": 13715, "text": "This exception must be thrown in a consistent fashion for synchronization to work correctly.", "labels": []}
{"id": 13716, "text": "if exclusive mode is not supported", "labels": []}
{"id": 13717, "text": "if releasing would place this synchronizer in an illegal state.", "labels": []}
{"id": 13718, "text": "if shared mode is not supported", "labels": []}
{"id": 13719, "text": "if conditions are not supported", "labels": []}
{"id": 13720, "text": "if the thread is null", "labels": []}
{"id": 13721, "text": "if the condition is null", "labels": []}
{"id": 13722, "text": "if exclusive synchronization is not held", "labels": []}
{"id": 13723, "text": "if the given condition is not associated with this synchronizer", "labels": []}
{"id": 13724, "text": "if this layout has already been justified, an Error is thrown.", "labels": []}
{"id": 13725, "text": "if the hit is not valid for the TextLayout.", "labels": []}
{"id": 13726, "text": "if hit or point is null.", "labels": []}
{"id": 13727, "text": "if no role info with that name in relation type.", "labels": []}
{"id": 13728, "text": "if null parameter.", "labels": []}
{"id": 13729, "text": "if there is already a role info in current relation type with the same name.", "labels": []}
{"id": 13730, "text": "if the document charset was changed", "labels": []}
{"id": 13731, "text": "if flatness or limit is less than zero", "labels": []}
{"id": 13732, "text": "if there are no more elements in the flattening path to be returned.", "labels": []}
{"id": 13733, "text": "if extraMetadataFormatNames has length 0.", "labels": []}
{"id": 13734, "text": "if extraMetadataFormatNames and extraMetadataFormatClassNames are neither both null, nor of the same length.", "labels": []}
{"id": 13735, "text": "if formatName is null or is not one of the names recognized by the plug-in.", "labels": []}
{"id": 13736, "text": "if the class corresponding to the format name cannot be loaded.", "labels": []}
{"id": 13737, "text": "if this object is read-only.", "labels": []}
{"id": 13738, "text": "if formatName is null or is not one of the names returned by getMetadataFormatNames.", "labels": []}
{"id": 13739, "text": "if root is null.", "labels": []}
{"id": 13740, "text": "if the tree cannot be parsed successfully using the rules of the given format.", "labels": []}
{"id": 13741, "text": "if there is no controller currently installed.", "labels": []}
{"id": 13742, "text": "if interfaceClass is not a compliant MBean interface", "labels": []}
{"id": 13743, "text": "if interfaceClass is not a compliant MXBean interface", "labels": []}
{"id": 13744, "text": "if interfaceClass is null.", "labels": []}
{"id": 13745, "text": "if mechanismType is null", "labels": []}
{"id": 13746, "text": "if no Provider supports a KeyInfoFactory implementation for the specified mechanism", "labels": []}
{"id": 13747, "text": "if mechanismType or provider are null", "labels": []}
{"id": 13748, "text": "if a KeyInfoFactory implementation for the specified mechanism is not available from the specified Provider object", "labels": []}
{"id": 13749, "text": "if a KeyInfoFactory implementation for the specified mechanism is not available from the specified provider", "labels": []}
{"id": 13750, "text": "if no Provider supports a KeyInfoFactory implementation for the DOM mechanism", "labels": []}
{"id": 13751, "text": "if feature is null", "labels": []}
{"id": 13752, "text": "if setting an Authenticator is not supported by the underlying implementation.", "labels": []}
{"id": 13753, "text": "if URLConnection is already connected.", "labels": []}
{"id": 13754, "text": "if the supplied auth is null.", "labels": []}
{"id": 13755, "text": "if URLConnection is already connected or if a different streaming mode is already enabled.", "labels": []}
{"id": 13756, "text": "if a content length less than zero is specified.", "labels": []}
{"id": 13757, "text": "if an error occurred connecting to the server.", "labels": []}
{"id": 13758, "text": "if one of the parts is syntactically incorrect, or if host is null and it is not possible to find the local host name, or if port is negative.", "labels": []}
{"id": 13759, "text": "if newOrientation is an illegal value", "labels": []}
{"id": 13760, "text": "When the supplied name does not identify an attribute.", "labels": []}
{"id": 13761, "text": "When the supplied names do not identify an attribute.", "labels": []}
{"id": 13762, "text": "if preconditions on the uri parameter do not hold.", "labels": []}
{"id": 13763, "text": "if a security manager is installed and it denies an unspecified permission to access the file system", "labels": []}
{"id": 13764, "text": "If the path string cannot be converted to a Path.", "labels": []}
{"id": 13765, "text": "if other is not a Path that can be relativized against this path", "labels": []}
{"id": 13766, "text": "if an I/O error occurs obtaining the absolute path, or where a file system is constructed to access the contents of a file as a file system, and the URI of the enclosing file system cannot be obtained", "labels": []}
{"id": 13767, "text": "In the case of the default provider, and a security manager is installed, the toAbsolutePath method throws a security exception.", "labels": []}
{"id": 13768, "text": "if the file does not exist or an I/O error occurs", "labels": []}
{"id": 13769, "text": "if this Path is not associated with the default provider", "labels": []}
{"id": 13770, "text": "if an invalid combination of events or modifiers is specified", "labels": []}
{"id": 13771, "text": "if the file is registered to watch the entries in a directory and the file is not a directory (optional specific exception)", "labels": []}
{"id": 13772, "text": "if the Blob passed to this to this constructor is a null.", "labels": []}
{"id": 13773, "text": "if the given starting position is out of bounds; if free had previously been called on this object", "labels": []}
{"id": 13774, "text": "if there is an error accessing the BLOB value", "labels": []}
{"id": 13775, "text": "if the SerialBlob in not instantiated with a Blob object that supports setBinaryStream(); if free had previously been called on this object", "labels": []}
{"id": 13776, "text": "if the current version is not known or the desired or current version is not of the correct dotted form.", "labels": []}
{"id": 13777, "text": "if array length is not at least the number of components in this ColorSpace", "labels": []}
{"id": 13778, "text": "if array length is not at least 3", "labels": []}
{"id": 13779, "text": "if array length is not at least the number of components in this ColorSpace.", "labels": []}
{"id": 13780, "text": "if component is less than 0 or greater than numComponents - 1", "labels": []}
{"id": 13781, "text": "if a security manager exists and the caller does not have ManagementPermission(\"monitor\").", "labels": []}
{"id": 13782, "text": "if id <= 0.", "labels": []}
{"id": 13783, "text": "if any element in the input array ids is <= 0.", "labels": []}
{"id": 13784, "text": "if maxDepth is negative.", "labels": []}
{"id": 13785, "text": "if the Java virtual machine does not support thread contention monitoring.", "labels": []}
{"id": 13786, "text": "if the Java virtual machine does not support CPU time measurement for the current thread.", "labels": []}
{"id": 13787, "text": "if the Java virtual machine does not support CPU time measurement for other threads.", "labels": []}
{"id": 13788, "text": "if the Java virtual machine does not support CPU time measurement for other threads nor for the current thread.", "labels": []}
{"id": 13789, "text": "if the Java virtual machine does not support monitoring of ownable synchronizer usage.", "labels": []}
{"id": 13790, "text": "if lockedMonitors is true but the Java virtual machine does not support monitoring of object monitor usage; or if lockedSynchronizers is true but the Java virtual machine does not support monitoring of ownable synchronizer usage.", "labels": []}
{"id": 13791, "text": "If this selector is closed", "labels": []}
{"id": 13792, "text": "If the value of the timeout argument is negative", "labels": []}
{"id": 13793, "text": "If this selector is closed or is closed by the action", "labels": []}
{"id": 13794, "text": "if cd does not represent a ConfigurationInfo with the required attributes", "labels": []}
{"id": 13795, "text": "if the calling thread does not have permission to replace the current KeyboardFocusManager", "labels": []}
{"id": 13796, "text": "if this KeyboardFocusManager is not the current KeyboardFocusManager for the calling thread's context and if the calling thread does not have \"replaceKeyboardFocusManager\" permission", "labels": []}
{"id": 13797, "text": "if the calling thread does not have \"replaceKeyboardFocusManager\" permission", "labels": []}
{"id": 13798, "text": "if defaultPolicy is null", "labels": []}
{"id": 13799, "text": "if id is not one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS, or if keystrokes is null, or if keystrokes contains null, or if any keystroke represents a KEY_TYPED event, or if any keystroke already maps to another default focus traversal operation", "labels": []}
{"id": 13800, "text": "if a VetoableChangeListener threw PropertyVetoException", "labels": []}
{"id": 13801, "text": "if the result overflows an int", "labels": []}
{"id": 13802, "text": "if the result overflows a long", "labels": []}
{"id": 13803, "text": "if the argument overflows an int", "labels": []}
{"id": 13804, "text": "if the divisor y is zero", "labels": []}
{"id": 13805, "text": "If this method is called from other ContentHandler methods.", "labels": []}
{"id": 13806, "text": "If the index is invalid.", "labels": []}
{"id": 13807, "text": "if obj is not a CompoundName.", "labels": []}
{"id": 13808, "text": "If posn is outside the specified range.", "labels": []}
{"id": 13809, "text": "If n is not a compound name, or if the addition of the components violates the syntax of this compound name (e.g.", "labels": []}
{"id": 13810, "text": "If adding comp at the specified position would violate the compound name's syntax.", "labels": []}
{"id": 13811, "text": "if this ticket is destroyed", "labels": []}
{"id": 13812, "text": "if the ticket is not renewable, or the latest allowable renew time has passed, or the KDC returns some error.", "labels": []}
{"id": 13813, "text": "If the connection is closed, or another thread closes the connection while the readPacket is in progress.", "labels": []}
{"id": 13814, "text": "If the length of the packet (as indictaed by the first 4 bytes) is less than 11 bytes, or an I/O error occurs.", "labels": []}
{"id": 13815, "text": "If the connection is closed, or another thread closes the connection while the write operation is in progress.", "labels": []}
{"id": 13816, "text": "If the value of the length field is invalid, or the byte array is of insufficient length.", "labels": []}
{"id": 13817, "text": "if out is null and this value is used in the method", "labels": []}
{"id": 13818, "text": "if the pipe is broken, unconnected, closed or an I/O error occurs.", "labels": []}
{"id": 13819, "text": "If off is negative, or len is negative, or off + len is negative or greater than the length of the given array", "labels": []}
{"id": 13820, "text": "if a configuration argument is not supported.", "labels": []}
{"id": 13821, "text": "if the supplied configuration argument is null.", "labels": []}
{"id": 13822, "text": "if the supplied configuration argument is invalid.", "labels": []}
{"id": 13823, "text": "if a security manager exists and its SecurityManager.checkSecurityAccess(java.lang.String) method denies access to clear this provider", "labels": []}
{"id": 13824, "text": "if a security manager exists and its SecurityManager.checkSecurityAccess(java.lang.String) method denies access to set property values.", "labels": []}
{"id": 13825, "text": "if a security manager exists and its SecurityManager.checkSecurityAccess(java.lang.String) method denies access to remove this provider's properties.", "labels": []}
{"id": 13826, "text": "if a security manager exists and its SecurityManager.checkSecurityAccess(java.lang.String) method denies access to set property values or remove properties.", "labels": []}
{"id": 13827, "text": "if a security manager exists and its SecurityManager.checkSecurityAccess(java.lang.String) method denies access to set property values and remove properties.", "labels": []}
{"id": 13828, "text": "if type or algorithm is null", "labels": []}
{"id": 13829, "text": "if the source name is not known", "labels": []}
{"id": 13830, "text": "if the attribute is not an instance of interface PrintJobAttribute", "labels": []}
{"id": 13831, "text": "if some element in the specified set is not an instance of interface PrintJobAttribute", "labels": []}
{"id": 13832, "text": "if the JShell instance is closed.", "labels": []}
{"id": 13833, "text": "if the value of both rows and cols is set to zero", "labels": []}
{"id": 13834, "text": "containing the following major error codes: GSSException.BAD_MECH GSSException.FAILURE", "labels": []}
{"id": 13835, "text": "containing the following major error codes: GSSException.BAD_NAMETYPE, GSSException.BAD_NAME, GSSException.BAD_MECH, GSSException.FAILURE", "labels": []}
{"id": 13836, "text": "containing the following major error codes: GSSException.BAD_MECH, GSSException.BAD_NAMETYPE, GSSException.BAD_NAME, GSSException.CREDENTIALS_EXPIRED, GSSException.NO_CRED, GSSException.FAILURE", "labels": []}
{"id": 13837, "text": "containing the following major error codes: GSSException.NO_CRED GSSException.CREDENTIALS_EXPIRED GSSException.BAD_NAMETYPE GSSException.BAD_MECH GSSException.FAILURE", "labels": []}
{"id": 13838, "text": "containing the following major error codes: GSSException.NO_CRED GSSException.CREDENTIALS_EXPIRED GSSException.BAD_MECH GSSException.FAILURE", "labels": []}
{"id": 13839, "text": "containing the following major error codes: GSSException.NO_CONTEXT, GSSException.DEFECTIVE_TOKEN, GSSException.UNAVAILABLE, GSSException.UNAUTHORIZED, GSSException.FAILURE", "labels": []}
{"id": 13840, "text": "containing the following major error codes: GSSException.UNAVAILABLE, GSSException.FAILURE", "labels": []}
{"id": 13841, "text": "if the stream does not point to valid audio file data recognized by the system", "labels": []}
{"id": 13842, "text": "if stream is null", "labels": []}
{"id": 13843, "text": "if the URL does not point to valid audio file data recognized by the system", "labels": []}
{"id": 13844, "text": "if url is null", "labels": []}
{"id": 13845, "text": "if the File does not point to valid audio file data recognized by the system", "labels": []}
{"id": 13846, "text": "if file is null", "labels": []}
{"id": 13847, "text": "if algorithm or mechanismType is null", "labels": []}
{"id": 13848, "text": "if no Provider supports a TransformService implementation for the specified algorithm and mechanism type", "labels": []}
{"id": 13849, "text": "if provider, algorithm, or mechanismType is null", "labels": []}
{"id": 13850, "text": "if a TransformService implementation for the specified algorithm and mechanism type is not available from the specified Provider object", "labels": []}
{"id": 13851, "text": "if provider, mechanismType, or algorithm is null", "labels": []}
{"id": 13852, "text": "if a TransformService implementation for the specified algorithm and mechanism type is not available from the specified provider", "labels": []}
{"id": 13853, "text": "if the specified parameters are invalid for this algorithm", "labels": []}
{"id": 13854, "text": "if the type of parent or context is not compatible with this TransformService", "labels": []}
{"id": 13855, "text": "if parent is null", "labels": []}
{"id": 13856, "text": "if the parameters cannot be marshalled", "labels": []}
{"id": 13857, "text": "if button is less than zero", "labels": []}
{"id": 13858, "text": "if button is greater than BUTTON3 and the support for extended mouse buttons is disabled by Java", "labels": []}
{"id": 13859, "text": "if button is greater than the current number of buttons and the support for extended mouse buttons is enabled by Java", "labels": []}
{"id": 13860, "text": "if an invalid button value is passed in", "labels": []}
{"id": 13861, "text": "If a security manager has been installed and it denies AttachPermission (\"attachVirtualMachine\"), or another permission required by the implementation.", "labels": []}
{"id": 13862, "text": "If the attachVirtualmachine method of all installed providers throws AttachNotSupportedException, or there aren't any providers installed.", "labels": []}
{"id": 13863, "text": "If id is null.", "labels": []}
{"id": 13864, "text": "If the agent library does not exist, the agent library is not statically linked with the VM, or the agent library cannot be loaded for another reason.", "labels": []}
{"id": 13865, "text": "If the Agent_OnAttach[_L] function returns an error.", "labels": []}
{"id": 13866, "text": "If agentLibrary is null.", "labels": []}
{"id": 13867, "text": "If agentPath is null.", "labels": []}
{"id": 13868, "text": "If the agent does not exist, or cannot be started in the manner specified in the java.lang.instrument specification.", "labels": []}
{"id": 13869, "text": "If the agentmain throws an exception", "labels": []}
{"id": 13870, "text": "If agent is null.", "labels": []}
{"id": 13871, "text": "If the target virtual machine is unable to complete the attach operation.", "labels": []}
{"id": 13872, "text": "A more specific error message will be given by Throwable.getMessage().", "labels": []}
{"id": 13873, "text": "If an I/O error occurs, a communication error for example, that cannot be identified as an error to indicate that the operation failed in the target VM.", "labels": []}
{"id": 13874, "text": "If keys or values in agentProperties are invalid.", "labels": []}
{"id": 13875, "text": "If agentProperties is null.", "labels": []}
{"id": 13876, "text": "if stream contains a malformed Unicode escape sequence.", "labels": []}
{"id": 13877, "text": "if the system property java.util.PropertyResourceBundle.encoding is set to \"UTF-8\" and stream contains an invalid UTF-8 byte sequence.", "labels": []}
{"id": 13878, "text": "if the system property java.util.PropertyResourceBundle.encoding is set to \"UTF-8\" and stream contains an unmappable UTF-8 byte sequence.", "labels": []}
{"id": 13879, "text": "Wraps an IllegalArgumentException The attribute name passed in parameter does not exist.", "labels": []}
{"id": 13880, "text": "if the given position does not represent a valid location in the associated document", "labels": []}
{"id": 13881, "text": "If a non-blocking connection operation is already in progress on this channel", "labels": []}
{"id": 13882, "text": "If this channel is not connected and a connection operation has not been initiated", "labels": []}
{"id": 13883, "text": "if the algorithm for recovering the key cannot be found", "labels": []}
{"id": 13884, "text": "if the key cannot be recovered (e.g., the given password is wrong).", "labels": []}
{"id": 13885, "text": "if the given key cannot be protected, or this operation fails for some other reason", "labels": []}
{"id": 13886, "text": "if this operation fails.", "labels": []}
{"id": 13887, "text": "if the given alias already exists and does not identify an entry containing a trusted certificate, or this operation fails for some other reason.", "labels": []}
{"id": 13888, "text": "if there is an I/O or format problem with the keystore data, if a password is required but not given, or if the given password was incorrect.", "labels": []}
{"id": 13889, "text": "If the error is due to a wrong password, the cause of the IOException should be an UnrecoverableKeyException", "labels": []}
{"id": 13890, "text": "if the algorithm used to check the integrity of the keystore cannot be found", "labels": []}
{"id": 13891, "text": "if any of the certificates in the keystore could not be loaded", "labels": []}
{"id": 13892, "text": "if the given KeyStore.LoadStoreParameter input is not recognized", "labels": []}
{"id": 13893, "text": "if there is an I/O or format problem with the keystore data.", "labels": []}
{"id": 13894, "text": "If the error is due to an incorrect ProtectionParameter (e.g.", "labels": []}
{"id": 13895, "text": "wrong password) the cause of the IOException should be an UnrecoverableKeyException", "labels": []}
{"id": 13896, "text": "if there is an I/O problem with the keystore data.", "labels": []}
{"id": 13897, "text": "If a naming exception was encountered while retrieving the values.", "labels": []}
{"id": 13898, "text": "If a naming exception was encountered while retrieving the value.", "labels": []}
{"id": 13899, "text": "If this attribute has no values.", "labels": []}
{"id": 13900, "text": "If ix is outside the specified range.", "labels": []}
{"id": 13901, "text": "If the attribute values are unordered and attrVal is one of those values.", "labels": []}
{"id": 13902, "text": "If attrVal already exists and the attribute values are unordered.", "labels": []}
{"id": 13903, "text": "if the key is destroyed", "labels": []}
{"id": 13904, "text": "if the pre-conditions for the uri parameter are not met", "labels": []}
{"id": 13905, "text": "if the file system, identified by the URI, does not exist", "labels": []}
{"id": 13906, "text": "if a provider supporting the URI scheme is not installed", "labels": []}
{"id": 13907, "text": "if a security manager is installed and it denies an unspecified permission", "labels": []}
{"id": 13908, "text": "if the pre-conditions for the uri parameter are not met, or the env parameter does not contain properties required by the provider, or a property value is invalid", "labels": []}
{"id": 13909, "text": "if the file system has already been created", "labels": []}
{"id": 13910, "text": "if an I/O error occurs creating the file system", "labels": []}
{"id": 13911, "text": "if a security manager is installed and it denies an unspecified permission required by the file system provider implementation", "labels": []}
{"id": 13912, "text": "if the URI scheme identifies an installed provider and the file system has already been created", "labels": []}
{"id": 13913, "text": "if a provider supporting the URI scheme is not found", "labels": []}
{"id": 13914, "text": "when an error occurs while loading a service provider", "labels": []}
{"id": 13915, "text": "an I/O error occurs creating the file system", "labels": []}
{"id": 13916, "text": "if a provider supporting this file type cannot be located", "labels": []}
{"id": 13917, "text": "INVALID_EXPRESSION_ERR: Raised if the expression is not legal according to the rules of the XPathEvaluatori", "labels": []}
{"id": 13918, "text": "NAMESPACE_ERR: Raised if the expression contains namespace prefixes which cannot be resolved by the specified XPathNSResolver.", "labels": []}
{"id": 13919, "text": "INVALID_EXPRESSION_ERR: Raised if the expression is not legal according to the rules of the XPathEvaluatori TYPE_ERR: Raised if the result cannot be converted to return the specified type.", "labels": []}
{"id": 13920, "text": "This exception will be caught by the MBean Server and re-thrown as an MBeanRegistrationException.", "labels": []}
{"id": 13921, "text": "if no Provider supports an AlgorithmParameterGeneratorSpi implementation for the specified algorithm", "labels": []}
{"id": 13922, "text": "if an AlgorithmParameterGeneratorSpi implementation for the specified algorithm is not available from the specified provider", "labels": []}
{"id": 13923, "text": "if an AlgorithmParameterGeneratorSpi implementation for the specified algorithm is not available from the specified Provider object", "labels": []}
{"id": 13924, "text": "if the given parameter generation values are inappropriate for this parameter generator.", "labels": []}
{"id": 13925, "text": "If buf is null.", "labels": []}
{"id": 13926, "text": "If off is negative, len is negative, or len is greater than buf.length - off", "labels": []}
{"id": 13927, "text": "if AbstractQueuedSynchronizer.isHeldExclusively() returns false", "labels": []}
{"id": 13928, "text": "if the stream has not been marked or if the mark has been invalidated.", "labels": []}
{"id": 13929, "text": "if (1) an empty rowset is added to the to this JoinRowSet object, (2) a match column has not been set for rowset, or (3) rowset violates the active JOIN", "labels": []}
{"id": 13930, "text": "if (1) rowset is an empty rowset or (2) rowset violates the active JOIN", "labels": []}
{"id": 13931, "text": "if (1) rowset is an empty rowset or (2) the match column for rowset does not satisfy the conditions of the JOIN", "labels": []}
{"id": 13932, "text": "if (1) an empty rowset is added to this JoinRowSet object, (2) a match column is not set for a RowSet object in rowset, or (3) a RowSet object being added violates the active JOIN", "labels": []}
{"id": 13933, "text": "if an error occurs generating the Collection object to be returned", "labels": []}
{"id": 13934, "text": "if an error occurs assembling the CachedRowSet object", "labels": []}
{"id": 13935, "text": "if an unsupported JOIN type is set", "labels": []}
{"id": 13936, "text": "if the compression mode is not MODE_EXPLICIT.", "labels": []}
{"id": 13937, "text": "if any of the arguments is null or has more than 4 elements, or if the numbers of DC and AC tables differ.", "labels": []}
{"id": 13938, "text": "if an IOException occurs while deserializing the object from its internal representation.", "labels": []}
{"id": 13939, "text": "if a ClassNotFoundException occurs while deserializing the object from its internal representation.", "labels": []}
{"id": 13940, "text": "if no Provider supports a Signature implementation for the specified algorithm", "labels": []}
{"id": 13941, "text": "if a SignatureSpi implementation for the specified algorithm is not available from the specified provider", "labels": []}
{"id": 13942, "text": "if a SignatureSpi implementation for the specified algorithm is not available from the specified Provider object", "labels": []}
{"id": 13943, "text": "if the key is invalid.", "labels": []}
{"id": 13944, "text": "if the public key in the certificate is not encoded properly or does not include required parameter information or cannot be used for digital signature purposes.", "labels": []}
{"id": 13945, "text": "if this signature object is not initialized properly or if this signature algorithm is unable to process the input data provided.", "labels": []}
{"id": 13946, "text": "if this signature object is not initialized properly, if this signature algorithm is unable to process the input data provided, or if len is less than the actual signature length.", "labels": []}
{"id": 13947, "text": "if outbuf is null, or offset or len is less than 0, or the sum of offset and len is greater than the length of outbuf.", "labels": []}
{"id": 13948, "text": "if this signature object is not initialized properly, the passed-in signature is improperly encoded or of the wrong type, if this signature algorithm is unable to process the input data provided, etc.", "labels": []}
{"id": 13949, "text": "if the signature byte array is null, or the offset or length is less than 0, or the sum of the offset and length is greater than the length of the signature byte array.", "labels": []}
{"id": 13950, "text": "if the specified index is less than -1", "labels": []}
{"id": 13951, "text": "if dst does not have enough space for encoding all input bytes.", "labels": []}
{"id": 13952, "text": "if the specified Set is empty (trustAnchors.isEmpty() == true)", "labels": []}
{"id": 13953, "text": "if the specified Set is null", "labels": []}
{"id": 13954, "text": "if any of the elements in the Set are not of type java.security.cert.TrustAnchor", "labels": []}
{"id": 13955, "text": "if the keystore has not been initialized", "labels": []}
{"id": 13956, "text": "if the keystore does not contain at least one trusted certificate entry", "labels": []}
{"id": 13957, "text": "if the keystore is null", "labels": []}
{"id": 13958, "text": "if any of the elements in the set are not of type java.security.cert.TrustAnchor", "labels": []}
{"id": 13959, "text": "if any of the elements in the set are not of type String", "labels": []}
{"id": 13960, "text": "if any of the elements in the list are not of type java.security.cert.CertStore", "labels": []}
{"id": 13961, "text": "if any of the elements in the list are not of type java.security.cert.PKIXCertPathChecker", "labels": []}
{"id": 13962, "text": "If this factory encountered an exception while attempting to get the object's state, and no other factories are to be tried.", "labels": []}
{"id": 13963, "text": "if any argument is null", "labels": []}
{"id": 13964, "text": "if the name has the incorrect format", "labels": []}
{"id": 13965, "text": "if sourceEncoding is null", "labels": []}
{"id": 13966, "text": "if targetEncoding is null", "labels": []}
{"id": 13967, "text": "if sourceFormat is null", "labels": []}
{"id": 13968, "text": "if targetEncoding or sourceFormat are null", "labels": []}
{"id": 13969, "text": "if targetFormat or sourceFormat are null", "labels": []}
{"id": 13970, "text": "if props is null", "labels": []}
{"id": 13971, "text": "if ip is null", "labels": []}
{"id": 13972, "text": "If variableName is null.", "labels": []}
{"id": 13973, "text": "if source is null.", "labels": []}
{"id": 13974, "text": "if an I/O error occurs while reading the stream.", "labels": []}
{"id": 13975, "text": "if an error occurs during loading, or initialization of the reader class, or during instantiation or initialization of the reader object.", "labels": []}
{"id": 13976, "text": "if the attempt to instantiate the reader fails.", "labels": []}
{"id": 13977, "text": "if the ImageReader's constructor throws an IllegalArgumentException to indicate that the extension object is unsuitable.", "labels": []}
{"id": 13978, "text": "if reader is null.", "labels": []}
{"id": 13979, "text": "if the specified file doesn't exist", "labels": []}
{"id": 13980, "text": "if the current platform does not support the Desktop.Action.OPEN action", "labels": []}
{"id": 13981, "text": "if the specified file has no associated application or the associated application fails to be launched", "labels": []}
{"id": 13982, "text": "if a security manager exists and its SecurityManager.checkRead(java.lang.String) method denies read access to the file, or it denies the AWTPermission(\"showWindowWithoutWarningBanner\") permission, or the calling thread is not allowed to create a subprocess", "labels": []}
{"id": 13983, "text": "if uri is null", "labels": []}
{"id": 13984, "text": "if the current platform does not support the Desktop.Action.BROWSE action", "labels": []}
{"id": 13985, "text": "if the user default browser is not found, or it fails to be launched, or the default handler application failed to be launched", "labels": []}
{"id": 13986, "text": "if a security manager exists and it denies the AWTPermission(\"showWindowWithoutWarningBanner\") permission, or the calling thread is not allowed to create a subprocess", "labels": []}
{"id": 13987, "text": "if a security manager exists and it denies the RuntimePermission(\"canProcessApplicationEvents\") permission", "labels": []}
{"id": 13988, "text": "if the current platform does not support the Desktop.Action.APP_ABOUT action", "labels": []}
{"id": 13989, "text": "if the current platform does not support the Desktop.Action.APP_PREFERENCES action", "labels": []}
{"id": 13990, "text": "if a security manager exists and its SecurityManager.checkRead(java.lang.String) method denies read access to the files, or it denies the RuntimePermission(\"canProcessApplicationEvents\") permission, or the calling thread is not allowed to create a subprocess", "labels": []}
{"id": 13991, "text": "if the current platform does not support the Desktop.Action.APP_OPEN_FILE action", "labels": []}
{"id": 13992, "text": "if a security manager exists and its SecurityManager.checkPrintJobAccess() method denies the permission to print or it denies the RuntimePermission(\"canProcessApplicationEvents\") permission", "labels": []}
{"id": 13993, "text": "if the current platform does not support the Desktop.Action.APP_PRINT_FILE action", "labels": []}
{"id": 13994, "text": "if the current platform does not support the Desktop.Action.APP_OPEN_URI action", "labels": []}
{"id": 13995, "text": "if a security manager exists and it will not allow the caller to invoke System.exit or it denies the RuntimePermission(\"canProcessApplicationEvents\") permission", "labels": []}
{"id": 13996, "text": "if the current platform does not support the Desktop.Action.APP_QUIT_HANDLER action", "labels": []}
{"id": 13997, "text": "if the current platform does not support the Desktop.Action.APP_SUDDEN_TERMINATION action", "labels": []}
{"id": 13998, "text": "if the current platform does not support the Desktop.Action.APP_MENU_BAR action", "labels": []}
{"id": 13999, "text": "if class is abstract or not a subclass of Event", "labels": []}
{"id": 14000, "text": "if a class is abstract or not a subclass of Event", "labels": []}
{"id": 14001, "text": "if a class is not a subclass of Event, is abstract, or the hook is already added", "labels": []}
{"id": 14002, "text": "if the event class has the Registered(false) annotation and is not registered manually", "labels": []}
{"id": 14003, "text": "if a security manager exists and the caller does not have FlightRecorderPermission(\"accessFlightRecorder\")", "labels": []}
{"id": 14004, "text": "if src is null", "labels": []}
{"id": 14005, "text": "if src equals dst", "labels": []}
{"id": 14006, "text": "if src cannot be filtered", "labels": []}
{"id": 14007, "text": "if src and dst do not have the same number of bands", "labels": []}
{"id": 14008, "text": "if this file object was opened for writing and does not support reading", "labels": []}
{"id": 14009, "text": "if this kind of file object does not support character access", "labels": []}
{"id": 14010, "text": "If an I/O error occurs while closing the channel", "labels": []}
{"id": 14011, "text": "If the channel was asynchronously closed", "labels": []}
{"id": 14012, "text": "If the thread blocked in the I/O operation was interrupted", "labels": []}
{"id": 14013, "text": "if src is not in valid Base64 scheme, or dst does not have enough space for decoding all input bytes.", "labels": []}
{"id": 14014, "text": "if src is not in valid Base64 scheme.", "labels": []}
{"id": 14015, "text": "The application may raise an exception.", "labels": []}
{"id": 14016, "text": "if output is not an instance of one of the classes returned by the originating service provider's getOutputTypes method.", "labels": []}
{"id": 14017, "text": "if the output has not been set.", "labels": []}
{"id": 14018, "text": "if image contains a Raster and canWriteRasters returns false.", "labels": []}
{"id": 14019, "text": "if image is null.", "labels": []}
{"id": 14020, "text": "if an error occurs during writing.", "labels": []}
{"id": 14021, "text": "if canWriteSequence returns false.", "labels": []}
{"id": 14022, "text": "if an error occurs writing the stream metadata.", "labels": []}
{"id": 14023, "text": "if the output has not been set, or prepareWriteSequence has not been called.", "labels": []}
{"id": 14024, "text": "if an I/O error occurs during the query.", "labels": []}
{"id": 14025, "text": "if the canReplaceStreamMetadata returns false.", "labels": []}
{"id": 14026, "text": "modes do not include", "labels": []}
{"id": 14027, "text": "if the writer supports image metadata replacement in general, but imageIndex is less than 0 or greater than the largest available index.", "labels": []}
{"id": 14028, "text": "if canReplaceImageMetadata returns false.", "labels": []}
{"id": 14029, "text": "if imageIndex is less than 0 or greater than the largest available index.", "labels": []}
{"id": 14030, "text": "if the writer supports image insertion in general, but imageIndex is less than -1 or greater than the largest available index.", "labels": []}
{"id": 14031, "text": "if canInsertImage(imageIndex) returns false.", "labels": []}
{"id": 14032, "text": "if imageIndex is less than -1 or greater than the largest available index.", "labels": []}
{"id": 14033, "text": "if the writer supports image removal in general, but imageIndex is less than 0 or greater than the largest available index.", "labels": []}
{"id": 14034, "text": "if canRemoveImage(imageIndex) returns false.", "labels": []}
{"id": 14035, "text": "if an I/O error occurs during the removal.", "labels": []}
{"id": 14036, "text": "if canWriteEmpty returns false.", "labels": []}
{"id": 14037, "text": "if a previous call to prepareWriteEmpty has been made without a corresponding call to endWriteEmpty.", "labels": []}
{"id": 14038, "text": "if a previous call to prepareInsertEmpty has been made without a corresponding call to endInsertEmpty.", "labels": []}
{"id": 14039, "text": "if imageType is null or thumbnails contains null references or objects other than BufferedImages.", "labels": []}
{"id": 14040, "text": "if width or height are less than 1.", "labels": []}
{"id": 14041, "text": "if an I/O error occurs during writing.", "labels": []}
{"id": 14042, "text": "if canWriteEmpty(imageIndex) returns false.", "labels": []}
{"id": 14043, "text": "if a previous call to prepareWriteEmpty without a corresponding call to endWriteEmpty has not been made.", "labels": []}
{"id": 14044, "text": "if a previous call to prepareInsertEmpty without a corresponding call to endInsertEmpty has been made.", "labels": []}
{"id": 14045, "text": "if a call to prepareReiplacePixels has been made without a matching call to endReplacePixels.", "labels": []}
{"id": 14046, "text": "if the writer supports empty image insertion in general, but imageIndex is less than -1 or greater than the largest available index.", "labels": []}
{"id": 14047, "text": "if canInsertEmpty(imageIndex) returns false.", "labels": []}
{"id": 14048, "text": "if a previous call to prepareInsertEmpty without a corresponding call to endInsertEmpty has not been made.", "labels": []}
{"id": 14049, "text": "if a previous call to prepareWriteEmpty without a corresponding call to endWriteEmpty has been made.", "labels": []}
{"id": 14050, "text": "if a call to prepareReplacePixels has been made without a matching call to endReplacePixels.", "labels": []}
{"id": 14051, "text": "if the writer supports pixel replacement in general, but imageIndex is less than 0 or greater than the largest available index.", "labels": []}
{"id": 14052, "text": "if canReplacePixels(imageIndex) returns false.", "labels": []}
{"id": 14053, "text": "if there is a previous call to prepareReplacePixels without a matching call to endReplacePixels (i.e., nesting is not allowed).", "labels": []}
{"id": 14054, "text": "if region is null or has a width or height less than 1.", "labels": []}
{"id": 14055, "text": "if an I/O error occurs during the preparation.", "labels": []}
{"id": 14056, "text": "if there is no previous call to prepareReplacePixels without a matching call to endReplacePixels.", "labels": []}
{"id": 14057, "text": "if any of the following are true: image is null.", "labels": []}
{"id": 14058, "text": "if canWriteRasters returns false.", "labels": []}
{"id": 14059, "text": "if any of the following are true: raster is null.", "labels": []}
{"id": 14060, "text": "if the calling thread does not have permission to create modal dialogs with the given modalityType", "labels": []}
{"id": 14061, "text": "if the dialog is displayable", "labels": []}
{"id": 14062, "text": "if undecorated is false, and this dialog does not have the default shape", "labels": []}
{"id": 14063, "text": "if undecorated is false, and this dialog opacity is less than 1.0f", "labels": []}
{"id": 14064, "text": "if undecorated is false, and the alpha value of this dialog background color is less than 1.0f", "labels": []}
{"id": 14065, "text": "if identifier is null or no TableColumn has this identifier", "labels": []}
{"id": 14066, "text": "if sorting is enabled and passed an index outside the number of rows of the TableModel", "labels": []}
{"id": 14067, "text": "if sorting is enabled and passed an index outside the range of the JTable as determined by the method getRowCount", "labels": []}
{"id": 14068, "text": "if the method is asked to show a printing dialog or run interactively, and GraphicsEnvironment.isHeadless returns true", "labels": []}
{"id": 14069, "text": "if a security manager exists and its SecurityManager.checkPrintJobAccess() method disallows this thread from creating a print job request", "labels": []}
{"id": 14070, "text": "if an error in the print system causes the job to be aborted", "labels": []}
{"id": 14071, "text": "if the commit fails", "labels": []}
{"id": 14072, "text": "if insertPos is less than the start of newParagraph or greater than or equal to the end of newParagraph", "labels": []}
{"id": 14073, "text": "if newParagraph is null", "labels": []}
{"id": 14074, "text": "if deletePos is less than the start of newParagraph or greater than the end of newParagraph", "labels": []}
{"id": 14075, "text": "INVALID_STATE_ERR: Raised if detach() has already been invoked on this object.", "labels": []}
{"id": 14076, "text": "INVALID_NODE_TYPE_ERR: Raised if the root container of refNode is not an Attr, Document, or DocumentFragment node or if refNode is a Document, DocumentFragment, Attr, Entity, or Notation node.", "labels": []}
{"id": 14077, "text": "WRONG_DOCUMENT_ERR: Raised if refNode was created from a different document than the one that created this range.", "labels": []}
{"id": 14078, "text": "INVALID_NODE_TYPE_ERR: Raised if the root container of refNode is not an Attr, Document or DocumentFragment node or if refNode is a Document, DocumentFragment, Attr, Entity, or Notation node.", "labels": []}
{"id": 14079, "text": "NO_MODIFICATION_ALLOWED_ERR: Raised if an ancestor container of the start of the Range is read-only.", "labels": []}
{"id": 14080, "text": "WRONG_DOCUMENT_ERR: Raised if newNode and the container of the start of the Range were not created from the same document.", "labels": []}
{"id": 14081, "text": "HIERARCHY_REQUEST_ERR: Raised if the container of the start of the Range is of a type that does not allow children of the type of newNode or if newNode is an ancestor of the container.", "labels": []}
{"id": 14082, "text": "INVALID_NODE_TYPE_ERR: Raised if newNode is an Attr, Entity, Notation, or Document node.", "labels": []}
{"id": 14083, "text": "If an error occurred while creating the new instance.", "labels": []}
{"id": 14084, "text": "If an error occurred while reconnecting.", "labels": []}
{"id": 14085, "text": "If an error occurred while setting the request controls.", "labels": []}
{"id": 14086, "text": "If an error occurred while getting the response controls.", "labels": []}
{"id": 14087, "text": "if formatName is null or is not a supported name.", "labels": []}
{"id": 14088, "text": "if the specified length is less than 1, or if the specified spacing is less than 0", "labels": []}
{"id": 14089, "text": "if the specified thickness is less than 1, or if the specified length is less than 1, or if the specified spacing is less than 0", "labels": []}
{"id": 14090, "text": "if any of the arguments are null, or if there are any null values in the args array", "labels": []}
{"id": 14091, "text": "if off is negative, len is negative, or off + len is greater than b.length.", "labels": []}
{"id": 14092, "text": "if s is null.", "labels": []}
{"id": 14093, "text": "if the modified UTF-8 representation of s requires more than 65536 bytes.", "labels": []}
{"id": 14094, "text": "if off is negative, len is negative, or off + len is greater than s.length.", "labels": []}
{"id": 14095, "text": "if off is negative, len is negative, or off + len is greater than c.length.", "labels": []}
{"id": 14096, "text": "if c is null.", "labels": []}
{"id": 14097, "text": "if off is negative, len is negative, or off + len is greater than i.length.", "labels": []}
{"id": 14098, "text": "if i is null.", "labels": []}
{"id": 14099, "text": "if off is negative, len is negative, or off + len is greater than l.length.", "labels": []}
{"id": 14100, "text": "if l is null.", "labels": []}
{"id": 14101, "text": "if off is negative, len is negative, or off + len is greater than f.length.", "labels": []}
{"id": 14102, "text": "if off is negative, len is negative, or off + len is greater than d.length.", "labels": []}
{"id": 14103, "text": "if d is null.", "labels": []}
{"id": 14104, "text": "if numBits is not between 0 and 64, inclusive.", "labels": []}
{"id": 14105, "text": "if pos lies in the flushed portion of the stream or past the current stream position.", "labels": []}
{"id": 14106, "text": "if a security manager exists and its checkPermission method denies permission to set the log writer.", "labels": []}
{"id": 14107, "text": "if a database access error occurs or the url is null", "labels": []}
{"id": 14108, "text": "when the driver has determined that the timeout value specified by the setLoginTimeout method has been exceeded and has at least tried to cancel the current database connection attempt", "labels": []}
{"id": 14109, "text": "if driver is null", "labels": []}
{"id": 14110, "text": "if a security manager exists and its checkPermission method denies permission to deregister a driver.", "labels": []}
{"id": 14111, "text": "If an invalid module descriptor is detected or the set of packages returned by the packageFinder does not include all of the packages obtained from the module descriptor", "labels": []}
{"id": 14112, "text": "If an I/O error occurs reading from the input stream or UncheckedIOException is thrown by the package finder", "labels": []}
{"id": 14113, "text": "If an invalid module descriptor is detected", "labels": []}
{"id": 14114, "text": "If an I/O error occurs reading from the input stream", "labels": []}
{"id": 14115, "text": "if this queue is full", "labels": []}
{"id": 14116, "text": "if the byte array is null", "labels": []}
{"id": 14117, "text": "if bound is not positive", "labels": []}
{"id": 14118, "text": "if streamSize is less than zero", "labels": []}
{"id": 14119, "text": "if streamSize is less than zero, or randomNumberOrigin is greater than or equal to randomNumberBound", "labels": []}
{"id": 14120, "text": "if randomNumberOrigin is greater than or equal to randomNumberBound", "labels": []}
{"id": 14121, "text": "if this connector server does not support the generation of client stubs.", "labels": []}
{"id": 14122, "text": "if the JMXConnectorServer is not started (see JMXConnectorServerMBean.isActive()).", "labels": []}
{"id": 14123, "text": "if a communications problem means that a stub cannot be created.", "labels": []}
{"id": 14124, "text": "if connectionId is null.", "labels": []}
{"id": 14125, "text": "if mbs or name is null.", "labels": []}
{"id": 14126, "text": "if thrown by the stop method.", "labels": []}
{"id": 14127, "text": "if the directory stream is closed", "labels": []}
{"id": 14128, "text": "if the file could not otherwise be opened because it is not a directory (optional specific exception)", "labels": []}
{"id": 14129, "text": "if the set contains an invalid combination of options", "labels": []}
{"id": 14130, "text": "if an unsupported open option is specified or the array contains attributes that cannot be set atomically when creating the file", "labels": []}
{"id": 14131, "text": "if a file of that name already exists and the CREATE_NEW option is specified (optional specific exception)", "labels": []}
{"id": 14132, "text": "In the case of the default provider, and a security manager is installed, the checkRead method is invoked to check read access to the path if the file is opened for reading.", "labels": []}
{"id": 14133, "text": "The checkWrite method is invoked to check write access to the path if the file is opened for writing.", "labels": []}
{"id": 14134, "text": "if the file does not exist (optional specific exception)", "labels": []}
{"id": 14135, "text": "if the directory does not exist (optional specific exception)", "labels": []}
{"id": 14136, "text": "if the directory could not otherwise be deleted because it is not empty (optional specific exception)", "labels": []}
{"id": 14137, "text": "if this or the target directory stream is closed", "labels": []}
{"id": 14138, "text": "if the file already exists in the target directory and cannot be replaced (optional specific exception)", "labels": []}
{"id": 14139, "text": "if the file cannot be moved as an atomic file system operation", "labels": []}
{"id": 14140, "text": "NOT_FOUND_ERR: Raised if before is not a descendant of the SELECT element.", "labels": []}
{"id": 14141, "text": "if the spliterator does not report a characteristic of SORTED.", "labels": []}
{"id": 14142, "text": "if the provider requires configuration and Provider.configure(java.lang.String) has not been called", "labels": []}
{"id": 14143, "text": "if the login operation fails", "labels": []}
{"id": 14144, "text": "if the caller does not pass a security check for SecurityPermission(\"authProvider.name\"), where name is the value returned by this provider's getName method", "labels": []}
{"id": 14145, "text": "if this method is called on a Clip instance", "labels": []}
{"id": 14146, "text": "if the line cannot be closed due to security restrictions", "labels": []}
{"id": 14147, "text": "if a control of the specified type is not supported", "labels": []}
{"id": 14148, "text": "If typeName or description is a null or empty string, or itemNames or itemDescriptions or itemTypes is null, or any element of itemNames or itemDescriptions is a null or empty string, or any element of itemTypes is null, or itemNames or itemDescriptions or itemTypes are not of the same size.", "labels": []}
{"id": 14149, "text": "If itemNames contains duplicate item names (case sensitive, but leading and trailing whitespaces removed).", "labels": []}
{"id": 14150, "text": "if the column is not part of filtering criteria", "labels": []}
{"id": 14151, "text": "if cookie is null", "labels": []}
{"id": 14152, "text": "if condition is WHEN_IN_FOCUSED_WINDOW and map is not an instance of ComponentInputMap; or if condition is not one of the legal values specified above", "labels": []}
{"id": 14153, "text": "if width or height is < 0", "labels": []}
{"id": 14154, "text": "if id is not one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or if keystrokes contains null, or if any keystroke represents a KEY_TYPED event, or if any keystroke already maps to another focus traversal operation for this Component", "labels": []}
{"id": 14155, "text": "when the attempt to set the property is vetoed by the component", "labels": []}
{"id": 14156, "text": "if the server cannot bind to the requested address, or if the server is already bound.", "labels": []}
{"id": 14157, "text": "if the first byte cannot be read for any reason other than end of file, the stream has been closed and the underlying input stream does not support reading after close, or another I/O error occurs.", "labels": []}
{"id": 14158, "text": "if the String does not contain a parsable int.", "labels": []}
{"id": 14159, "text": "if the string does not contain a parsable integer.", "labels": []}
{"id": 14160, "text": "if the string cannot be parsed as an integer.", "labels": []}
{"id": 14161, "text": "if lengths or values are null, the length of lengths is greater than 16, the length of values is greater than 256, if any value in lengths or values is less than zero, or if the arrays do not describe a valid Huffman table.", "labels": []}
{"id": 14162, "text": "if the data is no longer available in the requested flavor.", "labels": []}
{"id": 14163, "text": "if the requested data flavor is not supported.", "labels": []}
{"id": 14164, "text": "if childIndex is out of bounds", "labels": []}
{"id": 14165, "text": "if newChild is null or is an ancestor of this node", "labels": []}
{"id": 14166, "text": "if this node does not allow children", "labels": []}
{"id": 14167, "text": "if aChild is null", "labels": []}
{"id": 14168, "text": "if aChild is null or is not a child of this node", "labels": []}
{"id": 14169, "text": "if ancestor is not an ancestor of this node", "labels": []}
{"id": 14170, "text": "if this node has no children", "labels": []}
{"id": 14171, "text": "if priority is not NORMAL_PRIORITY or HIGH_PRIORITY.", "labels": []}
{"id": 14172, "text": "if bandwidth is less than zero.", "labels": []}
{"id": 14173, "text": "if an error occurs during de-serialization", "labels": []}
{"id": 14174, "text": "if transformation is null, empty, in an invalid format, or if no Provider supports a CipherSpi implementation for the specified algorithm", "labels": []}
{"id": 14175, "text": "if transformation contains a padding scheme that is not available", "labels": []}
{"id": 14176, "text": "if transformation is null, empty, in an invalid format, or if a CipherSpi implementation for the specified algorithm is not available from the specified provider", "labels": []}
{"id": 14177, "text": "if transformation is null, empty, in an invalid format, or if a CipherSpi implementation for the specified algorithm is not available from the specified Provider object", "labels": []}
{"id": 14178, "text": "if this cipher is in a wrong state (e.g., has not yet been initialized)", "labels": []}
{"id": 14179, "text": "if the given key is inappropriate for initializing this cipher, or requires algorithm parameters that cannot be determined from the given key, or if the given key has a keysize that exceeds the maximum allowable keysize (as determined from the configured jurisdiction policy files).", "labels": []}
{"id": 14180, "text": "if opmode is WRAP_MODE or UNWRAP_MODE but the mode is not implemented by the underlying CipherSpi.", "labels": []}
{"id": 14181, "text": "if the given key is inappropriate for initializing this cipher, or its keysize exceeds the maximum allowable keysize (as determined from the configured jurisdiction policy files).", "labels": []}
{"id": 14182, "text": "if the given algorithm parameters are inappropriate for this cipher, or this cipher requires algorithm parameters and params is null, or the given algorithm parameters imply a cryptographic strength that would exceed the legal limits (as determined from the configured jurisdiction policy files).", "labels": []}
{"id": 14183, "text": "if the public key in the given certificate is inappropriate for initializing this cipher, or this cipher requires algorithm parameters that cannot be determined from the public key in the given certificate, or the keysize of the public key in the given certificate has a keysize that exceeds the maximum allowable keysize (as determined by the configured jurisdiction policy files).", "labels": []}
{"id": 14184, "text": "if this cipher is in a wrong state (e.g., has not been initialized)", "labels": []}
{"id": 14185, "text": "if input and output are the same object", "labels": []}
{"id": 14186, "text": "if the output buffer is read-only", "labels": []}
{"id": 14187, "text": "if transformation is null.", "labels": []}
{"id": 14188, "text": "if transformation is not a valid transformation, i.e.", "labels": []}
{"id": 14189, "text": "if the src byte array is null", "labels": []}
{"id": 14190, "text": "if the corresponding method in the CipherSpi has not been overridden by an implementation", "labels": []}
{"id": 14191, "text": "if the src byte array is null, or the offset or length is less than 0, or the sum of the offset and len is greater than the length of the src byte array", "labels": []}
{"id": 14192, "text": "if the src ByteBuffer is null", "labels": []}
{"id": 14193, "text": "if secretKey or attributes is null", "labels": []}
{"id": 14194, "text": "if data or os is null", "labels": []}
{"id": 14195, "text": "if an error occurs while executing the transform", "labels": []}
{"id": 14196, "text": "if suffix is not a valid LDAP name, or if the addition of the components would violate the syntax rules of this LDAP name.", "labels": []}
{"id": 14197, "text": "If adding comp at the specified position would violate the name's syntax.", "labels": []}
{"id": 14198, "text": "if posn is outside the specified range.", "labels": []}
{"id": 14199, "text": "if deleting the component would violate the syntax rules of the name.", "labels": []}
{"id": 14200, "text": "if obj is null or not a LdapName.", "labels": []}
{"id": 14201, "text": "if x is an invalid vertical scroll bar policy, as listed above", "labels": []}
{"id": 14202, "text": "if x is not a valid horizontal scrollbar policy, as listed above", "labels": []}
{"id": 14203, "text": "If the Class object is null.", "labels": []}
{"id": 14204, "text": "if apdu.length is less than 2", "labels": []}
{"id": 14205, "text": "Wraps another exception or persistence is not supported", "labels": []}
{"id": 14206, "text": "if there is no such member", "labels": []}
{"id": 14207, "text": "if there is an error freeing the XML value.", "labels": []}
{"id": 14208, "text": "if there is an error processing the XML value.", "labels": []}
{"id": 14209, "text": "An exception is thrown if the state is not readable.", "labels": []}
{"id": 14210, "text": "An exception is thrown if the state is not writable.", "labels": []}
{"id": 14211, "text": "The getCause() method of the exception may provide a more detailed exception, for example, if the stream does not contain valid characters.", "labels": []}
{"id": 14212, "text": "if there is an error processing the XML value or if this feature is not supported.", "labels": []}
{"id": 14213, "text": "The getCause() method of the exception may provide a more detailed exception, for example, if an XML parser exception occurs.", "labels": []}
{"id": 14214, "text": "if the given array is null", "labels": []}
{"id": 14215, "text": "if fromIndex is negative, toIndex is less than fromIndex, or toIndex is greater than the array size", "labels": []}
{"id": 14216, "text": "if the given iterator is null", "labels": []}
{"id": 14217, "text": "if the given spliterator is null", "labels": []}
{"id": 14218, "text": "if any of the parameters are invalid or unsupported.", "labels": []}
{"id": 14219, "text": "if metadata is null or is not an instance of the correct class.", "labels": []}
{"id": 14220, "text": "if access to the file is denied by the SecurityManager", "labels": []}
{"id": 14221, "text": "if version is null", "labels": []}
{"id": 14222, "text": "may be thrown if the jar file has been closed", "labels": []}
{"id": 14223, "text": "A Java-specific IO exception, possibly the result of creating a new InputStream or Reader for the InputSource.", "labels": []}
{"id": 14224, "text": "if component is null", "labels": []}
{"id": 14225, "text": "if alignment is null", "labels": []}
{"id": 14226, "text": "if components is null, or contains null", "labels": []}
{"id": 14227, "text": "if components is null, or contains null; or axis is not SwingConstants.HORIZONTAL or SwingConstants.VERTICAL", "labels": []}
{"id": 14228, "text": "if parent is not the same Container that this was created with", "labels": []}
{"id": 14229, "text": "if invalid value is passed", "labels": []}
{"id": 14230, "text": "if the array of arguments contains any null elements.", "labels": []}
{"id": 14231, "text": "if interrupted while waiting, in which case the element is not left enqueued", "labels": []}
{"id": 14232, "text": "if it can be determined that the input method is inoperable, for example, because of incomplete installation.", "labels": []}
{"id": 14233, "text": "if the target's type is not identical with the caller's symbolic type descriptor", "labels": []}
{"id": 14234, "text": "if the target's type cannot be adjusted to the caller's symbolic type descriptor", "labels": []}
{"id": 14235, "text": "if the target's type can be adjusted to the caller, but a reference cast fails", "labels": []}
{"id": 14236, "text": "if an argument cannot be converted by reference casting", "labels": []}
{"id": 14237, "text": "if the target's type cannot be adjusted to take the given number of Object arguments", "labels": []}
{"id": 14238, "text": "if arguments is a null reference", "labels": []}
{"id": 14239, "text": "if newType is a null reference", "labels": []}
{"id": 14240, "text": "if the conversion cannot be made", "labels": []}
{"id": 14241, "text": "if arrayType is a null reference", "labels": []}
{"id": 14242, "text": "if arrayType is not an array type, or if target does not have at least arrayLength parameter types, or if arrayLength is negative, or if the resulting method handle's type would have too many parameters", "labels": []}
{"id": 14243, "text": "if the implied asType call fails", "labels": []}
{"id": 14244, "text": "if arrayType is not an array type, or if target does not have at least arrayLength parameter types, or if arrayLength is negative, or if spreadArgPos has an illegal value (negative, or together with arrayLength exceeding the number of arguments), or if the resulting method handle's type would have too many parameters", "labels": []}
{"id": 14245, "text": "if makeVarargs is true and this method handle does not have a trailing array parameter", "labels": []}
{"id": 14246, "text": "if arrayType is not an array type or arrayType is not assignable to this method handle's trailing parameter type, or arrayLength is not a legal array size, or the resulting method handle's type would have too many parameters", "labels": []}
{"id": 14247, "text": "if arrayType is not an array type or arrayType is not assignable to this method handle's array parameter type, or arrayLength is not a legal array size, or collectArgPos has an illegal value (negative, or greater than the number of arguments), or the resulting method handle's type would have too many parameters", "labels": []}
{"id": 14248, "text": "if arrayType is not an array type or arrayType is not assignable to this method handle's trailing parameter type", "labels": []}
{"id": 14249, "text": "if the target does not have a leading parameter type that is a reference type", "labels": []}
{"id": 14250, "text": "if x cannot be converted to the leading parameter type of the target", "labels": []}
{"id": 14251, "text": "if objectArgCount is negative or greater than 255 (or 254, if finalArray is true)", "labels": []}
{"id": 14252, "text": "if the string is null", "labels": []}
{"id": 14253, "text": "if the string is not well-formed", "labels": []}
{"id": 14254, "text": "if a named type cannot be found", "labels": []}
{"id": 14255, "text": "if trustAnchors is empty (trustAnchors.isEmpty() == true)", "labels": []}
{"id": 14256, "text": "if trustAnchors is null", "labels": []}
{"id": 14257, "text": "if any of the elements of trustAnchors are not of type java.security.cert.TrustAnchor", "labels": []}
{"id": 14258, "text": "if keystore has not been initialized", "labels": []}
{"id": 14259, "text": "if keystore does not contain at least one trusted certificate entry", "labels": []}
{"id": 14260, "text": "if keystore is null", "labels": []}
{"id": 14261, "text": "if maxPathLength is set to a value less than -1", "labels": []}
{"id": 14262, "text": "if startInstant parameter is null.", "labels": []}
{"id": 14263, "text": "If the startInstant parameter is null.", "labels": []}
{"id": 14264, "text": "If the field parameter is null.", "labels": []}
{"id": 14265, "text": "If the rhs parameter is null.", "labels": []}
{"id": 14266, "text": "If two durations cannot be meaningfully added.", "labels": []}
{"id": 14267, "text": "For example, adding negative one day to one month causes this exception.", "labels": []}
{"id": 14268, "text": "if the calendar parameter is null.", "labels": []}
{"id": 14269, "text": "If two durations cannot be meaningfully subtracted.", "labels": []}
{"id": 14270, "text": "For example, subtracting one day from one month causes this exception.", "labels": []}
{"id": 14271, "text": "if operation produces fraction in the months field.", "labels": []}
{"id": 14272, "text": "if the factor parameter is null.", "labels": []}
{"id": 14273, "text": "If the startTimeInstant parameter is null.", "labels": []}
{"id": 14274, "text": "If the underlying implementation cannot reasonably process the request, e.g.", "labels": []}
{"id": 14275, "text": "if duration is null.", "labels": []}
{"id": 14276, "text": "If duration is null.", "labels": []}
{"id": 14277, "text": "if the specified service does not support 2D printing, or this PrinterJob class does not support setting a 2D print service, or the specified service is otherwise not a valid print service.", "labels": []}
{"id": 14278, "text": "if attributes parameter is null.", "labels": []}
{"id": 14279, "text": "an error in the print system caused the job to be aborted.", "labels": []}
{"id": 14280, "text": "Wraps a java.lang.ClassNotFoundException or a java.lang.Exception that occurred when trying to invoke the MBean's constructor.", "labels": []}
{"id": 14281, "text": "The preRegister (MBeanRegistration interface) method of the MBean has thrown an exception.", "labels": []}
{"id": 14282, "text": "If the MBean's constructor or its preRegister or postRegister method threw a RuntimeException.", "labels": []}
{"id": 14283, "text": "If the postRegister (MBeanRegistration interface) method of the MBean throws a RuntimeException, the createMBean method will throw a RuntimeMBeanException, although the MBean creation and registration succeeded.", "labels": []}
{"id": 14284, "text": "In such a case, the MBean will be actually registered even though the createMBean method threw an exception.", "labels": []}
{"id": 14285, "text": "Note that RuntimeMBeanException can also be thrown by preRegister, in which case the MBean will not be registered.", "labels": []}
{"id": 14286, "text": "If the postRegister (MBeanRegistration interface) method of the MBean throws an Error, the createMBean method will throw a RuntimeErrorException, although the MBean creation and registration succeeded.", "labels": []}
{"id": 14287, "text": "Note that RuntimeErrorException can also be thrown by preRegister, in which case the MBean will not be registered.", "labels": []}
{"id": 14288, "text": "The constructor of the MBean has thrown an exception", "labels": []}
{"id": 14289, "text": "Wraps a java.lang.IllegalArgumentException: The className passed in parameter is null, the ObjectName passed in parameter contains a pattern or no ObjectName is specified for the MBean.", "labels": []}
{"id": 14290, "text": "A communication problem occurred when talking to the MBean server.", "labels": []}
{"id": 14291, "text": "The MBean's constructor or its preRegister or postRegister method threw a RuntimeException.", "labels": []}
{"id": 14292, "text": "If the postRegister method (MBeanRegistration interface) method of the MBean throws an Error, the createMBean method will throw a RuntimeErrorException, although the MBean creation and registration succeeded.", "labels": []}
{"id": 14293, "text": "Wraps a java.lang.IllegalArgumentException: The object name in parameter is null.", "labels": []}
{"id": 14294, "text": "An exception occurred when trying to invoke the getAttributes method of a Dynamic MBean.", "labels": []}
{"id": 14295, "text": "Wrap a java.lang.IllegalArgumentException: The object name in parameter is null or attributes in parameter is null.", "labels": []}
{"id": 14296, "text": "Wraps a java.lang.IllegalArgumentException: The object name in parameter is null or attributes in parameter is null.", "labels": []}
{"id": 14297, "text": "Wraps an IllegalArgumentException.", "labels": []}
{"id": 14298, "text": "if the attribute view is not available or it does not support reading the attribute", "labels": []}
{"id": 14299, "text": "If xmlEventWriter == null.", "labels": []}
{"id": 14300, "text": "If xmlStreamWriter == null.", "labels": []}
{"id": 14301, "text": "Is always thrown by this method.", "labels": []}
{"id": 14302, "text": "if codebase is null and a provider-specific URL used to load classes is invalid", "labels": []}
{"id": 14303, "text": "if a definition for the class could not be found at the specified URL", "labels": []}
{"id": 14304, "text": "if codebase is non-null and contains an invalid URL, or if codebase is null and a provider-specific URL used to load classes is invalid", "labels": []}
{"id": 14305, "text": "if a definition for the class could not be found at the specified location", "labels": []}
{"id": 14306, "text": "if codebase is non-null and contains an invalid URL, or if codebase is null and a provider-specific URL used to identify the class loader is invalid", "labels": []}
{"id": 14307, "text": "if there is a security manager and the invocation of its checkPermission method fails, or if the caller does not have permission to connect to all of the URLs in the codebase URL path", "labels": []}
{"id": 14308, "text": "if there is a security manager and the invocation of its checkPermission method fails", "labels": []}
{"id": 14309, "text": "if this input stream has been closed by invoking its close() method, or an I/O error occurs.", "labels": []}
{"id": 14310, "text": "if this stream has not been marked or, if the mark has been invalidated, or the stream has been closed by invoking its close() method, or an I/O error occurs.", "labels": []}
{"id": 14311, "text": "if the initial capacity is less than zero.", "labels": []}
{"id": 14312, "text": "if an error occurred when reading from the input stream.", "labels": []}
{"id": 14313, "text": "if a malformed Unicode escape appears in the input.", "labels": []}
{"id": 14314, "text": "if the input stream contains a malformed Unicode escape sequence.", "labels": []}
{"id": 14315, "text": "if inStream is null.", "labels": []}
{"id": 14316, "text": "if writing this property list to the specified output stream throws an IOException.", "labels": []}
{"id": 14317, "text": "if this Properties object contains any keys or values that are not Strings.", "labels": []}
{"id": 14318, "text": "if writer is null.", "labels": []}
{"id": 14319, "text": "if out is null.", "labels": []}
{"id": 14320, "text": "if reading from the specified input stream results in an IOException.", "labels": []}
{"id": 14321, "text": "if the document's encoding declaration can be read and it specifies an encoding that is not supported", "labels": []}
{"id": 14322, "text": "if in is null.", "labels": []}
{"id": 14323, "text": "if writing to the specified output stream results in an IOException.", "labels": []}
{"id": 14324, "text": "if the encoding is not supported by the implementation.", "labels": []}
{"id": 14325, "text": "if os is null, or if encoding is null.", "labels": []}
{"id": 14326, "text": "if os or charset is null.", "labels": []}
{"id": 14327, "text": "if any key in this property list is not a string.", "labels": []}
{"id": 14328, "text": "if url is invalid or if actions contains white-space.", "labels": []}
{"id": 14329, "text": "if the amount cannot be added", "labels": []}
{"id": 14330, "text": "if the unit is not supported by the temporal", "labels": []}
{"id": 14331, "text": "if the amount cannot be calculated, or the end temporal cannot be converted to the same type as the start temporal", "labels": []}
{"id": 14332, "text": "if an instance of this factory cannot be loaded", "labels": []}
{"id": 14333, "text": "if the property is not supported", "labels": []}
{"id": 14334, "text": "if the given priority is out of range", "labels": []}
{"id": 14335, "text": "If nsContext is null.", "labels": []}
{"id": 14336, "text": "If expression cannot be compiled.", "labels": []}
{"id": 14337, "text": "If expression is null.", "labels": []}
{"id": 14338, "text": "If expression cannot be evaluated.", "labels": []}
{"id": 14339, "text": "If returnType is not one of the types defined in XPathConstants ( NUMBER, STRING, BOOLEAN, NODE or NODESET).", "labels": []}
{"id": 14340, "text": "If expression or returnType is null.", "labels": []}
{"id": 14341, "text": "If the expression cannot be evaluated.", "labels": []}
{"id": 14342, "text": "If type is not of the types corresponding to the types defined in the XPathEvaluationResult.XPathResultType, or XPathEvaluationResult is specified as the type but an implementation supporting the ANY type is not available.", "labels": []}
{"id": 14343, "text": "If expression or type is null.", "labels": []}
{"id": 14344, "text": "If the implementation of this method does not support the ANY type.", "labels": []}
{"id": 14345, "text": "if invocation is null.", "labels": []}
{"id": 14346, "text": "If the SCTP protocol is not supported", "labels": []}
{"id": 14347, "text": "If a security manager has been installed and it does not permit access to the remote peer of the new association", "labels": []}
{"id": 14348, "text": "If the implementation does not support removing addresses from a listening socket, address is not bound to the channel's socket, or the channel has only one address bound to it", "labels": []}
{"id": 14349, "text": "if the profile does not specify the corresponding TRC as a single gamma value", "labels": []}
{"id": 14350, "text": "if the profile does not specify the corresponding TRC as a table", "labels": []}
{"id": 14351, "text": "if value is null.", "labels": []}
{"id": 14352, "text": "if value does not conform to this TabularData instance's row type definition.", "labels": []}
{"id": 14353, "text": "if the key is null", "labels": []}
{"id": 14354, "text": "if the key does not conform to this TabularData instance's TabularType type definition.", "labels": []}
{"id": 14355, "text": "if the value is null", "labels": []}
{"id": 14356, "text": "if the value is not of the type CompositeData", "labels": []}
{"id": 14357, "text": "if the value does not conform to this TabularData instance's TabularType definition", "labels": []}
{"id": 14358, "text": "if the key for the value parameter, calculated according to this TabularData instance's TabularType definition already maps to an existing value", "labels": []}
{"id": 14359, "text": "if the key does not conform to this TabularData instance's TabularType definition", "labels": []}
{"id": 14360, "text": "if a value in t is null.", "labels": []}
{"id": 14361, "text": "if a value in t is not an instance of CompositeData.", "labels": []}
{"id": 14362, "text": "if a value in t does not conform to this TabularData instance's row type definition.", "labels": []}
{"id": 14363, "text": "if the index for a value in t, calculated according to this TabularData instance's TabularType definition already maps to an existing value in this instance, or two values in t have the same index.", "labels": []}
{"id": 14364, "text": "if an element of values is null", "labels": []}
{"id": 14365, "text": "if an element of values does not conform to this TabularData instance's row type definition (ie its TabularType definition)", "labels": []}
{"id": 14366, "text": "if the index for an element of values, calculated according to this TabularData instance's TabularType definition already maps to an existing value in this instance, or two elements of values have the same index", "labels": []}
{"id": 14367, "text": "if defaultCloseOperation value isn't one of the above valid values", "labels": []}
{"id": 14368, "text": "(a runtime exception) if the content pane parameter is null", "labels": []}
{"id": 14369, "text": "if targetClass is a primitve type or array class", "labels": []}
{"id": 14370, "text": "if targetClass or caller is null", "labels": []}
{"id": 14371, "text": "if the access check specified above fails", "labels": []}
{"id": 14372, "text": "if the caller is not privileged to call setAccessible", "labels": []}
{"id": 14373, "text": "if the target is not a direct method handle", "labels": []}
{"id": 14374, "text": "if arrayClass is not an array type", "labels": []}
{"id": 14375, "text": "if the arrayClass is null", "labels": []}
{"id": 14376, "text": "if viewArrayClass or byteOrder is null", "labels": []}
{"id": 14377, "text": "if viewArrayClass is not an array type", "labels": []}
{"id": 14378, "text": "if the component type of viewArrayClass is not supported as a variable type", "labels": []}
{"id": 14379, "text": "if leadingArgCount is not in the range from 0 to type.parameterCount() inclusive, or if the resulting method handle's type would have too many parameters", "labels": []}
{"id": 14380, "text": "if the resulting method handle's type would have too many parameters", "labels": []}
{"id": 14381, "text": "if the index array length is not equal to the arity of the target, or if any index array element not a valid index for a parameter of newType, or if two corresponding parameter types in target.type() and newType are not identical,", "labels": []}
{"id": 14382, "text": "if the type argument is null", "labels": []}
{"id": 14383, "text": "if the value cannot be converted to the required return type", "labels": []}
{"id": 14384, "text": "if the given type is void.class", "labels": []}
{"id": 14385, "text": "if the target or the values array is null", "labels": []}
{"id": 14386, "text": "if (@code pos) is less than 0 or greater than N - L where N is the arity of the target method handle and L is the length of the values array.", "labels": []}
{"id": 14387, "text": "if an argument does not match the corresponding bound parameter type.", "labels": []}
{"id": 14388, "text": "if the target is null, or if the valueTypes list or any of its elements is null", "labels": []}
{"id": 14389, "text": "if any element of valueTypes is void.class, or if pos is negative or greater than the arity of the target, or if the new method handle's type would have too many parameters", "labels": []}
{"id": 14390, "text": "if the target is null, or if the valueTypes array or any of its elements is null", "labels": []}
{"id": 14391, "text": "if any element of newTypes is void.class, or if skip is negative or greater than the arity of the target, or if pos is negative or greater than the newTypes list size, or if newTypes does not contain the target's non-skipped parameter types at position pos.", "labels": []}
{"id": 14392, "text": "if the target is null or if the filters array is null", "labels": []}
{"id": 14393, "text": "if a non-null element of filters does not match a corresponding argument type of target as described above, or if the pos+filters.length is greater than target.type().parameterCount(), or if the resulting method handle's type would have too many parameters", "labels": []}
{"id": 14394, "text": "if the return type of filter is non-void and is not the same as the pos argument of the target, or if pos is not between 0 and the target's arity, inclusive, or if the resulting method handle's type would have too many parameters", "labels": []}
{"id": 14395, "text": "if the argument list of filter does not match the return type of target as described above", "labels": []}
{"id": 14396, "text": "if combiner's return type is non-void and not the same as the first argument type of the target, or if the initial N argument types of the target (skipping one matching the combiner's return type) are not identical with the argument types of combiner", "labels": []}
{"id": 14397, "text": "if either of the following two conditions holds: (1) combiner's return type is non-void and not the same as the argument type at position pos of the target signature; (2) the N argument types at position pos of the target signature (skipping one matching the combiner's return type) are not identical with the argument types of combiner.", "labels": []}
{"id": 14398, "text": "if test does not return boolean, or if all three method types do not match (with the return type of test changed to match that of the target).", "labels": []}
{"id": 14399, "text": "if handler does not accept the given exception type, or if the method handle types do not match in their return types and their corresponding parameters", "labels": []}
{"id": 14400, "text": "if the rules for the arguments are violated.", "labels": []}
{"id": 14401, "text": "if pred or body are null.", "labels": []}
{"id": 14402, "text": "if either of the iterations or body handles is null.", "labels": []}
{"id": 14403, "text": "if any argument violates the rules formulated above.", "labels": []}
{"id": 14404, "text": "if any of the start, end, or body handles is null.", "labels": []}
{"id": 14405, "text": "if the body handle is null.", "labels": []}
{"id": 14406, "text": "if any argument violates the above requirements.", "labels": []}
{"id": 14407, "text": "if cleanup does not accept the required leading arguments, or if the method handle types do not match in their return types and their corresponding trailing parameters", "labels": []}
{"id": 14408, "text": "if this JShell instance is closed.", "labels": []}
{"id": 14409, "text": "if the snippet is not associated with this JShell instance.", "labels": []}
{"id": 14410, "text": "if this JShell instance is closed", "labels": []}
{"id": 14411, "text": "if the parameter at the specified index is not a Byte", "labels": []}
{"id": 14412, "text": "if the parameter at the specified index is null", "labels": []}
{"id": 14413, "text": "if index is negative or not less than the current size of this ParameterBlock object", "labels": []}
{"id": 14414, "text": "if the parameter at the specified index is not a Character", "labels": []}
{"id": 14415, "text": "if the parameter at the specified index is not a Short", "labels": []}
{"id": 14416, "text": "if the parameter at the specified index is not an Integer", "labels": []}
{"id": 14417, "text": "if the parameter at the specified index is not a Long", "labels": []}
{"id": 14418, "text": "if the parameter at the specified index is not a Float", "labels": []}
{"id": 14419, "text": "if the parameter at the specified index is not a Double", "labels": []}
{"id": 14420, "text": "If cannot find an initial context.", "labels": []}
{"id": 14421, "text": "In a naming exception is encountered.", "labels": []}
{"id": 14422, "text": "if an attempt is made to supply an empty or null provider name", "labels": []}
{"id": 14423, "text": "If an error occurs obtaining the registered providers", "labels": []}
{"id": 14424, "text": "if a security manager exists and its checkPermission method denies calling setLogger", "labels": []}
{"id": 14425, "text": "if the logger is null", "labels": []}
{"id": 14426, "text": "if the supplied JNDI context is null", "labels": []}
{"id": 14427, "text": "if a security manager exists and its checkPermission method denies calling setJNDIContext", "labels": []}
{"id": 14428, "text": "if no Provider supports an AlgorithmParametersSpi implementation for the specified algorithm", "labels": []}
{"id": 14429, "text": "if an AlgorithmParametersSpi implementation for the specified algorithm is not available from the specified provider", "labels": []}
{"id": 14430, "text": "on decoding errors, or if this parameter object has already been initialized.", "labels": []}
{"id": 14431, "text": "if the requested parameter specification is inappropriate for this parameter object, or if this parameter object has not been initialized.", "labels": []}
{"id": 14432, "text": "on encoding errors, or if this parameter object has not been initialized.", "labels": []}
{"id": 14433, "text": "if the value of the target or methodName property is null", "labels": []}
{"id": 14434, "text": "if a matching method is not found", "labels": []}
{"id": 14435, "text": "if a security manager exists and it denies the method invocation", "labels": []}
{"id": 14436, "text": "if the method with the specified methodName throws an exception", "labels": []}
{"id": 14437, "text": "if object registration fails.", "labels": []}
{"id": 14438, "text": "if either of the following fails: a) registering the object with the activation system or b) exporting the object to the RMI runtime.", "labels": []}
{"id": 14439, "text": "if and only if activation is not supported by this implementation.", "labels": []}
{"id": 14440, "text": "if exporting the object to the RMI runtime fails", "labels": []}
{"id": 14441, "text": "if object is not known (it may already be inactive)", "labels": []}
{"id": 14442, "text": "if group is not active", "labels": []}
{"id": 14443, "text": "if activation group is not active", "labels": []}
{"id": 14444, "text": "if object registration or export fails", "labels": []}
{"id": 14445, "text": "if object export fails", "labels": []}
{"id": 14446, "text": "if dialogType is not legal", "labels": []}
{"id": 14447, "text": "if mode is an illegal file selection mode", "labels": []}
{"id": 14448, "text": "if the parameters are outside of the range: (0 <= start < (getSizes().length)) AND (length >= 0)", "labels": []}
{"id": 14449, "text": "if an error occurs in script.", "labels": []}
{"id": 14450, "text": "ScriptEngines should create and throw ScriptException wrappers for checked Exceptions thrown by underlying scripting implementations.", "labels": []}
{"id": 14451, "text": "if specified scope is invalid", "labels": []}
{"id": 14452, "text": "if the scope is invalid", "labels": []}
{"id": 14453, "text": "if the bindings is null and the scope is ScriptContext.ENGINE_SCOPE", "labels": []}
{"id": 14454, "text": "if context is null.", "labels": []}
{"id": 14455, "text": "if the Java virtual machine implementation does not support thread memory allocation measurement.", "labels": []}
{"id": 14456, "text": "if the Java virtual machine does not support thread memory allocation measurement.", "labels": []}
{"id": 14457, "text": "if values is null or zero size", "labels": []}
{"id": 14458, "text": "if values is null or zero length", "labels": []}
{"id": 14459, "text": "if list is null or zero length", "labels": []}
{"id": 14460, "text": "if the specified value isn't allowed", "labels": []}
{"id": 14461, "text": "if file equals null", "labels": []}
{"id": 14462, "text": "if the caller does not have necessary permissions", "labels": []}
{"id": 14463, "text": "if the linked file does not exist", "labels": []}
{"id": 14464, "text": "if both dateStyle and timeStyle are null", "labels": []}
{"id": 14465, "text": "if the width is invalid", "labels": []}
{"id": 14466, "text": "if the widths are invalid", "labels": []}
{"id": 14467, "text": "if the width or base value is invalid", "labels": []}
{"id": 14468, "text": "if the field has a variable set of valid values or either width is invalid", "labels": []}
{"id": 14469, "text": "if the number of fractional digits is invalid", "labels": []}
{"id": 14470, "text": "if the pattern is invalid", "labels": []}
{"id": 14471, "text": "if style is neither full nor short", "labels": []}
{"id": 14472, "text": "if both the date and time styles are null", "labels": []}
{"id": 14473, "text": "if pad width is too small", "labels": []}
{"id": 14474, "text": "if there was no previous call to optionalStart", "labels": []}
{"id": 14475, "text": "if a security manager exists and the caller does not have ManagementPermission(\"control\")", "labels": []}
{"id": 14476, "text": "if a recording with the specified ID doesn't exist", "labels": []}
{"id": 14477, "text": "if a recording with the iD doesn't exist, or if options contains invalid values", "labels": []}
{"id": 14478, "text": "if the recording is closed, an I/O error occurs, or no data is available for the specified recording or interval", "labels": []}
{"id": 14479, "text": "if a stream with the specified ID doesn't exist", "labels": []}
{"id": 14480, "text": "if an I/O error occurs while trying to close the stream", "labels": []}
{"id": 14481, "text": "if the stream is closed, or an I/O error occurred while trying to read the stream", "labels": []}
{"id": 14482, "text": "if no recording with the stream ID exists", "labels": []}
{"id": 14483, "text": "if a security manager exists and the caller does not have ManagementPermission(\"monitor\")", "labels": []}
{"id": 14484, "text": "if no recording with the specified ID exists", "labels": []}
{"id": 14485, "text": "if a security manager exists, and the caller does not have ManagementPermission(\"control\") or an option contains a file that the caller does not have permission to operate on.", "labels": []}
{"id": 14486, "text": "if the recording can't be dumped due to an I/O error (for example, an invalid path)", "labels": []}
{"id": 14487, "text": "if the recording is not yet started or if it is already closed", "labels": []}
{"id": 14488, "text": "if a security manager exists and its SecurityManager.checkWrite(java.lang.String) method denies write access to the named file or the caller does not have ManagmentPermission(\"control\")", "labels": []}
{"id": 14489, "text": "If an I/O error occurs while closing the file descriptor", "labels": []}
{"id": 14490, "text": "if no field called name exists", "labels": []}
{"id": 14491, "text": "if the field doesn't exist, or the field is not of type boolean", "labels": []}
{"id": 14492, "text": "if the field doesn't exist, or the field is not of type byte", "labels": []}
{"id": 14493, "text": "if the field doesn't exist, or the field is not of type char", "labels": []}
{"id": 14494, "text": "if the field doesn't exist, or the field value can't be converted to the type short by a widening conversion", "labels": []}
{"id": 14495, "text": "if the field doesn't exist, or the field value can't be converted to the type int by a widening conversion", "labels": []}
{"id": 14496, "text": "if the field doesn't exist, or the field value can't be converted to the type float by a widening conversion", "labels": []}
{"id": 14497, "text": "if the field doesn't exist, or the field value can't be converted to the type long via a widening conversion", "labels": []}
{"id": 14498, "text": "if the field doesn't exist, or the field value can't be converted to the type double by a widening conversion", "labels": []}
{"id": 14499, "text": "if the field doesn't exist, or the field isn't of type String", "labels": []}
{"id": 14500, "text": "if the field doesn't exist, or the field value can't be converted to a Duration object", "labels": []}
{"id": 14501, "text": "if the field doesn't exist, or the field value can't be converted to an Instant object", "labels": []}
{"id": 14502, "text": "if the field doesn't exist, or the field isn't of type Class", "labels": []}
{"id": 14503, "text": "if the field doesn't exist, or the field isn't of type Thread", "labels": []}
{"id": 14504, "text": "if access cannot be enabled for all objects in the array", "labels": []}
{"id": 14505, "text": "if the request is denied by the security manager or an element in the array is a constructor for java.lang.Class", "labels": []}
{"id": 14506, "text": "if access cannot be enabled", "labels": []}
{"id": 14507, "text": "if the request is denied by the security manager", "labels": []}
{"id": 14508, "text": "if this reflected object is a static member or constructor and the given obj is non-null, or if this reflected object is an instance method or field and the given obj is null or of type that is not a subclass of the declaring class of the member.", "labels": []}
{"id": 14509, "text": "if the frame is displayable", "labels": []}
{"id": 14510, "text": "if undecorated is false, and this frame does not have the default shape", "labels": []}
{"id": 14511, "text": "if undecorated is false, and this frame opacity is less than 1.0f", "labels": []}
{"id": 14512, "text": "if undecorated is false, and the alpha value of this frame background color is less than 1.0f", "labels": []}
{"id": 14513, "text": "thrown when the print job is terminated.", "labels": []}
{"id": 14514, "text": "If xmlEventReader access throws an Exception.", "labels": []}
{"id": 14515, "text": "If xmlEventReader == null.", "labels": []}
{"id": 14516, "text": "If xmlEventReader is not in XMLStreamConstants.START_DOCUMENT or XMLStreamConstants.START_ELEMENT state.", "labels": []}
{"id": 14517, "text": "If xmlStreamReader == null.", "labels": []}
{"id": 14518, "text": "If xmlStreamReader is not in XMLStreamConstants.START_DOCUMENT or XMLStreamConstants.START_ELEMENT state.", "labels": []}
{"id": 14519, "text": "when an illegal value for the orientation argument is supplied", "labels": []}
{"id": 14520, "text": "if the constraint object is not a string, or if it not one of the five specified constants.", "labels": []}
{"id": 14521, "text": "if a SQL error occurs in capturing the CLOB; if the Clob object is a null; or if either of the Clob.getCharacterStream() and Clob.getAsciiStream() methods on the Clob returns a null", "labels": []}
{"id": 14522, "text": "if this SerialClob object was not instantiated with a Clob object; if free had previously been called on this object", "labels": []}
{"id": 14523, "text": "if there is an error accessing the CLOB value represented by the Clob object that was used to create this SerialClob object", "labels": []}
{"id": 14524, "text": "if the free method had been previously called on this object", "labels": []}
{"id": 14525, "text": "if there is an error accessing the Clob value from the database.", "labels": []}
{"id": 14526, "text": "if an error occurs locating the Clob signature; if the free method had been previously called on this object", "labels": []}
{"id": 14527, "text": "if there is an error accessing the Clob value from the database", "labels": []}
{"id": 14528, "text": "if SerialClob is not instantiated with a Clob object; if the free method had been previously called on this object", "labels": []}
{"id": 14529, "text": "if there is an error accessing the CLOB value", "labels": []}
{"id": 14530, "text": "if the SerialClob is not instantiated with a Clob object; if the free method had been previously called on this object", "labels": []}
{"id": 14531, "text": "When Implementations do not override this method", "labels": []}
{"id": 14532, "text": "If the given InputStream is null.", "labels": []}
{"id": 14533, "text": "If parse produces a SAX error.", "labels": []}
{"id": 14534, "text": "If an IO error occurs interacting with the InputStream.", "labels": []}
{"id": 14535, "text": "If any IO error occurs interacting with the InputStream.", "labels": []}
{"id": 14536, "text": "If any SAX errors occur during processing.", "labels": []}
{"id": 14537, "text": "If the uri is null.", "labels": []}
{"id": 14538, "text": "If the File object is null.", "labels": []}
{"id": 14539, "text": "If the InputSource object is null.", "labels": []}
{"id": 14540, "text": "When the underlying XMLReader does not recognize the property name.", "labels": []}
{"id": 14541, "text": "When the underlying XMLReader recognizes the property name but doesn't support the property.", "labels": []}
{"id": 14542, "text": "if the driver does not use java.util.logging.", "labels": []}
{"id": 14543, "text": "if this throwable was created with Throwable(Throwable) or Throwable(String,Throwable), or this method has already been called on this throwable.", "labels": []}
{"id": 14544, "text": "if stackTrace is null or if any of the elements of stackTrace are null", "labels": []}
{"id": 14545, "text": "if exception is this throwable; a throwable cannot suppress itself.", "labels": []}
{"id": 14546, "text": "if exception is null", "labels": []}
{"id": 14547, "text": "if seq is null.", "labels": []}
{"id": 14548, "text": "if the value index is negative or not less than seq.length().", "labels": []}
{"id": 14549, "text": "if a is null.", "labels": []}
{"id": 14550, "text": "if the value index is negative or not less than the length of the char array.", "labels": []}
{"id": 14551, "text": "if the index argument is negative or not less than the limit argument, or if the limit argument is negative or greater than the length of the char array.", "labels": []}
{"id": 14552, "text": "if the index argument is less than 1 or greater than seq.length().", "labels": []}
{"id": 14553, "text": "if the index argument is less than 1 or greater than the length of the char array", "labels": []}
{"id": 14554, "text": "if the index argument is not greater than the start argument or is greater than the length of the char array, or if the start argument is negative or not less than the length of the char array.", "labels": []}
{"id": 14555, "text": "if the specified codePoint is not a valid Unicode code point.", "labels": []}
{"id": 14556, "text": "if the specified dst is null.", "labels": []}
{"id": 14557, "text": "if dstIndex is negative or not less than dst.length, or if dst at dstIndex doesn't have enough array element(s) to store the resulting char value(s).", "labels": []}
{"id": 14558, "text": "(If dstIndex is equal to dst.length-1 and the specified codePoint is a supplementary character, the high-surrogate value is not stored in dst[dstIndex].)", "labels": []}
{"id": 14559, "text": "if the specified name is not a valid Unicode character name.", "labels": []}
{"id": 14560, "text": "a RuntimeException occurred while getting the descriptor.", "labels": []}
{"id": 14561, "text": "Wraps an IllegalArgumentException for invalid descriptor.", "labels": []}
{"id": 14562, "text": "if the combination of arguments is invalid", "labels": []}
{"id": 14563, "text": "if unable to convert to an ZonedDateTime", "labels": []}
{"id": 14564, "text": "if the adjustment cannot be made", "labels": []}
{"id": 14565, "text": "if the amount cannot be calculated, or the end temporal cannot be converted to a ZonedDateTime", "labels": []}
{"id": 14566, "text": "if the elements in c are not Comparable, or are not mutually comparable", "labels": []}
{"id": 14567, "text": "if the specified object cannot be compared with the elements currently in the set", "labels": []}
{"id": 14568, "text": "if the specified element is null and this set uses natural ordering, or its comparator does not permit null elements", "labels": []}
{"id": 14569, "text": "if the specified object cannot be compared with the elements currently in this set", "labels": []}
{"id": 14570, "text": "if an I/O exception occurs while creating the MulticastSocket", "labels": []}
{"id": 14571, "text": "if an I/O exception occurs while setting the default time-to-live value", "labels": []}
{"id": 14572, "text": "if there is an error joining, or when the address is not a multicast address, or the platform does not support multicasting", "labels": []}
{"id": 14573, "text": "if a security manager exists and its checkMulticast method doesn't allow the join.", "labels": []}
{"id": 14574, "text": "if there is an error leaving or when the address is not a multicast address.", "labels": []}
{"id": 14575, "text": "if a security manager exists and its checkMulticast method doesn't allow the operation.", "labels": []}
{"id": 14576, "text": "if mcastaddr is null or is a SocketAddress subclass not supported by this socket", "labels": []}
{"id": 14577, "text": "if an error occurs while setting the value", "labels": []}
{"id": 14578, "text": "if a security manager exists and the caller does not have ManagementPermission(\"control\").", "labels": []}
{"id": 14579, "text": "if no Provider supports a SecureRandomSpi implementation for the specified algorithm", "labels": []}
{"id": 14580, "text": "if a SecureRandomSpi implementation for the specified algorithm is not available from the specified provider", "labels": []}
{"id": 14581, "text": "if a SecureRandomSpi implementation for the specified algorithm is not available from the specified Provider object", "labels": []}
{"id": 14582, "text": "if the specified params is null", "labels": []}
{"id": 14583, "text": "if no Provider supports a SecureRandomSpi implementation for the specified algorithm and parameters", "labels": []}
{"id": 14584, "text": "if the provider name is null or empty, or params is null", "labels": []}
{"id": 14585, "text": "if the specified provider does not support a SecureRandomSpi implementation for the specified algorithm and parameters", "labels": []}
{"id": 14586, "text": "if the specified provider or params is null", "labels": []}
{"id": 14587, "text": "if numBytes is negative", "labels": []}
{"id": 14588, "text": "if no algorithm is available", "labels": []}
{"id": 14589, "text": "if the underlying provider implementation has not overridden this method.", "labels": []}
{"id": 14590, "text": "if params is null, illegal or unsupported by this SecureRandom", "labels": []}
{"id": 14591, "text": "if offset or length is less than zero, or offset+length is greater than the length of the data array.", "labels": []}
{"id": 14592, "text": "if an I/O error occurs when sending or receiving", "labels": []}
{"id": 14593, "text": "if the operation is interrupted", "labels": []}
{"id": 14594, "text": "if the request argument is not a request that could have been validly built as specified by HttpRequest.Builder.", "labels": []}
{"id": 14595, "text": "If a security manager has been installed and it denies access to the URL in the given request, or proxy if one is configured.", "labels": []}
{"id": 14596, "text": "if an error occurs when trying to resolve the URI.", "labels": []}
{"id": 14597, "text": "if the same name is used for two roles.", "labels": []}
{"id": 14598, "text": "if any of the required parameters (relation id, relation service ObjectName, or relation type name) is null.", "labels": []}
{"id": 14599, "text": "if any of the required parameters (relation id, relation service ObjectName, relation service MBeanServer, or relation type name) is null.", "labels": []}
{"id": 14600, "text": "if null role name", "labels": []}
{"id": 14601, "text": "if null role", "labels": []}
{"id": 14602, "text": "if there is no role with the supplied role's name or if the role is not writable (no test on the write access mode performed when initializing the role)", "labels": []}
{"id": 14603, "text": "if value provided for role is not valid, i.e.", "labels": []}
{"id": 14604, "text": "if the relation type has not been declared in the Relation Service", "labels": []}
{"id": 14605, "text": "if the relation has not been added in the Relation Service.", "labels": []}
{"id": 14606, "text": "if null role list", "labels": []}
{"id": 14607, "text": "if the relation type has not been declared in the Relation Service.", "labels": []}
{"id": 14608, "text": "if the relation MBean has not been added in the Relation Service.", "labels": []}
{"id": 14609, "text": "if role does not exist in the relation or is not writable", "labels": []}
{"id": 14610, "text": "if role value does not conform to the associated role info (this will never happen when called from the Relation Service)", "labels": []}
{"id": 14611, "text": "if this method is called for a relation MBean not added in the Relation Service.", "labels": []}
{"id": 14612, "text": "if the two method types do not match", "labels": []}
{"id": 14613, "text": "if the switchPoints array reference is null or the array contains a null", "labels": []}
{"id": 14614, "text": "if an image with the specified capabilities cannot be created", "labels": []}
{"id": 14615, "text": "if p is null", "labels": []}
{"id": 14616, "text": "if id is not one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS", "labels": []}
{"id": 14617, "text": "if a null ResultSet object is supplied or this CachedRowSet object cannot retrieve the associated ResultSetMetaData object", "labels": []}
{"id": 14618, "text": "if an invalid Connection object is supplied or an error occurs in establishing the connection to the data source", "labels": []}
{"id": 14619, "text": "if the underlying synchronization provider's writer fails to write the updates back to the data source", "labels": []}
{"id": 14620, "text": "if an error occurs rolling back the current value of this CachedRowSet object to its previous value", "labels": []}
{"id": 14621, "text": "if an error occurs flushing the contents of this CachedRowSet object", "labels": []}
{"id": 14622, "text": "if (1) the current row has not been deleted or (2) the cursor is on the insert row, before the first row, or after the last row", "labels": []}
{"id": 14623, "text": "if (1) the current row has not been inserted or (2) the cursor is before the first row, after the last row, or on the insert row", "labels": []}
{"id": 14624, "text": "if the cursor is before the first row or after the last row in this CachedRowSet object", "labels": []}
{"id": 14625, "text": "if the cursor is on the insert row, before the first row, or after the last row", "labels": []}
{"id": 14626, "text": "if an error occurs generating the collection", "labels": []}
{"id": 14627, "text": "if an error occurs generating the collection or an invalid column id is provided", "labels": []}
{"id": 14628, "text": "if an error occurs while returning the SyncProvider object", "labels": []}
{"id": 14629, "text": "if an error occurs while attempting to reset the SyncProvider implementation", "labels": []}
{"id": 14630, "text": "if invalid metadata is supplied to the rowset", "labels": []}
{"id": 14631, "text": "if an error occurs producing the ResultSet object", "labels": []}
{"id": 14632, "text": "if there is no current row", "labels": []}
{"id": 14633, "text": "if there is no current row or an error is encountered resetting the contents of the original row", "labels": []}
{"id": 14634, "text": "if an error is encountered returning the table name", "labels": []}
{"id": 14635, "text": "if an error is encountered naming the table or tabName is null", "labels": []}
{"id": 14636, "text": "if any of the numbers in the given array are not valid for this rowset", "labels": []}
{"id": 14637, "text": "if an error occurs or cloning is not supported in the underlying platform", "labels": []}
{"id": 14638, "text": "if an error occurs in generating the copy of the of this CachedRowSet object", "labels": []}
{"id": 14639, "text": "if an error occurs in cloning the structure of this CachedRowSet object", "labels": []}
{"id": 14640, "text": "if this method is called on a closed RowSet", "labels": []}
{"id": 14641, "text": "if a rowset implementation is unable to to determine whether rows marked for deletion are visible", "labels": []}
{"id": 14642, "text": "if a database access error occurs or this Connection object within this CachedRowSet is in auto-commit mode", "labels": []}
{"id": 14643, "text": "if a database access error occurs or this Connection object within this CachedRowSet is in auto-commit mode.", "labels": []}
{"id": 14644, "text": "if an error occurs setting the CachedRowSet page size or if the page size is less than 0.", "labels": []}
{"id": 14645, "text": "if an error occurs fetching the next page, or if this method is called prematurely before populate or execute.", "labels": []}
{"id": 14646, "text": "if an error occurs fetching the previous page, or if this method is called prematurely before populate or execute.", "labels": []}
{"id": 14647, "text": "if a security manager exists and its checkPermission method doesn't allow reassigning of the standard input stream.", "labels": []}
{"id": 14648, "text": "if a security manager exists and its checkPermission method doesn't allow reassigning of the standard output stream.", "labels": []}
{"id": 14649, "text": "if a security manager exists and its checkPermission method doesn't allow reassigning of the standard error output stream.", "labels": []}
{"id": 14650, "text": "if the security manager has already been set and its checkPermission method doesn't allow it to be replaced", "labels": []}
{"id": 14651, "text": "if sm is non-null and a security manager is not allowed to be set dynamically", "labels": []}
{"id": 14652, "text": "if copying would cause access of data outside array bounds.", "labels": []}
{"id": 14653, "text": "if an element in the src array could not be stored into the dest array because of a type mismatch.", "labels": []}
{"id": 14654, "text": "if either src or dest is null.", "labels": []}
{"id": 14655, "text": "if a security manager exists and its checkPropertiesAccess method doesn't allow access to the system properties.", "labels": []}
{"id": 14656, "text": "if a security manager exists and its checkPropertyAccess method doesn't allow access to the specified system property.", "labels": []}
{"id": 14657, "text": "if a security manager exists and its checkPermission method doesn't allow setting of the specified property.", "labels": []}
{"id": 14658, "text": "if a security manager exists and its checkPermission method doesn't allow access to the environment variable name", "labels": []}
{"id": 14659, "text": "if a security manager exists and its checkPermission method doesn't allow access to the process environment", "labels": []}
{"id": 14660, "text": "if a security manager exists and its checkExit method doesn't allow exit with the specified status.", "labels": []}
{"id": 14661, "text": "Always throws an error when called.", "labels": []}
{"id": 14662, "text": "if calendarField is not the value of a Calendar field constant.", "labels": []}
{"id": 14663, "text": "if an unexpected exception occurs while validating the reference", "labels": []}
{"id": 14664, "text": "if the specified element is not an instance of class JobStateReason", "labels": []}
{"id": 14665, "text": "if the list contains elements that are not mutually comparable (for example, strings and integers).", "labels": []}
{"id": 14666, "text": "if the specified list's list-iterator does not support the set operation.", "labels": []}
{"id": 14667, "text": "(optional) if the implementation detects that the natural ordering of the list elements is found to violate the Comparable contract", "labels": []}
{"id": 14668, "text": "if the list contains elements that are not mutually comparable using the specified comparator.", "labels": []}
{"id": 14669, "text": "if the list contains elements that are not mutually comparable (for example, strings and integers), or the search key is not mutually comparable with the elements of the list.", "labels": []}
{"id": 14670, "text": "if the list contains elements that are not mutually comparable using the specified comparator, or the search key is not mutually comparable with the elements of the list using this comparator.", "labels": []}
{"id": 14671, "text": "if the specified list or its list-iterator does not support the set operation.", "labels": []}
{"id": 14672, "text": "if either i or j is out of range (i < 0 || i >= list.size() || j < 0 || j >= list.size()).", "labels": []}
{"id": 14673, "text": "if the destination list is too small to contain the entire source List.", "labels": []}
{"id": 14674, "text": "if the destination list's list-iterator does not support the set operation.", "labels": []}
{"id": 14675, "text": "if the collection contains elements that are not mutually comparable (for example, strings and integers).", "labels": []}
{"id": 14676, "text": "if the collection is empty.", "labels": []}
{"id": 14677, "text": "if the collection contains elements that are not mutually comparable using the specified comparator.", "labels": []}
{"id": 14678, "text": "if either collection is null.", "labels": []}
{"id": 14679, "text": "if one collection contains a null element and null is not an eligible element for the other collection.", "labels": []}
{"id": 14680, "text": "if one collection contains an element that is of a type which is ineligible for the other collection.", "labels": []}
{"id": 14681, "text": "if c does not support the add operation", "labels": []}
{"id": 14682, "text": "if elements contains one or more null values and c does not permit null elements, or if c or elements are null", "labels": []}
{"id": 14683, "text": "if some property of a value in elements prevents it from being added to c", "labels": []}
{"id": 14684, "text": "if map is not empty", "labels": []}
{"id": 14685, "text": "if the amount cannot be calculated, or the end temporal cannot be converted to the same type as this temporal", "labels": []}
{"id": 14686, "text": "if parentComponent does not have a valid parent", "labels": []}
{"id": 14687, "text": "if newType is not one of the legal values listed above", "labels": []}
{"id": 14688, "text": "if divisionType is not valid", "labels": []}
{"id": 14689, "text": "if path is not contained in getPaths", "labels": []}
{"id": 14690, "text": "if index is outside the range of getPaths", "labels": []}
{"id": 14691, "text": "INVALID_CHARACTER_ERR: Raised if the specified qualified name is not an XML name according to [XML 1.0].", "labels": []}
{"id": 14692, "text": "NAMESPACE_ERR: Raised if the qualifiedName is malformed.", "labels": []}
{"id": 14693, "text": "NOT_SUPPORTED_ERR: May be raised if the implementation does not support the feature \"XML\" and the language exposed through the Document does not support XML Namespaces (such as [HTML 4.01]).", "labels": []}
{"id": 14694, "text": "WRONG_DOCUMENT_ERR: Raised if doctype has already been used with a different document or was created from a different implementation.", "labels": []}
{"id": 14695, "text": "if the specified enum type has no constant with the specified name, or the specified class object does not represent an enum type", "labels": []}
{"id": 14696, "text": "if enumType or name is null", "labels": []}
{"id": 14697, "text": "if cb is null", "labels": []}
{"id": 14698, "text": "if cb is a read only buffer", "labels": []}
{"id": 14699, "text": "if cd does not represent a MemoryUsage with the attributes described above.", "labels": []}
{"id": 14700, "text": "WRONG_DOCUMENT_ERR: Raised if newAttr was created from a different document than the one that created the element.", "labels": []}
{"id": 14701, "text": "INUSE_ATTRIBUTE_ERR: Raised if newAttr is already an attribute of another Element object.", "labels": []}
{"id": 14702, "text": "The DOM user must explicitly clone Attr nodes to re-use them in other elements.", "labels": []}
{"id": 14703, "text": "NOT_FOUND_ERR: Raised if oldAttr is not an attribute of the element.", "labels": []}
{"id": 14704, "text": "INVALID_CHARACTER_ERR: Raised if the specified qualified name is not an XML name according to the XML version in use specified in the Document.xmlVersion attribute.", "labels": []}
{"id": 14705, "text": "NOT_FOUND_ERR: Raised if the specified node is not an attribute of this element.", "labels": []}
{"id": 14706, "text": "SERIALIZE_ERR: Raised if the LSSerializer was unable to serialize the node.", "labels": []}
{"id": 14707, "text": "DOM applications should attach a DOMErrorHandler using the parameter \"error-handler\" if they wish to get details on the error.", "labels": []}
{"id": 14708, "text": "DOMSTRING_SIZE_ERR: Raised if the resulting string is too long to fit in a DOMString.", "labels": []}
{"id": 14709, "text": "if support is null", "labels": []}
{"id": 14710, "text": "if the transform is non-invertible.", "labels": []}
{"id": 14711, "text": "if src and dst are the same", "labels": []}
{"id": 14712, "text": "if the image cannot be transformed because of a data-processing error that might be caused by an invalid image format, tile format, or image-processing operation, or any other unsupported operation.", "labels": []}
{"id": 14713, "text": "if the raster cannot be transformed because of a data-processing error that might be caused by an invalid image format, tile format, or image-processing operation, or any other unsupported operation.", "labels": []}
{"id": 14714, "text": "if the current thread cannot create a thread in the specified thread group.", "labels": []}
{"id": 14715, "text": "if the current thread cannot modify this thread group.", "labels": []}
{"id": 14716, "text": "if the current thread is not allowed to access this thread group.", "labels": []}
{"id": 14717, "text": "if checkAccess determines that the current thread cannot access this thread group", "labels": []}
{"id": 14718, "text": "if the current thread is not allowed to access this thread group or any of the threads in the thread group.", "labels": []}
{"id": 14719, "text": "if the thread group is not empty or if the thread group has already been destroyed.", "labels": []}
{"id": 14720, "text": "if trustedCert or attributes is null", "labels": []}
{"id": 14721, "text": "if terminalName is null", "labels": []}
{"id": 14722, "text": "if actions is an invalid actions specification", "labels": []}
{"id": 14723, "text": "if there was an I/O error while creating the reader", "labels": []}
{"id": 14724, "text": "if there was an I/O error while creating the input stream", "labels": []}
{"id": 14725, "text": "When the XMLReader recognizes the feature name but cannot determine its value at this time.", "labels": []}
{"id": 14726, "text": "When the XMLReader recognizes the feature name but cannot set the requested value.", "labels": []}
{"id": 14727, "text": "When the XMLReader recognizes the property name but cannot set the requested value.", "labels": []}
{"id": 14728, "text": "An IO exception from the parser, possibly from a byte stream or character stream supplied by the application.", "labels": []}
{"id": 14729, "text": "if the parameter values do not specify a valid MIDI meta message", "labels": []}
{"id": 14730, "text": "if the requested secret key algorithm is not available", "labels": []}
{"id": 14731, "text": "if the shared secret key material cannot be used to generate a secret key of the requested algorithm type (e.g., the key material is too short)", "labels": []}
{"id": 14732, "text": "If there is not enough room in the pushback buffer for the byte, or this input stream has been closed by invoking its close() method.", "labels": []}
{"id": 14733, "text": "If there is not enough room in the pushback buffer for the specified number of bytes, or this input stream has been closed by invoking its close() method.", "labels": []}
{"id": 14734, "text": "if the stream has been closed by invoking its close() method, in.skip(n) throws an IOException, or an I/O error occurs.", "labels": []}
{"id": 14735, "text": "if this method is invoked.", "labels": []}
{"id": 14736, "text": "if bits is less than 1 or greater than 16", "labels": []}
{"id": 14737, "text": "if size is less than 1", "labels": []}
{"id": 14738, "text": "if transferType is not one of DataBuffer.TYPE_BYTE or DataBuffer.TYPE_USHORT", "labels": []}
{"id": 14739, "text": "if pixel is not large enough to hold a pixel value for this ColorModel", "labels": []}
{"id": 14740, "text": "if transferType is invalid", "labels": []}
{"id": 14741, "text": "if pixel is not large enough to hold a pixel value for this ColorModel or if the components array is not null and is not large enough to hold all the color and alpha components starting at offset", "labels": []}
{"id": 14742, "text": "if transferType is not one of the supported transfer types", "labels": []}
{"id": 14743, "text": "if the components array is not large enough to hold all of the color and alpha components starting at offset", "labels": []}
{"id": 14744, "text": "if pixel is not large enough to hold a pixel value for this ColorModel or the components array is not large enough to hold all of the color and alpha components starting at offset", "labels": []}
{"id": 14745, "text": "if the number of bits in a pixel is greater than 16", "labels": []}
{"id": 14746, "text": "if the raster argument is not compatible with this IndexColorModel", "labels": []}
{"id": 14747, "text": "if the index argument is negative or not less than length()", "labels": []}
{"id": 14748, "text": "if start or end are negative, if end is greater than length(), or if start is greater than end", "labels": []}
{"id": 14749, "text": "If this object is UNDERFLOW", "labels": []}
{"id": 14750, "text": "If this object is OVERFLOW", "labels": []}
{"id": 14751, "text": "If this object represents a malformed-input error; the exception's length value will be that of this object", "labels": []}
{"id": 14752, "text": "If this object represents an unmappable-character error; the exceptions length value will be that of this object", "labels": []}
{"id": 14753, "text": "if the startMonth, startDay, startDayOfWeek, or startTime parameters are out of range", "labels": []}
{"id": 14754, "text": "if the endMonth, endDay, endDayOfWeek, or endTime parameters are out of range", "labels": []}
{"id": 14755, "text": "when unable to launch.", "labels": []}
{"id": 14756, "text": "when the VM was successfully launched, but terminated with an error before a connection could be established.", "labels": []}
{"id": 14757, "text": "if the specified permission is not permitted, based on the current security policy and the context encapsulated by this object.", "labels": []}
{"id": 14758, "text": "if the permission to check for is null.", "labels": []}
{"id": 14759, "text": "if the parent is null", "labels": []}
{"id": 14760, "text": "if this PopupMenu has a non-Component parent", "labels": []}
{"id": 14761, "text": "if the origin is not in the parent's hierarchy", "labels": []}
{"id": 14762, "text": "if the parent is not showing on screen", "labels": []}
{"id": 14763, "text": "if cause is this exception.", "labels": []}
{"id": 14764, "text": "if this method has already been called on this exception.", "labels": []}
{"id": 14765, "text": "if the key does not conform to this TabularData instance's * TabularType definition", "labels": []}
{"id": 14766, "text": "if the index for value, calculated according to this TabularData instance's TabularType definition already maps to an existing value in the underlying HashMap.", "labels": []}
{"id": 14767, "text": "if an element of values does not conform to this TabularData instance's row type definition", "labels": []}
{"id": 14768, "text": "if the index for an element of values, calculated according to this TabularData instance's TabularType definition already maps to an existing value in this instance, or two elements of values have the same index.", "labels": []}
{"id": 14769, "text": "if there is already a pending step request for the specified thread.", "labels": []}
{"id": 14770, "text": "if the size or depth arguments contain illegal values.", "labels": []}
{"id": 14771, "text": "if location is within a native method.", "labels": []}
{"id": 14772, "text": "(a runtime exception) if the layered pane parameter is null", "labels": []}
{"id": 14773, "text": "if the result exceeds the supported range, or if the nano-of-second is invalid", "labels": []}
{"id": 14774, "text": "if the amount cannot be calculated, or the end temporal cannot be converted to a LocalDateTime", "labels": []}
{"id": 14775, "text": "The attribute name parameter is null.", "labels": []}
{"id": 14776, "text": "if any of the arguments is null, has more than 4 elements, or if the numbers of DC and AC tables differ.", "labels": []}
{"id": 14777, "text": "if one of the following holds: corePoolSize < 0 keepAliveTime < 0 maximumPoolSize <= 0 maximumPoolSize < corePoolSize", "labels": []}
{"id": 14778, "text": "if workQueue is null", "labels": []}
{"id": 14779, "text": "at discretion of RejectedExecutionHandler, if the task cannot be accepted for execution", "labels": []}
{"id": 14780, "text": "if corePoolSize < 0 or corePoolSize is greater than the maximum pool size", "labels": []}
{"id": 14781, "text": "if value is true and the current keep-alive time is not greater than zero", "labels": []}
{"id": 14782, "text": "if the new maximum is less than or equal to zero, or less than the core pool size", "labels": []}
{"id": 14783, "text": "if time less than zero or if time is zero and allowsCoreThreadTimeOut", "labels": []}
{"id": 14784, "text": "if sequence is null", "labels": []}
{"id": 14785, "text": "if the specified field is out of range (field < 0 || field >= FIELD_COUNT).", "labels": []}
{"id": 14786, "text": "if field or style is invalid, or if this Calendar is non-lenient and any of the calendar fields have invalid values", "labels": []}
{"id": 14787, "text": "if any week year numbering isn't supported in this Calendar.", "labels": []}
{"id": 14788, "text": "if any of the given date specifiers is invalid or any of the calendar fields are inconsistent with the given date specifiers in non-lenient mode", "labels": []}
{"id": 14789, "text": "If the source parameter is not a unicast address or is not the same address type as the multicast group", "labels": []}
{"id": 14790, "text": "If this membership key is source-specific or is no longer valid", "labels": []}
{"id": 14791, "text": "If the underlying operating system does not support source filtering", "labels": []}
{"id": 14792, "text": "if the precision section is out of range or of incorrect format", "labels": []}
{"id": 14793, "text": "if the mode argument is not equal to one of \"r\", \"rw\", \"rws\", or \"rwd\"", "labels": []}
{"id": 14794, "text": "if the mode is \"r\" but the given string does not denote an existing regular file, or if the mode begins with \"rw\" but the given string does not denote an existing, writable regular file and a new regular file of that name cannot be created, or if some other error occurs while opening or creating the file", "labels": []}
{"id": 14795, "text": "if a security manager exists and its checkRead method denies read access to the file or the mode is \"rw\" and the security manager's checkWrite method denies write access to the file", "labels": []}
{"id": 14796, "text": "if the mode is \"r\" but the given file object does not denote an existing regular file, or if the mode begins with \"rw\" but the given file object does not denote an existing, writable regular file and a new regular file of that name cannot be created, or if some other error occurs while opening or creating the file", "labels": []}
{"id": 14797, "text": "Not thrown if end-of-file has been reached.", "labels": []}
{"id": 14798, "text": "if this file reaches the end before reading all the bytes.", "labels": []}
{"id": 14799, "text": "if off is negative, len is negative, or len is greater than b.length - off.", "labels": []}
{"id": 14800, "text": "if pos is less than 0 or if an I/O error occurs.", "labels": []}
{"id": 14801, "text": "if this file has reached the end.", "labels": []}
{"id": 14802, "text": "if this file reaches the end before reading two bytes.", "labels": []}
{"id": 14803, "text": "if this file reaches the end before reading four bytes.", "labels": []}
{"id": 14804, "text": "if this file reaches the end before reading eight bytes.", "labels": []}
{"id": 14805, "text": "if the bytes do not represent valid modified UTF-8 encoding of a Unicode string.", "labels": []}
{"id": 14806, "text": "if the signing fails.", "labels": []}
{"id": 14807, "text": "if the key is not supported by this implementation.", "labels": []}
{"id": 14808, "text": "if access to the guarded object is denied.", "labels": []}
{"id": 14809, "text": "if either the URIs are not absolute or do not have a URL protocol handler for the URI scheme", "labels": []}
{"id": 14810, "text": "If an error occurs while parsing the catalog", "labels": []}
{"id": 14811, "text": "if access to the resource is denied by the security manager", "labels": []}
{"id": 14812, "text": "containing the following major error codes: GSSException.DEFECTIVE_TOKEN, GSSException.BAD_MIC, GSSException.NO_CRED, GSSException.CREDENTIALS_EXPIRED, GSSException.BAD_BINDINGS, GSSException.OLD_TOKEN, GSSException.DUPLICATE_TOKEN, GSSException.BAD_NAMETYPE, GSSException.BAD_MECH, GSSException.FAILURE", "labels": []}
{"id": 14813, "text": "containing the following major error codes: GSSException.DEFECTIVE_TOKEN, GSSException.BAD_MIC, GSSException.NO_CRED, GSSException.CREDENTIALS_EXPIRED, GSSException.BAD_BINDINGS, GSSException.OLD_TOKEN, GSSException.DUPLICATE_TOKEN, GSSException.BAD_MECH, GSSException.FAILURE", "labels": []}
{"id": 14814, "text": "containing the following major error codes: GSSException.CONTEXT_EXPIRED, GSSException.BAD_QOP, GSSException.FAILURE", "labels": []}
{"id": 14815, "text": "containing the following major error codes: GSSException.DEFECTIVE_TOKEN, GSSException.BAD_MIC, GSSException.CONTEXT_EXPIRED, GSSException.FAILURE", "labels": []}
{"id": 14816, "text": "containing the following major error codes: GSSException.DEFECTIVE_TOKEN GSSException.BAD_MIC GSSException.CONTEXT_EXPIRED GSSException.FAILURE", "labels": []}
{"id": 14817, "text": "containing the following major error codes: GSSException.UNAVAILABLE, GSSException.CONTEXT_EXPIRED, GSSException.NO_CONTEXT, GSSException.FAILURE", "labels": []}
{"id": 14818, "text": "if the result of the reduction is null", "labels": []}
{"id": 14819, "text": "if the element selected is null", "labels": []}
{"id": 14820, "text": "if the specified parameters are not understood by the ConfigurationSpi implementation from the selected Provider", "labels": []}
{"id": 14821, "text": "if no Provider supports a ConfigurationSpi implementation for the specified type", "labels": []}
{"id": 14822, "text": "if the caller does not have permission to get a Configuration instance for the specified type", "labels": []}
{"id": 14823, "text": "if the specified provider is null or empty, or if the specified parameters are not understood by the ConfigurationSpi implementation from the specified provider", "labels": []}
{"id": 14824, "text": "if the specified provider does not support a ConfigurationSpi implementation for the specified type", "labels": []}
{"id": 14825, "text": "if the specified Provider is null, or if the specified parameters are not understood by the ConfigurationSpi implementation from the specified Provider", "labels": []}
{"id": 14826, "text": "if the specified Provider does not support a ConfigurationSpi implementation for the specified type", "labels": []}
{"id": 14827, "text": "if the name of the algorithm passed is unsupported.", "labels": []}
{"id": 14828, "text": "If src or form is null.", "labels": []}
{"id": 14829, "text": "If the number of bands in the source or destination is incompatible with the matrix.", "labels": []}
{"id": 14830, "text": "If the number of bands in the source is incompatible with the matrix.", "labels": []}
{"id": 14831, "text": "if location is null", "labels": []}
{"id": 14832, "text": "if offsetBefore and offsetAfter are equal, or transition.getNano() returns non-zero value", "labels": []}
{"id": 14833, "text": "if the outputFile already exists, cannot be created, opened, or written to.", "labels": []}
{"id": 14834, "text": "if this operation is not supported.", "labels": []}
{"id": 14835, "text": "if outputFile does not end with \".hprof\" suffix.", "labels": []}
{"id": 14836, "text": "if outputFile is null.", "labels": []}
{"id": 14837, "text": "If a security manager exists and its SecurityManager.checkWrite(java.lang.String) method denies write access to the named file or the caller does not have ManagmentPermission(\"control\").", "labels": []}
{"id": 14838, "text": "if the parameter values do not specify a valid MIDI system exclusive message", "labels": []}
{"id": 14839, "text": "if component1, component2 or type is null", "labels": []}
{"id": 14840, "text": "if position is not one of SwingConstants.NORTH, SwingConstants.SOUTH, SwingConstants.EAST or SwingConstants.WEST", "labels": []}
{"id": 14841, "text": "INVALID_ACCESS_ERR: Raised if the attached property doesn't support the float value or the unit type.", "labels": []}
{"id": 14842, "text": "INVALID_ACCESS_ERR: Raised if the CSS value doesn't contain a float value or if the float value can't be converted into the specified unit.", "labels": []}
{"id": 14843, "text": "INVALID_ACCESS_ERR: Raised if the CSS value doesn't contain a string value or if the string value can't be converted into the specified unit.", "labels": []}
{"id": 14844, "text": "INVALID_ACCESS_ERR: Raised if the CSS value doesn't contain a string value.", "labels": []}
{"id": 14845, "text": "INVALID_ACCESS_ERR: Raised if the CSS value doesn't contain a Counter value (e.g.", "labels": []}
{"id": 14846, "text": "INVALID_ACCESS_ERR: Raised if the CSS value doesn't contain a Rect value.", "labels": []}
{"id": 14847, "text": "INVALID_ACCESS_ERR: Raised if the attached property can't return a RGB color value (e.g.", "labels": []}
{"id": 14848, "text": "if no more elements exist.", "labels": []}
{"id": 14849, "text": "if aContainer is not a focus cycle root of aComponent or a focus traversal policy provider, or if either aContainer or aComponent is null", "labels": []}
{"id": 14850, "text": "if pos represents an invalid location within the document.", "labels": []}
{"id": 14851, "text": "if this UndoManager is not in progress (end has been invoked)", "labels": []}
{"id": 14852, "text": "if one of the edits throws CannotUndoException", "labels": []}
{"id": 14853, "text": "if one of the edits throws CannotRedoException", "labels": []}
{"id": 14854, "text": "if one of the edits throws CannotUndoException or there are no edits to be undone", "labels": []}
{"id": 14855, "text": "if one of the edits throws CannotRedoException or there are no edits to be redone", "labels": []}
{"id": 14856, "text": "if in.skip(n) throws an IOException.", "labels": []}
{"id": 14857, "text": "if there was a failure attempting to resolve the resource.", "labels": []}
{"id": 14858, "text": "if this is called when hasNext() returns false", "labels": []}
{"id": 14859, "text": "if there is an error processing the underlying XML source", "labels": []}
{"id": 14860, "text": "if the required values are not matched.", "labels": []}
{"id": 14861, "text": "if the current event is not white space, PROCESSING_INSTRUCTION, START_ELEMENT or END_ELEMENT", "labels": []}
{"id": 14862, "text": "if there is a fatal error detecting the next state", "labels": []}
{"id": 14863, "text": "if the prefix is null", "labels": []}
{"id": 14864, "text": "if this is not a START_ELEMENT or ATTRIBUTE", "labels": []}
{"id": 14865, "text": "if this is not a START_ELEMENT, END_ELEMENT or NAMESPACE", "labels": []}
{"id": 14866, "text": "if this state is not a valid text state.", "labels": []}
{"id": 14867, "text": "if the underlying XML source is not well-formed", "labels": []}
{"id": 14868, "text": "if targetStart < 0 or > than the length of target", "labels": []}
{"id": 14869, "text": "if length < 0 or targetStart + length > length of target", "labels": []}
{"id": 14870, "text": "is if target is null", "labels": []}
{"id": 14871, "text": "if this not a START_ELEMENT, END_ELEMENT or ENTITY_REFERENCE", "labels": []}
{"id": 14872, "text": "if any thread has interrupted this thread.", "labels": []}
{"id": 14873, "text": "if currencyCode or locale is null", "labels": []}
{"id": 14874, "text": "if currencyCode is not in the form of three upper-case letters, or locale isn't one of the locales returned from getAvailableLocales().", "labels": []}
{"id": 14875, "text": "if a database access error occurs or this XmlWriter object is not the writer for the given WebRowSet object", "labels": []}
{"id": 14876, "text": "if we're interrupted while waiting for the event dispatching thread to finish executing doRun.run()", "labels": []}
{"id": 14877, "text": "if an exception is thrown while running doRun", "labels": []}
{"id": 14878, "text": "if viewport is null", "labels": []}
{"id": 14879, "text": "thrown if any argument is null.", "labels": []}
{"id": 14880, "text": "thrown if either argument is null.", "labels": []}
{"id": 14881, "text": "thrown if argument is null.", "labels": []}
{"id": 14882, "text": "if newLocale is null", "labels": []}
{"id": 14883, "text": "if category and/or newLocale is null", "labels": []}
{"id": 14884, "text": "if key is not well-formed", "labels": []}
{"id": 14885, "text": "if the key is not well-formed", "labels": []}
{"id": 14886, "text": "if languageTag is null", "labels": []}
{"id": 14887, "text": "Throws MissingResourceException if three-letter language abbreviation is not available for this locale.", "labels": []}
{"id": 14888, "text": "Throws MissingResourceException if the three-letter country abbreviation is not available for this locale.", "labels": []}
{"id": 14889, "text": "if inLocale is null", "labels": []}
{"id": 14890, "text": "if priorityList or locales is null", "labels": []}
{"id": 14891, "text": "if one or more extended language ranges are included in the given list when Locale.FilteringMode.REJECT_EXTENDED_RANGES is specified", "labels": []}
{"id": 14892, "text": "if priorityList or tags is null", "labels": []}
{"id": 14893, "text": "if the new size is negative", "labels": []}
{"id": 14894, "text": "if the specified index is greater than or equal to the current size of this vector", "labels": []}
{"id": 14895, "text": "if the index is out of range (index < 0 || index >= size())", "labels": []}
{"id": 14896, "text": "if the runtime type of a, <T>, is not a supertype of the runtime type, <E>, of every element in this Vector", "labels": []}
{"id": 14897, "text": "if the types of one or more elements in this vector are incompatible with the specified collection (optional)", "labels": []}
{"id": 14898, "text": "if this vector contains one or more null elements and the specified collection does not support null elements (optional), or if the specified collection is null", "labels": []}
{"id": 14899, "text": "if unable to create the date", "labels": []}
{"id": 14900, "text": "if the era is not a JapaneseEra", "labels": []}
{"id": 14901, "text": "if eraValue is invalid", "labels": []}
{"id": 14902, "text": "passed upward if encountered when reading the object stream.", "labels": []}
{"id": 14903, "text": "if type is null.", "labels": []}
{"id": 14904, "text": "if im is null.", "labels": []}
{"id": 14905, "text": "if an error occurs during loading, or initialization of the writer class, or during instantiation or initialization of the writer object.", "labels": []}
{"id": 14906, "text": "if the attempt to instantiate the writer fails.", "labels": []}
{"id": 14907, "text": "if the ImageWriter's constructor throws an IllegalArgumentException to indicate that the extension object is unsuitable.", "labels": []}
{"id": 14908, "text": "if the length of data is less than the product of width and height", "labels": []}
{"id": 14909, "text": "if data is less than the size of this Kernel", "labels": []}
{"id": 14910, "text": "if eventClass is an abstract class", "labels": []}
{"id": 14911, "text": "if the class is annotated with Registered(false), but not manually registered", "labels": []}
{"id": 14912, "text": "if we are in an invalid location within the document.", "labels": []}
{"id": 14913, "text": "if I/O error occured.", "labels": []}
{"id": 14914, "text": "if the type of the specified element is incompatible with this set (optional)", "labels": []}
{"id": 14915, "text": "if the specified element is null and this set does not permit null elements (optional)", "labels": []}
{"id": 14916, "text": "if the runtime type of the specified array is not a supertype of the runtime type of every element in this set", "labels": []}
{"id": 14917, "text": "if the add operation is not supported by this set", "labels": []}
{"id": 14918, "text": "if the class of the specified element prevents it from being added to this set", "labels": []}
{"id": 14919, "text": "if the specified element is null and this set does not permit null elements", "labels": []}
{"id": 14920, "text": "if some property of the specified element prevents it from being added to this set", "labels": []}
{"id": 14921, "text": "if the remove operation is not supported by this set", "labels": []}
{"id": 14922, "text": "if the types of one or more elements in the specified collection are incompatible with this set (optional)", "labels": []}
{"id": 14923, "text": "if the specified collection contains one or more null elements and this set does not permit null elements (optional), or if the specified collection is null", "labels": []}
{"id": 14924, "text": "if the addAll operation is not supported by this set", "labels": []}
{"id": 14925, "text": "if the class of an element of the specified collection prevents it from being added to this set", "labels": []}
{"id": 14926, "text": "if the specified collection contains one or more null elements and this set does not permit null elements, or if the specified collection is null", "labels": []}
{"id": 14927, "text": "if some property of an element of the specified collection prevents it from being added to this set", "labels": []}
{"id": 14928, "text": "if the retainAll operation is not supported by this set", "labels": []}
{"id": 14929, "text": "if this set contains a null element and the specified collection does not permit null elements (optional), or if the specified collection is null", "labels": []}
{"id": 14930, "text": "if the removeAll operation is not supported by this set", "labels": []}
{"id": 14931, "text": "if the clear method is not supported by this set", "labels": []}
{"id": 14932, "text": "if no mapping is found and javax.xml.catalog.resolve is specified as strict", "labels": []}
{"id": 14933, "text": "if a security manager exists and its checkPermission method denies access.", "labels": []}
{"id": 14934, "text": "if estimateDepth <= 0", "labels": []}
{"id": 14935, "text": "if this StackWalker is not configured with Option.RETAIN_CLASS_REFERENCE.", "labels": []}
{"id": 14936, "text": "if there is no caller frame, i.e.", "labels": []}
{"id": 14937, "text": "when this getCallerClass method is called from a method which is the last frame on the stack.", "labels": []}
{"id": 14938, "text": "if canWriteTiles returns false.", "labels": []}
{"id": 14939, "text": "if mode is not one of the modes listed above.", "labels": []}
{"id": 14940, "text": "if the plug-in does not support tiling.", "labels": []}
{"id": 14941, "text": "if the tiling mode is not MODE_EXPLICIT.", "labels": []}
{"id": 14942, "text": "if the plug-in does not support grid offsets, and the grid offsets are not both zero.", "labels": []}
{"id": 14943, "text": "if the tile size is not within one of the allowable ranges returned by getPreferredTileSizes.", "labels": []}
{"id": 14944, "text": "if tileWidth or tileHeight is less than or equal to 0.", "labels": []}
{"id": 14945, "text": "if the tiling parameters have not been set.", "labels": []}
{"id": 14946, "text": "if the writer does not support progressive encoding.", "labels": []}
{"id": 14947, "text": "if the writer does not support compression, or does not support the requested mode.", "labels": []}
{"id": 14948, "text": "if the writer does not support compression.", "labels": []}
{"id": 14949, "text": "if there are no settable compression types.", "labels": []}
{"id": 14950, "text": "if compressionType is non-null but is not one of the values returned by getCompressionTypes.", "labels": []}
{"id": 14951, "text": "if the plug-in does not support compression.", "labels": []}
{"id": 14952, "text": "if no compression type is set.", "labels": []}
{"id": 14953, "text": "if the set of legal compression types is non-null and the current compression type is null.", "labels": []}
{"id": 14954, "text": "if quality is not between 0 and 1, inclusive.", "labels": []}
{"id": 14955, "text": "if str is null", "labels": []}
{"id": 14956, "text": "if there are no more tokens in this tokenizer's string.", "labels": []}
{"id": 14957, "text": "if delim is null", "labels": []}
{"id": 14958, "text": "If a problem was encountered while adding the listener.", "labels": []}
{"id": 14959, "text": "if cd does not represent a MonitorInfo with the attributes described above.", "labels": []}
{"id": 14960, "text": "if the duration is negative, or has a part smaller than a whole millisecond such that the whole duration is not divisible into one second", "labels": []}
{"id": 14961, "text": "if the duration is too large to be represented as nanos", "labels": []}
{"id": 14962, "text": "if the instant cannot be obtained, not thrown by most implementations", "labels": []}
{"id": 14963, "text": "if an invalid column index is set", "labels": []}
{"id": 14964, "text": "if an invalid column name is set, the column name is a null, or the column name is an empty string", "labels": []}
{"id": 14965, "text": "if an invalid column index is designated or if the designated column was not previously set as a match column", "labels": []}
{"id": 14966, "text": "if an invalid column name is designated or the designated column was not previously set as a match column", "labels": []}
{"id": 14967, "text": "if all the given providers fail, the exception that occurred on the first attempt to create the execution engine.", "labels": []}
{"id": 14968, "text": "if the job could not be successfully cancelled", "labels": []}
{"id": 14969, "text": "if the chooser panel has already been installed", "labels": []}
{"id": 14970, "text": "if an I/O error occurs or the ACL is invalid", "labels": []}
{"id": 14971, "text": "if the abort fails", "labels": []}
{"id": 14972, "text": "if the pipe is broken, unconnected, closed, or an I/O error occurs.", "labels": []}
{"id": 14973, "text": "if the pipe is broken, unconnected, or closed.", "labels": []}
{"id": 14974, "text": "An I/O error occurs", "labels": []}
{"id": 14975, "text": "If the implementation requires to access the file, and a security manager is installed, and it denies an unspecified permission required by a file system provider implementation.", "labels": []}
{"id": 14976, "text": "If the file reference is associated with the default file system provider then the SecurityManager.checkRead(String) method is invoked to check read access to the file.", "labels": []}
{"id": 14977, "text": "if an error occurs during formatting", "labels": []}
{"id": 14978, "text": "if unable to parse the requested result", "labels": []}
{"id": 14979, "text": "if the position is invalid", "labels": []}
{"id": 14980, "text": "if less than 2 types are specified", "labels": []}
{"id": 14981, "text": "if some problem occurs during parsing", "labels": []}
{"id": 14982, "text": "if the action is null", "labels": []}
{"id": 14983, "text": "if action or perms or any element of perms is null", "labels": []}
{"id": 14984, "text": "if the specified action's run method threw a checked exception", "labels": []}
{"id": 14985, "text": "if the specified permission is not permitted, based on the current security policy.", "labels": []}
{"id": 14986, "text": "if the specified permission is null and is checked based on the security policy currently in effect.", "labels": []}
{"id": 14987, "text": "if no Provider supports a CertPathBuilderSpi implementation for the specified algorithm", "labels": []}
{"id": 14988, "text": "if a CertPathBuilderSpi implementation for the specified algorithm is not available from the specified provider", "labels": []}
{"id": 14989, "text": "if a CertPathBuilderSpi implementation for the specified algorithm is not available from the specified Provider object", "labels": []}
{"id": 14990, "text": "if the specified element cannot be compared with the elements currently in the set", "labels": []}
{"id": 14991, "text": "if fromElement and toElement cannot be compared to one another using this set's comparator (or, if the set has no comparator, using natural ordering).", "labels": []}
{"id": 14992, "text": "Implementations may, but are not required to, throw this exception if fromElement or toElement cannot be compared to elements currently in the set.", "labels": []}
{"id": 14993, "text": "if fromElement or toElement is null and this set does not permit null elements", "labels": []}
{"id": 14994, "text": "if fromElement is greater than toElement; or if this set itself has a restricted range, and fromElement or toElement lies outside the bounds of the range.", "labels": []}
{"id": 14995, "text": "if toElement is not compatible with this set's comparator (or, if the set has no comparator, if toElement does not implement Comparable).", "labels": []}
{"id": 14996, "text": "Implementations may, but are not required to, throw this exception if toElement cannot be compared to elements currently in the set.", "labels": []}
{"id": 14997, "text": "if toElement is null and this set does not permit null elements", "labels": []}
{"id": 14998, "text": "if this set itself has a restricted range, and toElement lies outside the bounds of the range", "labels": []}
{"id": 14999, "text": "if fromElement is not compatible with this set's comparator (or, if the set has no comparator, if fromElement does not implement Comparable).", "labels": []}
{"id": 15000, "text": "Implementations may, but are not required to, throw this exception if fromElement cannot be compared to elements currently in the set.", "labels": []}
{"id": 15001, "text": "if fromElement is null and this set does not permit null elements", "labels": []}
{"id": 15002, "text": "if this set itself has a restricted range, and fromElement lies outside the bounds of the range", "labels": []}
{"id": 15003, "text": "if fromElement is greater than toElement; or if this set itself has a restricted range, and fromElement or toElement lies outside the bounds of the range", "labels": []}
{"id": 15004, "text": "if there is no remedy", "labels": []}
{"id": 15005, "text": "if a definition for one of the named interfaces could not be found at the specified location, or if creation of the dynamic proxy class failed (such as if Proxy.getProxyClass(ClassLoader,Class[]) would throw an IllegalArgumentException for the given interface list)", "labels": []}
{"id": 15006, "text": "if languageCode or locale is null", "labels": []}
{"id": 15007, "text": "if languageCode is not in the form of two or three lower-case letters, or locale isn't one of the locales returned from getAvailableLocales().", "labels": []}
{"id": 15008, "text": "if scriptCode or locale is null", "labels": []}
{"id": 15009, "text": "if scriptCode is not in the form of four title case letters, or locale isn't one of the locales returned from getAvailableLocales().", "labels": []}
{"id": 15010, "text": "if countryCode or locale is null", "labels": []}
{"id": 15011, "text": "if countryCode is not in the form of two upper-case letters or three digit letters, or locale isn't one of the locales returned from getAvailableLocales().", "labels": []}
{"id": 15012, "text": "if variant or locale is null", "labels": []}
{"id": 15013, "text": "if key or locale is null", "labels": []}
{"id": 15014, "text": "if key, type or locale is null", "labels": []}
{"id": 15015, "text": "If args cannot be evaluated with this XPath function.", "labels": []}
{"id": 15016, "text": "if the name is null", "labels": []}
{"id": 15017, "text": "if the name is improperly specified", "labels": []}
{"id": 15018, "text": "if name or keywordMap is null", "labels": []}
{"id": 15019, "text": "if the name is improperly specified or a keyword in the name maps to an OID that is not in the correct form", "labels": []}
{"id": 15020, "text": "if the InputStream is null", "labels": []}
{"id": 15021, "text": "if the specified format is invalid or null", "labels": []}
{"id": 15022, "text": "if the specified format is invalid, null, or an OID in the name maps to an improperly specified keyword", "labels": ["NullnessNotAllowed", "Ambiguous"]}
{"id": 15023, "text": "if oidMap is null", "labels": []}
{"id": 15024, "text": "INVALID_STATE_ERR: Raised if the LSParser.busy attribute is true.", "labels": ["Dependent"]}
{"id": 15025, "text": "PARSE_ERR: Raised if the LSParser was unable to load the XML document.", "labels": []}
{"id": 15026, "text": "HIERARCHY_REQUEST_ERR: Raised if the content cannot replace, be inserted before, after, or as a child of the context node (see also Node.insertBefore or Node.replaceChild in [DOM Level 3 Core] ).", "labels": []}
{"id": 15027, "text": "NOT_SUPPORTED_ERR: Raised if the LSParser doesn't support this method, or if the context node is of type Document and the DOM implementation doesn't support the replacement of the DocumentType child or Element child.", "labels": []}
{"id": 15028, "text": "NO_MODIFICATION_ALLOWED_ERR: Raised if the context node is a read only node and the content is being appended to its child list, or if the parent node of the context node is read only node and the content is being inserted in its child list.", "labels": []}
{"id": 15029, "text": "PARSE_ERR: Raised if the LSParser was unable to load the XML fragment.", "labels": []}
{"id": 15030, "text": "If address is not bound to the channel's socket.", "labels": []}
{"id": 15031, "text": "or the channel has only one address bound to it", "labels": []}
{"id": 15032, "text": "If a security manager has been installed and it does not permit access to the given remote peer", "labels": []}
{"id": 15033, "text": "If streamNumner is negative or greater than or equal to the maximum number of outgoing streams", "labels": []}
{"id": 15034, "text": "if the content length is non-positive", "labels": []}
{"id": 15035, "text": "if the path is not found", "labels": []}
{"id": 15036, "text": "if a security manager has been installed and it denies read access to the given file", "labels": []}
{"id": 15037, "text": "if the RMI socket factory is already set", "labels": []}
{"id": 15038, "text": "If str is null", "labels": []}
{"id": 15039, "text": "If the given string violates RFC 2396, as augmented by the above deviations", "labels": []}
{"id": 15040, "text": "If both a scheme and a path are given but the path is relative, if the URI string constructed from the given components violates RFC 2396, or if the authority component of the string is present but cannot be parsed as a server-based authority", "labels": []}
{"id": 15041, "text": "If the URI string constructed from the given components violates RFC 2396", "labels": []}
{"id": 15042, "text": "If the given string violates RFC 2396", "labels": []}
{"id": 15043, "text": "If the authority component of this URI is defined but cannot be parsed as a server-based authority according to RFC 2396", "labels": []}
{"id": 15044, "text": "If uri is null", "labels": []}
{"id": 15045, "text": "If this URL is not absolute", "labels": []}
{"id": 15046, "text": "If a protocol handler for the URL could not be found, or if some other error occurred while constructing the URL", "labels": []}
{"id": 15047, "text": "If the given object is not a URI", "labels": []}
{"id": 15048, "text": "if direction is not one of NORTH, SOUTH, EAST or WEST", "labels": []}
{"id": 15049, "text": "if a database access error occurs or this method invokes the RowSet.execute method", "labels": []}
{"id": 15050, "text": "if font is null", "labels": []}
{"id": 15051, "text": "if isHeadless() returns true", "labels": []}
{"id": 15052, "text": "If the Source is an XML artifact that the implementation cannot validate (for example, a processing instruction).", "labels": []}
{"id": 15053, "text": "If the ErrorHandler throws a SAXException or if a fatal error is found and the ErrorHandler returns normally.", "labels": []}
{"id": 15054, "text": "If the validator is processing a SAXSource and the underlying XMLReader throws an IOException.", "labels": []}
{"id": 15055, "text": "If source is null.", "labels": []}
{"id": 15056, "text": "If the Result type doesn't match the Source type or if the Source is an XML artifact that the implementation cannot validate (for example, a processing instruction).", "labels": []}
{"id": 15057, "text": "If the source parameter is null.", "labels": []}
{"id": 15058, "text": "When the Validator recognizes the feature name but cannot determine its value at this time.", "labels": []}
{"id": 15059, "text": "When the name parameter is null.", "labels": []}
{"id": 15060, "text": "When the Validator recognizes the feature name but cannot set the requested value.", "labels": []}
{"id": 15061, "text": "When the Validator recognizes the property name but cannot set the requested value.", "labels": []}
{"id": 15062, "text": "If a security manager exists and its checkCreateClassLoader method doesn't allow creation of a new class loader.", "labels": []}
{"id": 15063, "text": "If the class could not be found", "labels": []}
{"id": 15064, "text": "If registered as parallel capable and className is null", "labels": []}
{"id": 15065, "text": "If the data did not contain a valid class", "labels": []}
{"id": 15066, "text": "If either off or len is negative, or if off+len is greater than b.length.", "labels": []}
{"id": 15067, "text": "If an attempt is made to add this class to a package that contains classes that were signed by a different set of certificates than this class (which is unsigned), or if name begins with \"java.", "labels": []}
{"id": 15068, "text": "If name is not null and not equal to the binary name of the class specified by b", "labels": []}
{"id": 15069, "text": "If an attempt is made to add this class to a package that contains classes that were signed by a different set of certificates than this class, or if name begins with \"java.\"", "labels": []}
{"id": 15070, "text": "If the data did not contain a valid class.", "labels": []}
{"id": 15071, "text": "If an attempt is made to add this class to a package that contains classes that were signed by a different set of certificates than this class, or if name begins with \"java.", "labels": []}
{"id": 15072, "text": "If c is null.", "labels": []}
{"id": 15073, "text": "If I/O errors occur", "labels": []}
{"id": 15074, "text": "If a security manager is present, and the caller's class loader is not null and is not an ancestor of this class loader, and the caller does not have the RuntimePermission(\"getClassLoader\")", "labels": []}
{"id": 15075, "text": "If a security manager is present, and the caller's class loader is not null and is not the same as or an ancestor of the system class loader, and the caller does not have the RuntimePermission(\"getClassLoader\")", "labels": []}
{"id": 15076, "text": "If invoked recursively during the construction of the class loader specified by the \"java.system.class.loader\" property.", "labels": []}
{"id": 15077, "text": "If the system property \"java.system.class.loader\" is defined but the named class could not be loaded, the provider class does not define the required constructor, or an exception is thrown by that constructor when it is invoked.", "labels": []}
{"id": 15078, "text": "The underlying cause of the error can be retrieved via the Throwable.getCause() method.", "labels": []}
{"id": 15079, "text": "if a package of the given name is already defined by this class loader", "labels": []}
{"id": 15080, "text": "if s or charset is null", "labels": []}
{"id": 15081, "text": "if the implementation encounters illegal characters", "labels": []}
{"id": 15082, "text": "if there is no current input method available or the current input method does not support the enabling/disabling operation", "labels": []}
{"id": 15083, "text": "if there is no current input method available or the current input method does not support checking whether it is enabled for composition", "labels": []}
{"id": 15084, "text": "if there is no current input method available or the current input method does not support the reconversion operation.", "labels": []}
{"id": 15085, "text": "if event is null", "labels": []}
{"id": 15086, "text": "if client is null", "labels": []}
{"id": 15087, "text": "if point or location is null", "labels": []}
{"id": 15088, "text": "if location or point is null", "labels": []}
{"id": 15089, "text": "if len is negative.", "labels": []}
{"id": 15090, "text": "if buf is null.", "labels": []}
{"id": 15091, "text": "if the end of the stream is reached.", "labels": []}
{"id": 15092, "text": "if the stream reaches the end before reading all the bytes.", "labels": []}
{"id": 15093, "text": "if this stream reaches the end before reading all the bytes.", "labels": []}
{"id": 15094, "text": "if the bytes do not represent a valid modified UTF-8 encoding of a string.", "labels": []}
{"id": 15095, "text": "if the stream reaches the end before reading all the bits.", "labels": []}
{"id": 15096, "text": "if the default receiver is not available due to resource restrictions, or no device providing receivers is installed in the system", "labels": []}
{"id": 15097, "text": "if the default transmitter is not available due to resource restrictions, or no device providing transmitters is installed in the system", "labels": []}
{"id": 15098, "text": "if the synthesizer is not available due to resource restrictions, or no synthesizer is installed in the system", "labels": []}
{"id": 15099, "text": "if the sequencer is not available due to resource restrictions, or there is no Receiver available by any installed MidiDevice, or no sequencer is installed in the system", "labels": []}
{"id": 15100, "text": "if the sequencer is not available due to resource restrictions, or no sequencer is installed in the system, or if connected is true, and there is no Receiver available by any installed MidiDevice", "labels": []}
{"id": 15101, "text": "if the stream does not point to valid MIDI soundbank data recognized by the system", "labels": []}
{"id": 15102, "text": "if an I/O error occurred when loading the soundbank", "labels": []}
{"id": 15103, "text": "if the URL does not point to valid MIDI soundbank data recognized by the system", "labels": []}
{"id": 15104, "text": "if the File does not point to valid MIDI soundbank data recognized by the system", "labels": []}
{"id": 15105, "text": "if the stream does not point to valid MIDI file data recognized by the system", "labels": []}
{"id": 15106, "text": "if an I/O exception occurs while accessing the stream", "labels": []}
{"id": 15107, "text": "if the URL does not point to valid MIDI file data recognized by the system", "labels": []}
{"id": 15108, "text": "if an I/O exception occurs while accessing the URL", "labels": []}
{"id": 15109, "text": "if the File does not point to valid MIDI file data recognized by the system", "labels": []}
{"id": 15110, "text": "if an I/O exception occurs while accessing the file", "labels": []}
{"id": 15111, "text": "if the SQLOutputImpl object is in use by a SQLData object attempting to write the attribute values of a UDT to the database.", "labels": []}
{"id": 15112, "text": "if this channel has been closed or if the corresponding Card has been disconnected.", "labels": []}
{"id": 15113, "text": "if the APDU encodes a MANAGE CHANNEL command", "labels": []}
{"id": 15114, "text": "if the card operation failed", "labels": []}
{"id": 15115, "text": "if command or response is null", "labels": []}
{"id": 15116, "text": "if the response buffer is read-only", "labels": []}
{"id": 15117, "text": "if command and response are the same object, if response may not have sufficient space to receive the response APDU or if the APDU encodes a MANAGE CHANNEL command", "labels": []}
{"id": 15118, "text": "if this CardChannel represents a connection the basic logical channel", "labels": []}
{"id": 15119, "text": "if the serverNames contains null element", "labels": []}
{"id": 15120, "text": "if the serverNames contains more than one name of the same name type", "labels": []}
{"id": 15121, "text": "if the matchers contains null element", "labels": []}
{"id": 15122, "text": "if the matchers contains more than one name of the same name type", "labels": []}
{"id": 15123, "text": "if protocols is null, or if any element in a non-empty array is null or an empty (zero-length) string", "labels": []}
{"id": 15124, "text": "if dataType is not one of the supported data types", "labels": []}
{"id": 15125, "text": "if nThreads <= 0", "labels": []}
{"id": 15126, "text": "if threadFactory is null", "labels": []}
{"id": 15127, "text": "if corePoolSize < 0", "labels": []}
{"id": 15128, "text": "if executor null", "labels": []}
{"id": 15129, "text": "if the current access control context does not have permission to both get and set context class loader", "labels": []}
{"id": 15130, "text": "if task null", "labels": []}
{"id": 15131, "text": "if action null", "labels": []}
{"id": 15132, "text": "if callable null", "labels": []}
{"id": 15133, "text": "if the current access control context does not have permission to both set and get context class loader", "labels": []}
{"id": 15134, "text": "If returnType is not one of the types defined in XPathConstants.", "labels": []}
{"id": 15135, "text": "If returnType is null.", "labels": []}
{"id": 15136, "text": "If source or returnType is null.", "labels": []}
{"id": 15137, "text": "If type is not of the types corresponding to the types defined in the XPathResultType, or XPathEvaluationResult is specified as the type but an implementation supporting the ANY type is not available.", "labels": []}
{"id": 15138, "text": "If type is null.", "labels": []}
{"id": 15139, "text": "when attempting to set this after any context has been pushed.", "labels": []}
{"id": 15140, "text": "if called for a non-off-screen image.", "labels": []}
{"id": 15141, "text": "if the property name is null.", "labels": []}
{"id": 15142, "text": "if width or height is zero.", "labels": []}
{"id": 15143, "text": "if priority is less than zero or greater than 1.", "labels": []}
{"id": 15144, "text": "if numEntries is less than 0", "labels": []}
{"id": 15145, "text": "if beginGlyphIndex is less than 0", "labels": []}
{"id": 15146, "text": "if the sum of beginGlyphIndex and numEntries is greater than the number of glyphs in this GlyphVector", "labels": []}
{"id": 15147, "text": "if glyphIndex is less than 0 or greater than the number of glyphs in this GlyphVector", "labels": []}
{"id": 15148, "text": "if glyphIndex is less than 0 or greater than or equal to the number of glyphs in this GlyphVector", "labels": []}
{"id": 15149, "text": "if the sum of beginGlyphIndex and numEntries is greater than the number of glyphs in this GlyphVector plus one", "labels": []}
{"id": 15150, "text": "if the class extending the BaseRowSet abstract class does not implement the RowSet interface or one of it's sub-interfaces.", "labels": []}
{"id": 15151, "text": "if an empty string is provided as the command value", "labels": []}
{"id": 15152, "text": "if an error occurs retrieving the URL value", "labels": []}
{"id": 15153, "text": "if an error occurs setting the Url property or the parameter supplied is a string with a length of 0 (an empty string)", "labels": []}
{"id": 15154, "text": "if an empty string is provided as the DataSource name", "labels": []}
{"id": 15155, "text": "if the given parameter is not one of the Connection constants", "labels": []}
{"id": 15156, "text": "if an error occurs internally determining the maximum limit of the column size", "labels": []}
{"id": 15157, "text": "if (1) an error occurs internally setting the maximum limit of the column size or (2) a size of less than 0 is set", "labels": []}
{"id": 15158, "text": "if an error occurs internally determining the maximum limit of rows that a Rowset object can contain", "labels": []}
{"id": 15159, "text": "if an error occurs internally setting the maximum limit on the number of rows that a JDBC RowSet object can contain; or if max is less than 0; or if max is less than the fetchSize of the RowSet", "labels": []}
{"id": 15160, "text": "if an error occurs setting the underlying JDBC technology-enabled driver to process the escape syntax", "labels": []}
{"id": 15161, "text": "if an error occurs in determining the query time-out value", "labels": []}
{"id": 15162, "text": "if an error occurs setting the query time-out or if the query time-out value is less than 0", "labels": []}
{"id": 15163, "text": "if an error occurs determining if deleted rows are visible or not", "labels": []}
{"id": 15164, "text": "if an error occurs setting whether deleted rows are visible or not", "labels": []}
{"id": 15165, "text": "if an error occurs determining if escape processing is enabled or not or if the internal escape processing trigger has not been enabled", "labels": []}
{"id": 15166, "text": "if (1) the RowSet type is TYPE_FORWARD_ONLY and the given fetch direction is not FETCH_FORWARD or (2) the given fetch direction is not one of the following: ResultSet.FETCH_FORWARD, ResultSet.FETCH_REVERSE, or ResultSet.FETCH_UNKNOWN", "labels": []}
{"id": 15167, "text": "if the specified fetch size is less than 0 or more than the limit for the maximum number of rows", "labels": []}
{"id": 15168, "text": "if a database access error occurs or the given parameter index is out of bounds", "labels": []}
{"id": 15169, "text": "if an error occurs or the given parameter index is out of bounds", "labels": []}
{"id": 15170, "text": "if an error occurs or the parameter index is out of bounds", "labels": []}
{"id": 15171, "text": "if an error occurs, the parameter index is out of bounds, or when connected to a data source, the number of bytes the driver reads and sends to the database is not equal to the number of bytes specified in length", "labels": []}
{"id": 15172, "text": "if an error occurs the parameter index is out of bounds, or there is ambiguity in the implementation of the object being set", "labels": []}
{"id": 15173, "text": "if an error occurs; the parameter index is out of bounds or the Ref object is null; or the Ref object returns a null base type name.", "labels": []}
{"id": 15174, "text": "if an error occurs; the parameter index is out of bounds or the Clob is null", "labels": []}
{"id": 15175, "text": "if an error occurs; the parameter index is out of bounds or the ARRAY is null", "labels": []}
{"id": 15176, "text": "if an error occurs clearing the parameters", "labels": []}
{"id": 15177, "text": "if an error occurs retrieving the object array of parameters of this RowSet object or if not all parameters have been set", "labels": []}
{"id": 15178, "text": "if the driver does not support national character sets; if the driver can detect that a data conversion error could occur ; if a database access error occurs; or this method is called on a closed PreparedStatement", "labels": []}
{"id": 15179, "text": "if targetSqlType is a ARRAY, BLOB, CLOB, DATALINK, JAVA_OBJECT, NCHAR, NCLOB, NVARCHAR, LONGNVARCHAR, REF, ROWID, SQLXML or STRUCT data type and the JDBC driver does not support this data type", "labels": []}
{"id": 15180, "text": "if a database access error occurs, this method is called on a closed CallableStatement or if the given Object parameter is ambiguous", "labels": []}
{"id": 15181, "text": "if a database access error occurs, this method is called on a closed PreparedStatement, if parameterIndex does not correspond to a parameter marker in the SQL statement, if the length specified is less than zero or if the number of bytes in the InputStream does not match the specified length.", "labels": []}
{"id": 15182, "text": "if a database access error occurs, this method is called on a closed PreparedStatement or if parameterIndex does not correspond to a parameter marker in the SQL statement,", "labels": []}
{"id": 15183, "text": "if parameterIndex does not correspond to a parameter marker in the SQL statement, or if the length specified is less than zero; if the number of bytes in the InputStream does not match the specified length; if a database access error occurs or this method is called on a closed CallableStatement", "labels": []}
{"id": 15184, "text": "if a database access error occurs, this method is called on a closed PreparedStatement, if parameterIndex does not correspond to a parameter marker in the SQL statement, or if the length specified is less than zero.", "labels": []}
{"id": 15185, "text": "if a database access error occurs, this method is called on a closed PreparedStatementor if parameterIndex does not correspond to a parameter marker in the SQL statement", "labels": []}
{"id": 15186, "text": "if parameterIndex does not correspond to a parameter marker in the SQL statement; if the length specified is less than zero; a database access error occurs or this method is called on a closed CallableStatement", "labels": []}
{"id": 15187, "text": "if a database access error occurs, this method is called on a closed result set, the java.xml.transform.Result, Writer or OutputStream has not been closed for the SQLXML object or if there is an error processing the XML value.", "labels": []}
{"id": 15188, "text": "if the driver does not support national character sets; if the driver can detect that a data conversion error could occur ; or if a database access error occurs", "labels": []}
{"id": 15189, "text": "if the driver does not support national character sets; if the driver can detect that a data conversion error could occur ; if a database access error occurs; or this method is called on a closed CallableStatement", "labels": []}
{"id": 15190, "text": "if parameterIndex does not correspond to a parameter marker in the SQL statement; if the length specified is less than zero; if the driver does not support national character sets; if the driver can detect that a data conversion error could occur; if a database access error occurs or this method is called on a closed CallableStatement", "labels": []}
{"id": 15191, "text": "if the driver does not support national character sets; if the driver can detect that a data conversion error could occur; if a database access error occurs or this method is called on a closed CallableStatement", "labels": []}
{"id": 15192, "text": "if the current thread is interrupted while waiting", "labels": []}
{"id": 15193, "text": "if source or target is null.", "labels": []}
{"id": 15194, "text": "if this lock is not held", "labels": []}
{"id": 15195, "text": "if the given condition is not associated with this lock", "labels": []}
{"id": 15196, "text": "if either of the arguments were created with another file manager implementation", "labels": []}
{"id": 15197, "text": "if location is an output location and files does not contain exactly one element", "labels": []}
{"id": 15198, "text": "if location is an output location and does not represent an existing directory", "labels": []}
{"id": 15199, "text": "if location is an output location and paths does not contain exactly one element or if this file manager does not support any of the given paths", "labels": []}
{"id": 15200, "text": "if location is an output location and paths does not represent an existing directory", "labels": []}
{"id": 15201, "text": "if the location is not a module-oriented or output location.", "labels": []}
{"id": 15202, "text": "if this operation is not supported by this file manager.", "labels": []}
{"id": 15203, "text": "if the file object does not have an underlying path", "labels": []}
{"id": 15204, "text": "if the operation is not supported by this file manager", "labels": []}
{"id": 15205, "text": "if rhs is null", "labels": []}
{"id": 15206, "text": "If the selector is closed", "labels": []}
{"id": 15207, "text": "If this channel is in blocking mode", "labels": []}
{"id": 15208, "text": "If this channel was not created by the same provider as the given selector", "labels": []}
{"id": 15209, "text": "If this channel is currently registered with the given selector but the corresponding key has already been cancelled", "labels": []}
{"id": 15210, "text": "If a bit in the ops set does not correspond to an operation that is supported by this channel, that is, if set & ~validOps() != 0", "labels": []}
{"id": 15211, "text": "If a bit in ops does not correspond to an operation that is supported by this channel, that is, if set & ~validOps() != 0", "labels": []}
{"id": 15212, "text": "If block is true and this channel is registered with one or more selectors", "labels": []}
{"id": 15213, "text": "if posn is outside the specified range", "labels": []}
{"id": 15214, "text": "if n is not a valid name, or if the addition of the components would violate the syntax rules of this name", "labels": []}
{"id": 15215, "text": "if adding comp would violate the syntax rules of this name", "labels": []}
{"id": 15216, "text": "if elem is a leaf", "labels": []}
{"id": 15217, "text": "if an HTMLEditorKit.Parser has not been defined", "labels": []}
{"id": 15218, "text": "if replacement is impossible because of a structural issue", "labels": []}
{"id": 15219, "text": "if an HTMLEditorKit.Parser has not been set", "labels": []}
{"id": 15220, "text": "if an HTMLEditorKit.Parser has not been set on the document", "labels": []}
{"id": 15221, "text": "if insertion is impossible because of a structural issue", "labels": []}
{"id": 15222, "text": "if linkers or any of its elements are null.", "labels": []}
{"id": 15223, "text": "if paramName is null", "labels": []}
{"id": 15224, "text": "if the timeout expires before the connection can be established", "labels": []}
{"id": 15225, "text": "if an I/O error occurs while opening the connection.", "labels": []}
{"id": 15226, "text": "if the timeout parameter is negative", "labels": []}
{"id": 15227, "text": "if an I/O error occurs while getting the content.", "labels": []}
{"id": 15228, "text": "if the protocol does not support the content type.", "labels": []}
{"id": 15229, "text": "if the computation of the permission requires network or file I/O and an exception occurs while computing it.", "labels": []}
{"id": 15230, "text": "if an I/O error occurs while creating the input stream.", "labels": []}
{"id": 15231, "text": "if the protocol does not support input.", "labels": []}
{"id": 15232, "text": "if already connected", "labels": []}
{"id": 15233, "text": "if the factory has already been defined.", "labels": []}
{"id": 15234, "text": "if layout is not a ScrollPaneLayout", "labels": []}
{"id": 15235, "text": "if policy is not one of the legal values shown above", "labels": []}
{"id": 15236, "text": "if corner key is invalid", "labels": ["Ambiguous"]}
{"id": 15237, "text": "if the attribute is not an instance of interface PrintRequestAttribute", "labels": []}
{"id": 15238, "text": "if some element in the specified set is not an instance of interface PrintRequestAttribute", "labels": []}
{"id": 15239, "text": "if style is not one of: NONE, FRAME, PLAIN_DIALOG, INFORMATION_DIALOG, ERROR_DIALOG, COLOR_CHOOSER_DIALOG, FILE_CHOOSER_DIALOG, QUESTION_DIALOG, or WARNING_DIALOG.", "labels": []}
{"id": 15240, "text": "if the glass parameter is null", "labels": []}
{"id": 15241, "text": "if the amount cannot be calculated, or the end temporal cannot be converted to an Instant", "labels": []}
{"id": 15242, "text": "if otherInstant is null", "labels": []}
{"id": 15243, "text": "If a naming exception was encountered while creating the StartTLS extended response object.", "labels": []}
{"id": 15244, "text": "if there is not JapaneseEra with the specified name", "labels": []}
{"id": 15245, "text": "if the constraint is not a string.", "labels": []}
{"id": 15246, "text": "if the instant is too large to represent as a Timestamp", "labels": []}
{"id": 15247, "text": "if sourceRegion is non-null and either sourceRegion.x or sourceRegion.y is negative.", "labels": []}
{"id": 15248, "text": "if sourceRegion is non-null and either sourceRegion.width or sourceRegion.height is negative or 0.", "labels": []}
{"id": 15249, "text": "if subsampling is such that this region will have a subsampled width or height of zero.", "labels": []}
{"id": 15250, "text": "if either period is negative or 0, or if either grid offset is negative or greater than the corresponding period.", "labels": []}
{"id": 15251, "text": "if the source region is such that the subsampled output would contain no pixels.", "labels": []}
{"id": 15252, "text": "if sourceBands contains a negative or duplicate value.", "labels": []}
{"id": 15253, "text": "if destinationOffset is null.", "labels": []}
{"id": 15254, "text": "the exception additionally may implement an interface that more precisely describes the cause of the exception FlavorException.", "labels": []}
{"id": 15255, "text": "If the document has a flavor not supported by this print job.", "labels": []}
{"id": 15256, "text": "AttributeException.", "labels": []}
{"id": 15257, "text": "If one or more of the attributes are not valid for this print job.", "labels": []}
{"id": 15258, "text": "if the named file exists but is a directory rather than a regular file, does not exist but cannot be created, or cannot be opened for any other reason", "labels": []}
{"id": 15259, "text": "if window is null", "labels": []}
{"id": 15260, "text": "if doc can't be narrowed to a StyledDocument which is the required type of model for this text component", "labels": []}
{"id": 15261, "text": "if the request is denied by the security manager or this is a constructor for java.lang.Class", "labels": []}
{"id": 15262, "text": "if this Constructor object is enforcing Java language access control and the underlying constructor is inaccessible.", "labels": []}
{"id": 15263, "text": "if the number of actual and formal parameters differ; if an unwrapping conversion for primitive arguments fails; or if, after possible unwrapping, a parameter value cannot be converted to the corresponding formal parameter type by a method invocation conversion; if this constructor pertains to an enum type.", "labels": []}
{"id": 15264, "text": "if the class that declares the underlying constructor represents an abstract class.", "labels": []}
{"id": 15265, "text": "if the underlying constructor throws an exception.", "labels": []}
{"id": 15266, "text": "if the addition of the specified BeanContext is refused.", "labels": []}
{"id": 15267, "text": "if fromIndex > toIndex", "labels": []}
{"id": 15268, "text": "if fromIndex < 0 or toIndex > a.length", "labels": []}
{"id": 15269, "text": "if the array contains elements that are not mutually comparable (for example, strings and integers)", "labels": []}
{"id": 15270, "text": "(optional) if the natural ordering of the array elements is found to violate the Comparable contract", "labels": []}
{"id": 15271, "text": "if fromIndex > toIndex or (optional) if the natural ordering of the array elements is found to violate the Comparable contract", "labels": []}
{"id": 15272, "text": "if the array contains elements that are not mutually comparable (for example, strings and integers).", "labels": []}
{"id": 15273, "text": "if the array contains elements that are not mutually comparable using the specified comparator", "labels": []}
{"id": 15274, "text": "if the array contains elements that are not mutually comparable using the specified comparator.", "labels": []}
{"id": 15275, "text": "if fromIndex > toIndex or (optional) if the comparator is found to violate the Comparator contract", "labels": []}
{"id": 15276, "text": "if the specified array or function is null", "labels": []}
{"id": 15277, "text": "if the search key is not comparable to the elements of the array.", "labels": []}
{"id": 15278, "text": "if the search key is not comparable to the elements of the array within the specified range.", "labels": []}
{"id": 15279, "text": "if the array contains elements that are not mutually comparable using the specified comparator, or the search key is not comparable to the elements of the array using this comparator.", "labels": []}
{"id": 15280, "text": "if the range contains elements that are not mutually comparable using the specified comparator, or the search key is not comparable to the elements in the range using this comparator.", "labels": []}
{"id": 15281, "text": "if aFromIndex > aToIndex or if bFromIndex > bToIndex", "labels": []}
{"id": 15282, "text": "if aFromIndex < 0 or aToIndex > a.length or if bFromIndex < 0 or bToIndex > b.length", "labels": []}
{"id": 15283, "text": "if either array is null", "labels": []}
{"id": 15284, "text": "if the comparator is null", "labels": []}
{"id": 15285, "text": "if either array or the comparator is null", "labels": []}
{"id": 15286, "text": "if the specified value is not of a runtime type that can be stored in the specified array", "labels": []}
{"id": 15287, "text": "if newLength is negative", "labels": []}
{"id": 15288, "text": "if original is null", "labels": []}
{"id": 15289, "text": "if an element copied from original is not of a runtime type that can be stored in an array of class newType", "labels": []}
{"id": 15290, "text": "if from < 0 or from > original.length", "labels": []}
{"id": 15291, "text": "if from > to", "labels": []}
{"id": 15292, "text": "if an element copied from original is not of a runtime type that can be stored in an array of class newType.", "labels": []}
{"id": 15293, "text": "if the generator is null", "labels": []}
{"id": 15294, "text": "if scope is invalid.", "labels": ["Ambiguous"]}
{"id": 15295, "text": "if the value of scope is ENGINE_SCOPE and the specified Bindings is null.", "labels": []}
{"id": 15296, "text": "if the value of scope is invalid.", "labels": ["Ambiguous"]}
{"id": 15297, "text": "if algName or encryptedData is null.", "labels": []}
{"id": 15298, "text": "if encryptedData is empty, i.e.", "labels": []}
{"id": 15299, "text": "if the specified algName is not supported.", "labels": []}
{"id": 15300, "text": "if a security manager exists and its checkPermission method doesn't allow setting the default authenticator.", "labels": []}
{"id": 15301, "text": "if a security manager exists and its checkPermission method doesn't allow requesting password authentication.", "labels": []}
{"id": 15302, "text": "if a security manager exists and its checkPermission method doesn't allow the password authentication request.", "labels": []}
{"id": 15303, "text": "if field is ZONE_OFFSET, DST_OFFSET, or unknown, or if any calendar fields have out-of-range values in non-lenient mode.", "labels": []}
{"id": 15304, "text": "if any of the calendar fields is invalid in non-lenient mode.", "labels": []}
{"id": 15305, "text": "if any of the given date specifiers is invalid, or if any of the calendar fields are inconsistent with the given date specifiers in non-lenient mode", "labels": []}
{"id": 15306, "text": "if zdt is null", "labels": []}
{"id": 15307, "text": "if the zoned date-time is too large to represent as a GregorianCalendar", "labels": []}
{"id": 15308, "text": "if the set operation is not supported by this list", "labels": []}
{"id": 15309, "text": "if delimiter is null", "labels": []}
{"id": 15310, "text": "if prefix, delimiter, or suffix is null", "labels": []}
{"id": 15311, "text": "when the emptyValue parameter is null", "labels": []}
{"id": 15312, "text": "if the other StringJoiner is null", "labels": []}
{"id": 15313, "text": "if this method is called before the connection has been established.", "labels": []}
{"id": 15314, "text": "if the peer was not verified", "labels": []}
{"id": 15315, "text": "if the HostnameVerifier parameter is null.", "labels": []}
{"id": 15316, "text": "if a security manager exists and its checkPermission method does not allow SSLPermission(\"setHostnameVerifier\")", "labels": []}
{"id": 15317, "text": "if the SSLSocketFactory parameter is null.", "labels": []}
{"id": 15318, "text": "if a security manager exists and its checkSetFactory method does not allow a socket factory to be specified.", "labels": []}
{"id": 15319, "text": "if this method is called before the connection has been established", "labels": []}
{"id": 15320, "text": "if no Provider supports a CertPathValidatorSpi implementation for the specified algorithm", "labels": []}
{"id": 15321, "text": "if a CertPathValidatorSpi implementation for the specified algorithm is not available from the specified provider", "labels": []}
{"id": 15322, "text": "if a CertPathValidatorSpi implementation for the specified algorithm is not available from the specified Provider object", "labels": []}
{"id": 15323, "text": "if obj is not a CompositeName.", "labels": []}
{"id": 15324, "text": "If n is not a composite name.", "labels": []}
{"id": 15325, "text": "if the timeout specified is < 0.", "labels": []}
{"id": 15326, "text": "if the preconditions on the offset and length parameters do not hold.", "labels": []}
{"id": 15327, "text": "if the dst buffer is read-only.", "labels": []}
{"id": 15328, "text": "if either srcs or dst is null, or if any element in the srcs subsequence specified is null.", "labels": []}
{"id": 15329, "text": "if the client/server mode has not yet been set.", "labels": []}
{"id": 15330, "text": "If the preconditions on the offset and length parameters do not hold.", "labels": []}
{"id": 15331, "text": "if any of the dst buffers are read-only.", "labels": []}
{"id": 15332, "text": "if either src or dsts is null, or if any element in the dsts subsequence specified is null.", "labels": []}
{"id": 15333, "text": "if this engine has not received the proper SSL/TLS/DTLS close notification message from the peer.", "labels": []}
{"id": 15334, "text": "if a problem was encountered while signaling the SSLEngine to begin a new handshake.", "labels": []}
{"id": 15335, "text": "if a security manager is present and it denies RuntimePermission(\"preferences\").", "labels": []}
{"id": 15336, "text": "(A null value for def is permitted.)", "labels": []}
{"id": 15337, "text": "if key.length() exceeds MAX_KEY_LENGTH.", "labels": []}
{"id": 15338, "text": "if key.length() exceeds MAX_KEY_LENGTH or if value.length exceeds MAX_VALUE_LENGTH*3/4.", "labels": []}
{"id": 15339, "text": "if path name is null.", "labels": []}
{"id": 15340, "text": "if this node (or an ancestor) has been removed with the removeNode() method and pathName is not the empty string (\"\").", "labels": []}
{"id": 15341, "text": "if pcl is null.", "labels": []}
{"id": 15342, "text": "if ncl is null.", "labels": []}
{"id": 15343, "text": "if preference data cannot be read from backing store.", "labels": []}
{"id": 15344, "text": "If a security manager is present and it denies RuntimePermission(\"preferences\").", "labels": []}
{"id": 15345, "text": "if a security manager has been installed and it denies JDIPermission (\"virtualMachineManager\") or other unspecified permissions required by the implementation.", "labels": []}
{"id": 15346, "text": "if callable or unit is null", "labels": []}
{"id": 15347, "text": "NOT_FOUND_ERR: Raised when the parameter name is not recognized.", "labels": []}
{"id": 15348, "text": "if the status byte or all data bytes belonging to the message do not specify a valid MIDI message", "labels": []}
{"id": 15349, "text": "if the command value, channel value or all data bytes belonging to the message do not specify a valid MIDI message", "labels": []}
{"id": 15350, "text": "if the status byte, or all data bytes belonging to the message, do not specify a valid MIDI message", "labels": []}
{"id": 15351, "text": "if the status byte or all data bytes belonging to the message, do not specify a valid MIDI message", "labels": []}
{"id": 15352, "text": "if a database access error occurs or this method is called on a closed Statement", "labels": []}
{"id": 15353, "text": "if a database access error occurs, this method is called on a closed Statement or the condition max >= 0 is not satisfied", "labels": []}
{"id": 15354, "text": "if a database access error occurs, this method is called on a closed Statement or the condition seconds >= 0 is not satisfied", "labels": []}
{"id": 15355, "text": "if a database access error occurs, this method is called on a closed Statement, the method is called on a PreparedStatement or CallableStatement", "labels": []}
{"id": 15356, "text": "if a database access error occurs, this method is called on a closed Statement or the given direction is not one of ResultSet.FETCH_FORWARD, ResultSet.FETCH_REVERSE, or ResultSet.FETCH_UNKNOWN", "labels": []}
{"id": 15357, "text": "if a database access error occurs, this method is called on a closed Statement or the condition rows >= 0 is not satisfied.", "labels": []}
{"id": 15358, "text": "if a database access error occurs, this method is called on a closed Statement or the driver does not support batch statements.", "labels": []}
{"id": 15359, "text": "Throws BatchUpdateException (a subclass of SQLException) if one of the commands sent to the database fails to execute properly or attempts to return a result set.", "labels": []}
{"id": 15360, "text": "if a database access error occurs, this method is called on a closed Statement or the argument supplied is not one of the following: Statement.CLOSE_CURRENT_RESULT, Statement.KEEP_CURRENT_RESULT or Statement.CLOSE_ALL_RESULTS", "labels": []}
{"id": 15361, "text": "if DatabaseMetaData.supportsMultipleOpenResults returns false and either Statement.KEEP_CURRENT_RESULT or Statement.CLOSE_ALL_RESULTS are supplied as the argument.", "labels": []}
{"id": 15362, "text": "if a database access error occurs, this method is called on a closed Statement, the given SQL statement returns a ResultSet object, the given constant is not one of those allowed, the method is called on a PreparedStatement or CallableStatement", "labels": []}
{"id": 15363, "text": "if the JDBC driver does not support this method with a constant of Statement.RETURN_GENERATED_KEYS", "labels": []}
{"id": 15364, "text": "if a database access error occurs, this method is called on a closed Statement, the SQL statement returns a ResultSet object,the second argument supplied to this method is not an int array whose elements are valid column indexes, the method is called on a PreparedStatement or CallableStatement", "labels": []}
{"id": 15365, "text": "if a database access error occurs, this method is called on a closed Statement, the SQL statement returns a ResultSet object, the second argument supplied to this method is not a String array whose elements are valid column names, the method is called on a PreparedStatement or CallableStatement", "labels": []}
{"id": 15366, "text": "if a database access error occurs, this method is called on a closed Statement, the second parameter supplied to this method is not Statement.RETURN_GENERATED_KEYS or Statement.NO_GENERATED_KEYS, the method is called on a PreparedStatement or CallableStatement", "labels": []}
{"id": 15367, "text": "if a database access error occurs, this method is called on a closed Statement, the elements in the int array passed to this method are not valid column indexes, the method is called on a PreparedStatement or CallableStatement", "labels": []}
{"id": 15368, "text": "if a database access error occurs, this method is called on a closed Statement,the elements of the String array passed to this method are not valid column names, the method is called on a PreparedStatement or CallableStatement", "labels": []}
{"id": 15369, "text": "if this method is called on a closed Statement", "labels": []}
{"id": 15370, "text": "if a database access error occurs, this method is called on a closed Statement, the given SQL statement produces a ResultSet object, the method is called on a PreparedStatement or CallableStatement", "labels": []}
{"id": 15371, "text": "if identifier is not a valid identifier", "labels": []}
{"id": 15372, "text": "if the datasource does not support delimited identifiers", "labels": []}
{"id": 15373, "text": "if identifier is null", "labels": []}
{"id": 15374, "text": "if no Provider supports a KeyGeneratorSpi implementation for the specified algorithm", "labels": []}
{"id": 15375, "text": "if a KeyGeneratorSpi implementation for the specified algorithm is not available from the specified provider", "labels": []}
{"id": 15376, "text": "if a KeyGeneratorSpi implementation for the specified algorithm is not available from the specified Provider object", "labels": []}
{"id": 15377, "text": "if the given parameters are inappropriate for this key generator", "labels": []}
{"id": 15378, "text": "if the keysize is wrong or not supported.", "labels": []}
{"id": 15379, "text": "if the requested data flavor is not equivalent to either DataFlavor.stringFlavor or DataFlavor.plainTextFlavor", "labels": []}
{"id": 15380, "text": "if an IOException occurs while retrieving the data.", "labels": []}
{"id": 15381, "text": "By default, StringSelection never throws this exception, but a subclass may.", "labels": []}
{"id": 15382, "text": "if the notion of full name does not apply to this binding in the naming system.", "labels": []}
{"id": 15383, "text": "If the path is associated with a provider that does not support creating file channels, or an unsupported open option is specified, or the array contains an attribute that cannot be set atomically when creating the file", "labels": []}
{"id": 15384, "text": "If the target channel was not opened for writing", "labels": []}
{"id": 15385, "text": "If either this channel or the target channel is closed", "labels": []}
{"id": 15386, "text": "If another thread closes either channel while the transfer is in progress", "labels": []}
{"id": 15387, "text": "If another thread interrupts the current thread while the transfer is in progress, thereby closing both channels and setting the current thread's interrupt status", "labels": []}
{"id": 15388, "text": "If the source channel was not opened for reading", "labels": []}
{"id": 15389, "text": "If either this channel or the source channel is closed", "labels": []}
{"id": 15390, "text": "If the mode is READ_ONLY but this channel was not opened for reading", "labels": []}
{"id": 15391, "text": "If the mode is READ_WRITE or PRIVATE but this channel was not opened for both reading and writing", "labels": []}
{"id": 15392, "text": "If another thread closes this channel while the invoking thread is blocked in this method", "labels": []}
{"id": 15393, "text": "If the invoking thread is interrupted while blocked in this method", "labels": []}
{"id": 15394, "text": "If a lock that overlaps the requested region is already held by this Java virtual machine, or if another thread is already blocked in this method and is attempting to lock an overlapping region", "labels": []}
{"id": 15395, "text": "If shared is true this channel was not opened for reading", "labels": []}
{"id": 15396, "text": "If the capacity is a negative integer", "labels": []}
{"id": 15397, "text": "If there are fewer than length bytes remaining in this buffer", "labels": []}
{"id": 15398, "text": "If there is insufficient space in this buffer for the remaining bytes in the source buffer", "labels": []}
{"id": 15399, "text": "If the index is negative or the unit size is not a power of 2", "labels": []}
{"id": 15400, "text": "If the native platform does not guarantee stable alignment offset values for the given unit size when managing the memory regions of buffers of the same kind as this buffer (direct or non-direct).", "labels": []}
{"id": 15401, "text": "For example, if garbage collection would result in the moving of a memory region covered by a non-direct buffer from one location to another and both locations have different alignment characteristics.", "labels": []}
{"id": 15402, "text": "If the unit size not a power of 2", "labels": []}
{"id": 15403, "text": "If the native platform does not guarantee stable aligned slices for the given unit size when managing the memory regions of buffers of the same kind as this buffer (direct or non-direct).", "labels": []}
{"id": 15404, "text": "If an accept operation is already in progress on this channel", "labels": []}
{"id": 15405, "text": "if a value for the unit cannot be obtained", "labels": []}
{"id": 15406, "text": "if an unknown protocol or the port is a negative number other than -1", "labels": []}
{"id": 15407, "text": "if an unknown protocol is specified.", "labels": []}
{"id": 15408, "text": "if a security manager exists and its checkPermission method doesn't allow specifying a stream handler explicitly.", "labels": []}
{"id": 15409, "text": "if no protocol is specified, or an unknown protocol is found, or spec is null, or the parsed URL fails to comply with the specific syntax of the associated protocol.", "labels": []}
{"id": 15410, "text": "if a security manager exists and its checkPermission method doesn't allow specifying a stream handler.", "labels": []}
{"id": 15411, "text": "if an I/O exception occurs.", "labels": []}
{"id": 15412, "text": "if a security manager is present and the caller doesn't have permission to connect to the proxy.", "labels": []}
{"id": 15413, "text": "will be thrown if proxy is null, or proxy has the wrong type", "labels": []}
{"id": 15414, "text": "if the subclass that implements the protocol handler doesn't support this method.", "labels": []}
{"id": 15415, "text": "if the application has already set a factory.", "labels": []}
{"id": 15416, "text": "if no Provider supports a KeyStoreSpi implementation for the specified type", "labels": []}
{"id": 15417, "text": "if a KeyStoreSpi implementation for the specified type is not available from the specified provider", "labels": []}
{"id": 15418, "text": "if KeyStoreSpi implementation for the specified type is not available from the specified Provider object", "labels": []}
{"id": 15419, "text": "if the keystore has not been initialized (loaded).", "labels": []}
{"id": 15420, "text": "if the keystore has not been initialized (loaded), the given key cannot be protected, or this operation fails for some other reason", "labels": []}
{"id": 15421, "text": "if the keystore has not been initialized (loaded), or if this operation fails for some other reason.", "labels": []}
{"id": 15422, "text": "if the keystore has not been initialized, or the given alias already exists and does not identify an entry containing a trusted certificate, or this operation fails for some other reason.", "labels": []}
{"id": 15423, "text": "if the given LoadStoreParameter input is not recognized", "labels": []}
{"id": 15424, "text": "if alias or entry is null", "labels": []}
{"id": 15425, "text": "if the keystore has not been initialized (loaded), or if this operation fails for some other reason", "labels": []}
{"id": 15426, "text": "if alias or entryClass is null", "labels": []}
{"id": 15427, "text": "if the keystore has not been initialized (loaded)", "labels": []}
{"id": 15428, "text": "if no Provider supports a KeyStoreSpi implementation for the specified keystore file.", "labels": []}
{"id": 15429, "text": "If the error is due to a wrong password, the cause of the IOException should be an UnrecoverableKeyException.", "labels": []}
{"id": 15430, "text": "if the algorithm used to check the integrity of the keystore cannot be found.", "labels": []}
{"id": 15431, "text": "if any of the certificates in the keystore could not be loaded.", "labels": []}
{"id": 15432, "text": "if file does not exist or does not refer to a normal file.", "labels": []}
{"id": 15433, "text": "if file is null.", "labels": []}
{"id": 15434, "text": "if a security manager exists and its SecurityManager.checkRead(java.io.FileDescriptor) method denies read access to the specified file.", "labels": []}
{"id": 15435, "text": "wrong password) the cause of the IOException should be an UnrecoverableKeyException.", "labels": []}
{"id": 15436, "text": "if file does not exist or does not refer to a normal file, or if param is not recognized.", "labels": []}
{"id": 15437, "text": "if type is not one of LayoutStyle.ComponentPlacement.RELATED or LayoutStyle.ComponentPlacement.UNRELATED", "labels": []}
{"id": 15438, "text": "if ds is null.", "labels": []}
{"id": 15439, "text": "if the time is null", "labels": []}
{"id": 15440, "text": "if the length of the specified extra field data is greater than 0xFFFF bytes", "labels": []}
{"id": 15441, "text": "the exception additionally may implement an interfaces which more precisely describes the cause of the exception FlavorException.", "labels": []}
{"id": 15442, "text": "if the target isn't the container specified to the constructor", "labels": []}
{"id": 15443, "text": "If the timeout wait is interrupted", "labels": []}
{"id": 15444, "text": "if the offset ID is invalid", "labels": []}
{"id": 15445, "text": "if the offset is not in the required range", "labels": []}
{"id": 15446, "text": "if the reference could not be created", "labels": []}
{"id": 15447, "text": "if the registry could not be exported", "labels": []}
{"id": 15448, "text": "if the info object specified does not match the info object for a mixer supported by this MixerProvider, or if this MixerProvider does not have default mixer, but default mixer has been requested", "labels": []}
{"id": 15449, "text": "if name is already bound", "labels": []}
{"id": 15450, "text": "if some \"mandatory\" attributes of the binding are not supplied", "labels": []}
{"id": 15451, "text": "if the name is already bound", "labels": []}
{"id": 15452, "text": "if attrs does not contain all the mandatory attributes required for creation", "labels": []}
{"id": 15453, "text": "if schema not supported", "labels": []}
{"id": 15454, "text": "if the search filter specified is not supported or understood by the underlying directory", "labels": []}
{"id": 15455, "text": "if the search controls contain invalid settings", "labels": []}
{"id": 15456, "text": "if filterExpr contains {i} expressions where i is outside the bounds of the array filterArgs", "labels": []}
{"id": 15457, "text": "if cons contains invalid settings", "labels": []}
{"id": 15458, "text": "if filterExpr with filterArgs represents an invalid search filter", "labels": []}
{"id": 15459, "text": "if an error occurs while attempting to access the type name", "labels": []}
{"id": 15460, "text": "if an error occurs while attempting to access the array", "labels": []}
{"id": 15461, "text": "if an error occurs releasing the Array's resources", "labels": []}
{"id": 15462, "text": "if reason is null or severity is null", "labels": []}
{"id": 15463, "text": "if reason is not an instance of class PrinterStateReason or if severity is not an instance of class Severity", "labels": []}
{"id": 15464, "text": "if severity is null", "labels": []}
{"id": 15465, "text": "In particular, an IOException may be thrown if the output stream has been closed.", "labels": []}
{"id": 15466, "text": "In particular, an IOException is thrown if the output stream is closed.", "labels": []}
{"id": 15467, "text": "If a factory has already been installed.", "labels": []}
{"id": 15468, "text": "if a naming exception was encountered while attempting to get a URL context, or if one of the factories accessed throws a NamingException.", "labels": []}
{"id": 15469, "text": "if one of the factories accessed throws an exception, or if an error was encountered while loading and instantiating the factory and object classes.", "labels": []}
{"id": 15470, "text": "A factory should only throw an exception if it does not want other factories to be used in an attempt to create an object.", "labels": []}
{"id": 15471, "text": "If a naming exception occurs while creating the context.", "labels": []}
{"id": 15472, "text": "If the Context.INITIAL_CONTEXT_FACTORY property is not found or names a nonexistent class or a class that cannot be instantiated, or if the initial context could not be created for some other reason.", "labels": []}
{"id": 15473, "text": "If some other naming exception was encountered.", "labels": []}
{"id": 15474, "text": "If a builder was previous installed.", "labels": []}
{"id": 15475, "text": "If a naming exception occurred.", "labels": []}
{"id": 15476, "text": "If one of the factories accessed throws an exception, or if an error was encountered while loading and instantiating the factory and object classes.", "labels": []}
{"id": 15477, "text": "if name or description are null or empty string, or openType is null.", "labels": []}
{"id": 15478, "text": "if the file argument is null", "labels": []}
{"id": 15479, "text": "if either of the arguments is null", "labels": []}
{"id": 15480, "text": "if princ is null", "labels": []}
{"id": 15481, "text": "if the principal argument is null", "labels": []}
{"id": 15482, "text": "if a security manager exists and the read access to the keytab file is not permitted", "labels": []}
{"id": 15483, "text": "if year parameter is outside value constraints for the field as specified in date/time field mapping table.", "labels": []}
{"id": 15484, "text": "if fractional parameter is outside value constraints for the field as specified in date/time field mapping table.", "labels": []}
{"id": 15485, "text": "if increment is less than or equal to zero", "labels": []}
{"id": 15486, "text": "if start is out of range, or if increment is less than or equal to zero", "labels": []}
{"id": 15487, "text": "thrown on illegal lock attempt.", "labels": []}
{"id": 15488, "text": "If the document is implemented properly, this can only happen if a document listener attempts to mutate the document.", "labels": []}
{"id": 15489, "text": "This situation violates the bean event model where order of delivery is not guaranteed and all listeners should be notified before further mutations are allowed.", "labels": []}
{"id": 15490, "text": "if any of the given compilation units are of other kind than source", "labels": []}
{"id": 15491, "text": "if the implementation has not overridden this method", "labels": []}
{"id": 15492, "text": "if params is illegal or unsupported by this SecureRandom", "labels": []}
{"id": 15493, "text": "if factory is null", "labels": []}
{"id": 15494, "text": "if contents is null", "labels": []}
{"id": 15495, "text": "If an error occurred while processing the challenge or generating a response.", "labels": []}
{"id": 15496, "text": "if a database access error occurs or the result set type is TYPE_FORWARD_ONLY", "labels": []}
{"id": 15497, "text": "if a security manager exists and its checkPermission method doesn't allow getting the Policy object.", "labels": []}
{"id": 15498, "text": "if the specified parameters are not understood by the PolicySpi implementation from the selected Provider", "labels": []}
{"id": 15499, "text": "if no Provider supports a PolicySpi implementation for the specified type", "labels": []}
{"id": 15500, "text": "if the caller does not have permission to get a Policy instance for the specified type.", "labels": []}
{"id": 15501, "text": "if the specified provider is null or empty, or if the specified parameters are not understood by the PolicySpi implementation from the specified provider", "labels": []}
{"id": 15502, "text": "if the specified provider does not support a PolicySpi implementation for the specified type", "labels": []}
{"id": 15503, "text": "if the caller does not have permission to get a Policy instance for the specified type", "labels": []}
{"id": 15504, "text": "if the specified Provider is null, or if the specified parameters are not understood by the PolicySpi implementation from the specified Provider", "labels": []}
{"id": 15505, "text": "if the specified Provider does not support a PolicySpi implementation for the specified type", "labels": []}
{"id": 15506, "text": "if the file does not exist, is a directory rather than a regular file, or for some other reason cannot be opened for reading.", "labels": []}
{"id": 15507, "text": "if a security manager exists and its checkRead method denies read access to the file.", "labels": []}
{"id": 15508, "text": "if a security manager exists and its checkRead method denies read access to the file descriptor.", "labels": []}
{"id": 15509, "text": "if n is negative, if the stream does not support seek, or if an I/O error occurs.", "labels": []}
{"id": 15510, "text": "if this file input stream has been closed by calling close or an I/O error occurs.", "labels": []}
{"id": 15511, "text": "if a parser cannot be created which satisfies the requested configuration.", "labels": []}
{"id": 15512, "text": "if this method is invoked", "labels": []}
{"id": 15513, "text": "if an error occurs writing out the rowset contents in XML format", "labels": []}
{"id": 15514, "text": "if a data source access error occurs", "labels": []}
{"id": 15515, "text": "if a IO exception occurs", "labels": []}
{"id": 15516, "text": "If the string does not contain a parsable byte.", "labels": []}
{"id": 15517, "text": "if the string does not contain a parsable byte.", "labels": []}
{"id": 15518, "text": "If the String does not contain a parsable byte.", "labels": []}
{"id": 15519, "text": "if alias is null", "labels": []}
{"id": 15520, "text": "if an error occurred during the operation", "labels": []}
{"id": 15521, "text": "if the getKeyStore method has not been invoked prior to calling this method", "labels": []}
{"id": 15522, "text": "if keyStore or protectionParameters is null", "labels": []}
{"id": 15523, "text": "if the keyStore has not been initialized", "labels": []}
{"id": 15524, "text": "if type, file or protection is null", "labels": []}
{"id": 15525, "text": "if protection is not an instance of either PasswordProtection or CallbackHandlerProtection; or if file does not exist or does not refer to a normal file", "labels": []}
{"id": 15526, "text": "if file or protection is null", "labels": []}
{"id": 15527, "text": "if type or protection is null", "labels": []}
{"id": 15528, "text": "if this Synthesizer doesn't support the specified instrument's soundbank", "labels": []}
{"id": 15529, "text": "if instrument from or instrument to aren't supported by synthesizer or if instrument to is not loaded", "labels": []}
{"id": 15530, "text": "if from or to parameters have null value", "labels": []}
{"id": 15531, "text": "if orientation is not one of VERTICAL, HORIZONTAL", "labels": []}
{"id": 15532, "text": "if cd does not represent a valid RecordingInfo", "labels": []}
{"id": 15533, "text": "if the implementation does not support this operation", "labels": []}
{"id": 15534, "text": "if the process is the current process", "labels": []}
{"id": 15535, "text": "if the specified object is not of same class as this object", "labels": []}
{"id": 15536, "text": "If the channel that was used to acquire this lock is no longer open", "labels": []}
{"id": 15537, "text": "if the name or actions is invalid.", "labels": []}
{"id": 15538, "text": "INVALID_CHARACTER_ERR: If the medium contains characters that are invalid in the underlying style language.", "labels": []}
{"id": 15539, "text": "NO_MODIFICATION_ALLOWED_ERR: Raised if this list is readonly.", "labels": []}
{"id": 15540, "text": "if name is empty", "labels": []}
{"id": 15541, "text": "if space is not a TYPE_RGB space or if the min/max normalized component values are not 0.0/1.0.", "labels": []}
{"id": 15542, "text": "if inData is not large enough to hold a pixel value for this color model", "labels": []}
{"id": 15543, "text": "if inData is not a primitive array of type transferType", "labels": []}
{"id": 15544, "text": "if this transferType is not supported by this color model", "labels": []}
{"id": 15545, "text": "if inData is not large enough to hold a pixel value for this ColorModel", "labels": []}
{"id": 15546, "text": "if this tranferType is not supported by this ColorModel", "labels": []}
{"id": 15547, "text": "if this transferType is not supported by this ColorModel", "labels": []}
{"id": 15548, "text": "if pixel is not large enough to hold a pixel value for this ColorModel, or if components is not null and is not large enough to hold all the color and alpha components, starting at offset", "labels": []}
{"id": 15549, "text": "if obj is not large enough to hold a pixel value for this ColorModel or the components array is not large enough to hold all of the color and alpha components starting at offset", "labels": []}
{"id": 15550, "text": "if an I/O error occurs when opening the socket.", "labels": []}
{"id": 15551, "text": "if a SecurityManager is present and its checkListen method doesn't allow the operation.", "labels": []}
{"id": 15552, "text": "if endpoint is a SocketAddress subclass not supported by this socket", "labels": []}
{"id": 15553, "text": "if an I/O error occurs when waiting for a connection.", "labels": []}
{"id": 15554, "text": "if a security manager exists and its checkAccept method doesn't allow the operation.", "labels": []}
{"id": 15555, "text": "if a timeout was previously set with setSoTimeout and the timeout has been reached.", "labels": []}
{"id": 15556, "text": "if this socket has an associated channel, the channel is in non-blocking mode, and there is no connection ready to be accepted", "labels": []}
{"id": 15557, "text": "if an I/O error occurs when closing the socket.", "labels": []}
{"id": 15558, "text": "if button is less than zero or greater than the number of button masks reserved for buttons", "labels": []}
{"id": 15559, "text": "if modeToDrop is not one of PUBLIC, MODULE, PACKAGE, PROTECTED, PRIVATE or UNCONDITIONAL", "labels": []}
{"id": 15560, "text": "if this lookup does not have PACKAGE access", "labels": []}
{"id": 15561, "text": "if the class is malformed (ClassFormatError), cannot be verified (VerifyError), is already defined, or another linkage error occurs", "labels": []}
{"id": 15562, "text": "if bytes is null", "labels": []}
{"id": 15563, "text": "if the method does not exist", "labels": []}
{"id": 15564, "text": "if access checking fails, or if the method is not static, or if the method's variable arity modifier bit is set and asVarargsCollector fails", "labels": []}
{"id": 15565, "text": "if a security manager is present and it refuses access", "labels": []}
{"id": 15566, "text": "if access checking fails, or if the method is static, or if the method's variable arity modifier bit is set and asVarargsCollector fails", "labels": []}
{"id": 15567, "text": "if the constructor does not exist", "labels": []}
{"id": 15568, "text": "if access checking fails or if the method's variable arity modifier bit is set and asVarargsCollector fails", "labels": []}
{"id": 15569, "text": "if the class cannot be loaded by the lookup class' loader.", "labels": []}
{"id": 15570, "text": "if the class is not accessible, using the allowed access modes.", "labels": []}
{"id": 15571, "text": "if the class is not accessible from the lookup class, using the allowed access modes.", "labels": []}
{"id": 15572, "text": "if the field does not exist", "labels": []}
{"id": 15573, "text": "if access checking fails, or if the field is static", "labels": []}
{"id": 15574, "text": "if access checking fails, or if the field is not static", "labels": []}
{"id": 15575, "text": "if access checking fails", "labels": []}
{"id": 15576, "text": "if the target is not a direct method handle or if access checking fails", "labels": []}
{"id": 15577, "text": "if the target is null", "labels": []}
{"id": 15578, "text": "containing the following major error codes: GSSException.BAD_MECH if the mechanism does not support this method, GSSException.UNAVAILABLE if the type specified is not supported, GSSException.NO_CONTEXT if the security context is invalid, GSSException.FAILURE for other unspecified failures.", "labels": []}
{"id": 15579, "text": "if a security manager exists and a proper InquireSecContextPermission is not granted.", "labels": []}
{"id": 15580, "text": "if direction doesn't have one of the legal values above", "labels": []}
{"id": 15581, "text": "if the collection is this queue", "labels": []}
{"id": 15582, "text": "if prompt is null, if prompt has a length of 0, if choices is null, if choices has a length of 0, if any element from choices is null, if any element from choices has a length of 0 or if defaultChoice does not fall within the array boundaries of choices.", "labels": []}
{"id": 15583, "text": "if this future was cancelled", "labels": []}
{"id": 15584, "text": "if this future completed exceptionally", "labels": []}
{"id": 15585, "text": "if this future completed exceptionally or a completion computation threw an exception", "labels": []}
{"id": 15586, "text": "if the array or any of its elements are null", "labels": []}
{"id": 15587, "text": "if the exception is null", "labels": []}
{"id": 15588, "text": "If cannot return controls due to an error.", "labels": []}
{"id": 15589, "text": "if this is not a drop", "labels": []}
{"id": 15590, "text": "if an invalid action is specified", "labels": []}
{"id": 15591, "text": "if uriReference is null", "labels": []}
{"id": 15592, "text": "thrown if the device cannot be opened due to resource restrictions", "labels": []}
{"id": 15593, "text": "thrown if the device cannot be opened due to security restrictions", "labels": []}
{"id": 15594, "text": "thrown if a receiver is not available due to resource restrictions", "labels": []}
{"id": 15595, "text": "thrown if a transmitter is not available due to resource restrictions", "labels": []}
{"id": 15596, "text": "if serviceURL is null.", "labels": []}
{"id": 15597, "text": "if the connector client or the connection cannot be made because of a communication problem.", "labels": []}
{"id": 15598, "text": "if the connection cannot be made for security reasons.", "labels": []}
{"id": 15599, "text": "if the method is inaccessible.", "labels": []}
{"id": 15600, "text": "if the getter is inaccessible.", "labels": []}
{"id": 15601, "text": "if the field is inaccessible.", "labels": []}
{"id": 15602, "text": "if the field does not exist.", "labels": []}
{"id": 15603, "text": "if the constructor is inaccessible.", "labels": []}
{"id": 15604, "text": "if the method does not exist.", "labels": []}
{"id": 15605, "text": "if the field is not static, the field is final, or the field does not exist in this class.", "labels": []}
{"id": 15606, "text": "if the field type has not yet been loaded through the appropriate class loader.", "labels": []}
{"id": 15607, "text": "if the value's type does not match the field's declared type.", "labels": []}
{"id": 15608, "text": "if the method is not a member of this class or a superclass, if the size of the argument list does not match the number of declared arguments for the method, or if the method is an initializer, constructor or static intializer.", "labels": []}
{"id": 15609, "text": "if the method is not a member of this class, if the size of the argument list does not match the number of declared arguments for the constructor, or if the method is not a constructor.", "labels": []}
{"id": 15610, "text": "if methods are not yet available because the class has not yet been prepared.", "labels": []}
{"id": 15611, "text": "if the minimal days value is less than one or greater than 7", "labels": []}
{"id": 15612, "text": "If the String does not contain a parsable short.", "labels": []}
{"id": 15613, "text": "If the string does not contain a parsable short.", "labels": []}
{"id": 15614, "text": "if alpha is less than 0.0 or greater than 1.0, or if rule is not one of the following: CLEAR, SRC, DST, SRC_OVER, DST_OVER, SRC_IN, DST_IN, SRC_OUT, DST_OUT, SRC_ATOP, DST_ATOP, or XOR", "labels": []}
{"id": 15615, "text": "if rule is not one of the following: CLEAR, SRC, DST, SRC_OVER, DST_OVER, SRC_IN, DST_IN, SRC_OUT, DST_OUT, SRC_ATOP, DST_ATOP, or XOR", "labels": []}
{"id": 15616, "text": "if alpha is less than 0.0 or greater than 1.0", "labels": []}
{"id": 15617, "text": "the invoke raised a user exception", "labels": []}
{"id": 15618, "text": "if the invoke() was canceled by stop()", "labels": []}
{"id": 15619, "text": "if value isn't allowed", "labels": []}
{"id": 15620, "text": "if this object is already forwarding to an MBeanServer object or if mbs is null or if mbs is identical to this object.", "labels": []}
{"id": 15621, "text": "if the stream is closed.", "labels": []}
{"id": 15622, "text": "if the stream has been closed.", "labels": []}
{"id": 15623, "text": "if this input method does not support the enabling/disabling operation", "labels": []}
{"id": 15624, "text": "if this input method does not support checking whether it is enabled for composition", "labels": []}
{"id": 15625, "text": "if the input method does not support the reconversion operation.", "labels": []}
{"id": 15626, "text": "if given a type for an executable, package, or module", "labels": []}
{"id": 15627, "text": "if kind is not valid", "labels": []}
{"id": 15628, "text": "if too many or too few type arguments are given, or if an inappropriate type argument or type element is provided", "labels": []}
{"id": 15629, "text": "if too many or too few type arguments are given, or if an inappropriate type argument, type element, or containing type is provided", "labels": []}
{"id": 15630, "text": "if the element is not a valid one for the given type", "labels": []}
{"id": 15631, "text": "if the SSLContextImpl requires initialization and the engineInit() has not been called", "labels": []}
{"id": 15632, "text": "if the current thread is interrupted before acquiring the lock", "labels": []}
{"id": 15633, "text": "if the stamp does not match the current state of this lock", "labels": []}
{"id": 15634, "text": "If the streamNumber is negative or greater than 65536", "labels": []}
{"id": 15635, "text": "If association is null, or the streamNumber is negative or greater than 65536", "labels": []}
{"id": 15636, "text": "any SAX exception, possibly wrapping another exception", "labels": []}
{"id": 15637, "text": "the client may throw an exception during processing", "labels": []}
{"id": 15638, "text": "if no Provider supports an XMLSignatureFactory implementation for the specified mechanism", "labels": []}
{"id": 15639, "text": "if provider or mechanismType is null", "labels": []}
{"id": 15640, "text": "if an XMLSignatureFactory implementation for the specified mechanism is not available from the specified Provider object", "labels": []}
{"id": 15641, "text": "if an XMLSignatureFactory implementation for the specified mechanism is not available from the specified provider", "labels": []}
{"id": 15642, "text": "if no Provider supports an XMLSignatureFactory implementation for the DOM mechanism", "labels": []}
{"id": 15643, "text": "if any of the transforms are not of type Transform", "labels": []}
{"id": 15644, "text": "if uri is not RFC 2396 compliant", "labels": []}
{"id": 15645, "text": "if dm or digestValue is null", "labels": []}
{"id": 15646, "text": "if any of the transforms (in either list) are not of type Transform", "labels": []}
{"id": 15647, "text": "if uri is not RFC 2396 compliant or appliedTransforms is empty", "labels": []}
{"id": 15648, "text": "if dm, appliedTransforms or result is null", "labels": []}
{"id": 15649, "text": "if the type of params is inappropriate for this XMLSignatureFactory", "labels": []}
{"id": 15650, "text": "if the specified parameters are inappropriate for the requested algorithm", "labels": []}
{"id": 15651, "text": "if an implementation of the specified algorithm cannot be found", "labels": []}
{"id": 15652, "text": "if xmlStructure is null", "labels": []}
{"id": 15653, "text": "if the type of xmlStructure is inappropriate for this factory", "labels": []}
{"id": 15654, "text": "if an unrecoverable exception occurs during unmarshalling", "labels": []}
{"id": 15655, "text": "if the security manager denies access to the directory.", "labels": []}
{"id": 15656, "text": "if input is null.", "labels": []}
{"id": 15657, "text": "if a cache file is needed but cannot be created.", "labels": []}
{"id": 15658, "text": "if output is null.", "labels": []}
{"id": 15659, "text": "if an error occurs during reading or when not able to create required ImageInputStream.", "labels": []}
{"id": 15660, "text": "if any parameter is null.", "labels": []}
{"id": 15661, "text": "if an error occurs during writing or when not able to create required ImageOutputStream.", "labels": []}
{"id": 15662, "text": "If any specified class can not be found", "labels": []}
{"id": 15663, "text": "If any specified class is an interface or abstract class", "labels": []}
{"id": 15664, "text": "If the default constructor of a specified class is not accessible", "labels": []}
{"id": 15665, "text": "If any specified class does not implement DOMImplementationSource", "labels": []}
{"id": 15666, "text": "if executor is null", "labels": []}
{"id": 15667, "text": "if maxBufferCapacity not positive", "labels": []}
{"id": 15668, "text": "if subscriber is null", "labels": []}
{"id": 15669, "text": "if closed", "labels": []}
{"id": 15670, "text": "if item is null", "labels": []}
{"id": 15671, "text": "if thrown by Executor", "labels": []}
{"id": 15672, "text": "if error is null", "labels": []}
{"id": 15673, "text": "if consumer is null", "labels": []}
{"id": 15674, "text": "if either off or len is negative, or if off+len is greater than b.length.", "labels": []}
{"id": 15675, "text": "if an attempt is made to add this class to a package that contains classes that were signed by a different set of certificates than this class, or if the class name begins with \"java.", "labels": []}
{"id": 15676, "text": "If this object factory encountered an exception while attempting to create an object, and no other object factories are to be tried.", "labels": []}
{"id": 15677, "text": "if the item doesn't exist in the list", "labels": []}
{"id": 15678, "text": "if the position is less than 0 or greater than getItemCount()-1", "labels": []}
{"id": 15679, "text": "If provider or id is null.", "labels": []}
{"id": 15680, "text": "if name is improperly formatted, if name is null, or if name does not contain the realm to use and the default realm is not specified in either a Kerberos configuration file or via the java.security.krb5.realm system property.", "labels": []}
{"id": 15681, "text": "if a security manager is installed and name does not contain the realm to use, and a proper ServicePermission as described above is not granted.", "labels": []}
{"id": 15682, "text": "if name is improperly formatted, if name is null, if the nameType is not supported, or if name does not contain the realm to use and the default realm is not specified in either a Kerberos configuration file or via the java.security.krb5.realm system property.", "labels": []}
{"id": 15683, "text": "if either the input or reason strings are null", "labels": []}
{"id": 15684, "text": "if the error index is less than -1", "labels": []}
{"id": 15685, "text": "if namespaceURI is null", "labels": []}
{"id": 15686, "text": "if localName is not an attribute of the specified element or it does not contain a specific value", "labels": []}
{"id": 15687, "text": "if element or localName is null", "labels": []}
{"id": 15688, "text": "if text is null.", "labels": []}
{"id": 15689, "text": "if the subrange given by beginIndex and endIndex is out of the text range.", "labels": []}
{"id": 15690, "text": "if beginIndex is less than 0, endIndex is greater than the length of the string, or beginIndex is greater than endIndex.", "labels": []}
{"id": 15691, "text": "if the ColorModel of src is an IndexColorModel, or if the number of scaling factors and offsets in this RescaleOp do not meet the requirements stated in the class comments, or if the source and destination images differ in size.", "labels": []}
{"id": 15692, "text": "if src and dst do not have the same number of bands, or if the number of scaling factors and offsets in this RescaleOp do not meet the requirements stated in the class comments, or if the source and destination rasters differ in size.", "labels": []}
{"id": 15693, "text": "An implementation of this interface should specify any required permissions.", "labels": []}
{"id": 15694, "text": "if a security manager exists and its checkPermission method doesn't allow the operation", "labels": []}
{"id": 15695, "text": "if this factory encountered an exception while attempting to get the object's state, and no other factories are to be tried.", "labels": []}
{"id": 15696, "text": "if value/key is null, an unsupported value type is used, or a value/key is used that doesn't match the signatures in the annotationType", "labels": []}
{"id": 15697, "text": "if delay is negative, or delay + System.currentTimeMillis() is negative.", "labels": []}
{"id": 15698, "text": "if task was already scheduled or cancelled, timer was cancelled, or timer thread terminated.", "labels": []}
{"id": 15699, "text": "if task is null", "labels": []}
{"id": 15700, "text": "if time.getTime() is negative.", "labels": []}
{"id": 15701, "text": "if task or time is null", "labels": []}
{"id": 15702, "text": "if delay < 0, or delay + System.currentTimeMillis() < 0, or period <= 0", "labels": []}
{"id": 15703, "text": "if firstTime.getTime() < 0, or period <= 0", "labels": []}
{"id": 15704, "text": "if task or firstTime is null", "labels": []}
{"id": 15705, "text": "if firstTime.getTime() < 0 or period <= 0", "labels": []}
{"id": 15706, "text": "if any of the jar file entries are incorrectly signed.", "labels": []}
{"id": 15707, "text": "if model is null", "labels": []}
{"id": 15708, "text": "if the currently edited value couldn't be committed.", "labels": []}
{"id": 15709, "text": "if the number of arrays in the LookupTable does not meet the restrictions described in the class comments, or if the source image has an IndexColorModel.", "labels": []}
{"id": 15710, "text": "if the source and destinations rasters do not have the same number of bands, or the number of arrays in the LookupTable does not meet the restrictions described in the class comments.", "labels": []}
{"id": 15711, "text": "if an I/O error occurs, or the owner parameter is a group and this implementation does not support setting the owner to a group", "labels": []}
{"id": 15712, "text": "if copies is less than or equal to 0", "labels": []}
{"id": 15713, "text": "if defaultSelection is null", "labels": []}
{"id": 15714, "text": "if destination is null.", "labels": []}
{"id": 15715, "text": "if dialog is null.", "labels": []}
{"id": 15716, "text": "if one or more of the above conditions is violated.", "labels": []}
{"id": 15717, "text": "if sides is null.", "labels": []}
{"id": 15718, "text": "if the sequence contains invalid MIDI data, or is not supported", "labels": []}
{"id": 15719, "text": "if invalid data is encountered in the stream, or the stream is not supported", "labels": []}
{"id": 15720, "text": "if the Sequencer is closed", "labels": []}
{"id": 15721, "text": "thrown if the track is not part of the current sequence", "labels": []}
{"id": 15722, "text": "if the requested loop start point cannot be set, usually because it falls outside the sequence's duration or because the start point is after the end point", "labels": []}
{"id": 15723, "text": "if the requested loop point cannot be set, usually because it falls outside the sequence's duration or because the ending point is before the starting point", "labels": []}
{"id": 15724, "text": "if count is negative and not equal to LOOP_CONTINUOUSLY", "labels": []}
{"id": 15725, "text": "if no Provider supports a TerminalFactorySpi of the specified type", "labels": []}
{"id": 15726, "text": "if provider is null or the empty String", "labels": []}
{"id": 15727, "text": "if a TerminalFactorySpi implementation of the specified type is not available from the specified provider", "labels": []}
{"id": 15728, "text": "if no TerminalFactory of the specified type could be found", "labels": []}
{"id": 15729, "text": "if the specified provider could not be found", "labels": []}
{"id": 15730, "text": "if a TerminalFactorySpi implementation of the specified type is not available from the specified Provider", "labels": []}
{"id": 15731, "text": "if any of the arguments are null.", "labels": []}
{"id": 15732, "text": "if a database access error occurs or this XmlReader object is not the reader for the given rowset", "labels": []}
{"id": 15733, "text": "if c is not an EnumSet instance and contains no elements", "labels": []}
{"id": 15734, "text": "if e is null", "labels": []}
{"id": 15735, "text": "if any parameters are null", "labels": []}
{"id": 15736, "text": "if any of the specified elements are null, or if rest is null", "labels": []}
{"id": 15737, "text": "if from or to are null", "labels": []}
{"id": 15738, "text": "if from.compareTo(to) > 0", "labels": []}
{"id": 15739, "text": "if interfaceName is null, or if any element of attributes is null", "labels": []}
{"id": 15740, "text": "if any element of attributes is not an instance of interfaceName", "labels": []}
{"id": 15741, "text": "if the category is not a Class that implements interface Attribute", "labels": []}
{"id": 15742, "text": "if this attribute set does not support the remove() operation", "labels": []}
{"id": 15743, "text": "if this attribute set does not support the addAll(AttributeSet) method", "labels": []}
{"id": 15744, "text": "if some element in the specified set is null, or the set is null", "labels": []}
{"id": 15745, "text": "if evt is null", "labels": []}
{"id": 15746, "text": "if field is invalid", "labels": []}
{"id": 15747, "text": "if the instant value has already been set, or if fields have been set too many (approximately Integer.MAX_VALUE) times.", "labels": []}
{"id": 15748, "text": "if zone is null", "labels": []}
{"id": 15749, "text": "if the calendar type is unknown, or if any invalid field values are given in non-lenient mode, or if a week date is given for the calendar type that doesn't support week dates.", "labels": []}
{"id": 15750, "text": "if the coordinates are not in bounds, or if obj is too small to hold the input.", "labels": []}
{"id": 15751, "text": "if iArray or data is null.", "labels": []}
{"id": 15752, "text": "if the coordinates are not in bounds, or if iArray is too small to hold the input.", "labels": []}
{"id": 15753, "text": "if fArray or data is null.", "labels": []}
{"id": 15754, "text": "if the coordinates are not in bounds, or if fArray is too small to hold the input.", "labels": []}
{"id": 15755, "text": "if dArray or data is null.", "labels": []}
{"id": 15756, "text": "if the coordinates are not in bounds, or if dArray is too small to hold the input.", "labels": []}
{"id": 15757, "text": "if the coordinates or the band index are not in bounds, or if iArray is too small to hold the input.", "labels": []}
{"id": 15758, "text": "if the coordinates or the band index are not in bounds, or if fArray is too small to hold the input.", "labels": []}
{"id": 15759, "text": "if the coordinates or the band index are not in bounds, or if dArray is too small to hold the input.", "labels": []}
{"id": 15760, "text": "if the string cannot be converted to a set of permissions", "labels": []}
{"id": 15761, "text": "if a security manager exists and its checkPropertiesAccess method doesn't allow setting of system properties", "labels": []}
{"id": 15762, "text": "if the hook cannot be invoked on the required arguments, or if the target returned by the hook is not of the given targetType", "labels": []}
{"id": 15763, "text": "if the hook returns a null value", "labels": []}
{"id": 15764, "text": "if the hook returns something other than a MethodHandle", "labels": []}
{"id": 15765, "text": "if the ConstantCallSite constructor has not completed", "labels": []}
{"id": 15766, "text": "if the current state does not allow Namespace writing", "labels": []}
{"id": 15767, "text": "If given encoding does not match encoding of the underlying stream", "labels": []}
{"id": 15768, "text": "if the given range is null", "labels": []}
{"id": 15769, "text": "if the given range does not comply with the syntax of the language range mentioned in RFC 4647", "labels": []}
{"id": 15770, "text": "if the given range does not comply with the syntax of the language range mentioned in RFC 4647 or if the given weight is less than MIN_WEIGHT or greater than MAX_WEIGHT", "labels": []}
{"id": 15771, "text": "if ranges is null", "labels": []}
{"id": 15772, "text": "if a language range or a weight found in the given ranges is ill-formed", "labels": []}
{"id": 15773, "text": "if priorityList is null", "labels": []}
{"id": 15774, "text": "if color is null.", "labels": []}
{"id": 15775, "text": "if media is null.", "labels": []}
{"id": 15776, "text": "if orientationRequested is not 3 or 4", "labels": []}
{"id": 15777, "text": "if origin is null.", "labels": []}
{"id": 15778, "text": "if printQuality is not 3, 4, or 5", "labels": []}
{"id": 15779, "text": "If the named charset is not supported", "labels": []}
{"id": 15780, "text": "If offset is negative, length is negative, or offset is greater than bytes.length - length", "labels": []}
{"id": 15781, "text": "if the index argument is negative or not less than the length of this string.", "labels": []}
{"id": 15782, "text": "if the index argument is less than 1 or greater than the length of this string.", "labels": []}
{"id": 15783, "text": "if the regular expression's syntax is invalid", "labels": []}
{"id": 15784, "text": "If delimiter or elements is null", "labels": []}
{"id": 15785, "text": "if the count is negative.", "labels": []}
{"id": 15786, "text": "if the proposed type is null", "labels": []}
{"id": 15787, "text": "if the proposed new target is null", "labels": []}
{"id": 15788, "text": "if the proposed new target has a method type that differs from the previous target", "labels": []}
{"id": 15789, "text": "if the sites array reference is null or the array contains a null", "labels": []}
{"id": 15790, "text": "if argument is null", "labels": []}
{"id": 15791, "text": "if an input or output error occurs", "labels": []}
{"id": 15792, "text": "if EXIT_ON_CLOSE has been specified and the SecurityManager will not allow the caller to invoke System.exit", "labels": []}
{"id": 15793, "text": "if the profile does not specify the TRC as a single gamma value", "labels": []}
{"id": 15794, "text": "if the profile does not specify the TRC as a table", "labels": []}
{"id": 15795, "text": "if IP address is of illegal length, or if the interface does not have a numeric scope_id assigned for the given address type.", "labels": []}
{"id": 15796, "text": "if IP address is of illegal length.", "labels": []}
{"id": 15797, "text": "if the attributes or the map is a null value", "labels": []}
{"id": 15798, "text": "if the read position is located at an invalid position or if there are no further values in the stream.", "labels": []}
{"id": 15799, "text": "if the read position is located at an invalid position or if there are no further values in the stream", "labels": []}
{"id": 15800, "text": "if the read position is located at an invalid position or if there are no more values in the stream", "labels": []}
{"id": 15801, "text": "if the read position is located at an invalid position; or if there are no further values in the stream.", "labels": []}
{"id": 15802, "text": "if an error occurs determining the last value read was a null value or not;", "labels": []}
{"id": 15803, "text": "if the fileObject is not an HTML file", "labels": []}
{"id": 15804, "text": "If the file descriptor is not valid", "labels": []}
{"id": 15805, "text": "if this watch service is closed", "labels": []}
{"id": 15806, "text": "if this watch service is closed, or it is closed while waiting for the next key", "labels": []}
{"id": 15807, "text": "The name is null.", "labels": []}
{"id": 15808, "text": "If property is null.", "labels": []}
{"id": 15809, "text": "If property is not a valid key property for this ObjectName.", "labels": []}
{"id": 15810, "text": "if q could not have been returned by the quote(java.lang.String) method, for instance if it does not begin and end with a quote (\").", "labels": []}
{"id": 15811, "text": "if q is null.", "labels": []}
{"id": 15812, "text": "if the input does not represent a well-formed class file", "labels": []}
{"id": 15813, "text": "if address type is not supported", "labels": []}
{"id": 15814, "text": "if the length is negative of if the length is greater than the packet's data buffer length.", "labels": []}
{"id": 15815, "text": "the exception to throw from the method invocation on the proxy instance", "labels": []}
{"id": 15816, "text": "If a naming exception was encountered while attempting to get a URL context, or if one of the factories accessed throws a NamingException.", "labels": []}
{"id": 15817, "text": "If a naming exception was encountered while using the factories.", "labels": []}
{"id": 15818, "text": "if primitives or algorithm is null or empty", "labels": []}
{"id": 15819, "text": "if primitives is null or empty, or the key is null", "labels": []}
{"id": 15820, "text": "if primitives or algorithm is null or empty, or the key is null", "labels": []}
{"id": 15821, "text": "if dirty call fails", "labels": []}
{"id": 15822, "text": "if clean call fails", "labels": []}
{"id": 15823, "text": "if dataType is not either DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT, or DataBuffer.TYPE_INT", "labels": []}
{"id": 15824, "text": "if any mask in bitMask is not contiguous", "labels": []}
{"id": 15825, "text": "If an unrecoverable error occurs during the course of the transformation.", "labels": []}
{"id": 15826, "text": "If value is null.", "labels": []}
{"id": 15827, "text": "When keys are not recognized and are not namespace qualified.", "labels": []}
{"id": 15828, "text": "If the property is not supported, and is not qualified with a namespace.", "labels": []}
{"id": 15829, "text": "If the property is not supported.", "labels": []}
{"id": 15830, "text": "if some element in the specified set is null", "labels": []}
{"id": 15831, "text": "if index is less than 0", "labels": []}
{"id": 15832, "text": "if the item doesn't exist in the choice menu", "labels": []}
{"id": 15833, "text": "if the specified position is out of bounds", "labels": []}
{"id": 15834, "text": "if the specified position is greater than the number of items or less than zero", "labels": []}
{"id": 15835, "text": "if the mbeanInterface does not follow JMX design patterns for Management Interfaces, or if the given implementation does not implement the specified interface, or if emitter is null.", "labels": []}
{"id": 15836, "text": "if the mbeanInterface does not follow JMX design patterns for Management Interfaces, or if this does not implement the specified interface, or if emitter is null.", "labels": []}
{"id": 15837, "text": "if the emitter parameter to the constructor was not a NotificationBroadcasterSupport.", "labels": []}
{"id": 15838, "text": "if level is null.", "labels": []}
{"id": 15839, "text": "if level is null, or msgSupplier is null.", "labels": []}
{"id": 15840, "text": "if level is null, or obj is null.", "labels": []}
{"id": 15841, "text": "if the type has not yet been loaded or created through the appropriate class loader.", "labels": []}
{"id": 15842, "text": "if the necessary runtime permission is not granted.", "labels": []}
{"id": 15843, "text": "if number is negative or dataTypes is negative or specifies an out of range type.", "labels": []}
{"id": 15844, "text": "if name or tagSet is null.", "labels": []}
{"id": 15845, "text": "if number is negative.", "labels": []}
{"id": 15846, "text": "if datatype is less than MIN_DATATYPE or greater than MAX_DATATYPE.", "labels": []}
{"id": 15847, "text": "if algorithm is not available.", "labels": []}
{"id": 15848, "text": "if algorithm is not available in the specified provider.", "labels": []}
{"id": 15849, "text": "if algorithm is not compatible with the algorithm of the signer's private key.", "labels": []}
{"id": 15850, "text": "if name is empty or has a size bigger than 8, or it contains characters not from the set \"a-zA-Z0-9_-\".", "labels": []}
{"id": 15851, "text": "if a signature algorithm is not set and cannot be derived from the private key using the getDefaultSignatureAlgorithm(java.security.PrivateKey) method.", "labels": []}
{"id": 15852, "text": "if the supplied lineSeparator is the empty string", "labels": []}
{"id": 15853, "text": "if an invalid set of open options are specified", "labels": []}
{"id": 15854, "text": "If a security manager has been installed and it denies write access to the file.", "labels": []}
{"id": 15855, "text": "if the given path does not exist, is not a directory, is not writable, or if an invalid set of open options are specified", "labels": []}
{"id": 15856, "text": "If a security manager has been installed and it denies read access to the directory, or it denies write access to the directory, or it denies write access to the files within the directory.", "labels": []}
{"id": 15857, "text": "if bufferSize <= 0", "labels": []}
{"id": 15858, "text": "if validatingKey or node is null", "labels": []}
{"id": 15859, "text": "if canUndo returns false", "labels": []}
{"id": 15860, "text": "if canRedo returns false", "labels": []}
{"id": 15861, "text": "If canRedefineClasses() is false any call of this method will throw this exception.", "labels": []}
{"id": 15862, "text": "If canAddMethod() is false attempting to add a method will throw this exception.", "labels": []}
{"id": 15863, "text": "If canUnrestrictedlyRedefineClasses() is false, attempting any of the following will throw this exception changing the schema (the fields) changing the hierarchy (superclasses, interfaces) deleting a method changing class modifiers changing method modifiers changing the NestHost or NestMembers class attributes", "labels": []}
{"id": 15864, "text": "if the bytes don't correspond to the reference type (the names don't match).", "labels": []}
{"id": 15865, "text": "if a \"verifier\" detects that a class, though well formed, contains an internal inconsistency or security problem.", "labels": []}
{"id": 15866, "text": "if the bytes do not represent a valid class.", "labels": []}
{"id": 15867, "text": "if a circularity has been detected while initializing a class.", "labels": []}
{"id": 15868, "text": "if the major and minor version numbers in bytes are not supported by the VM.", "labels": []}
{"id": 15869, "text": "if the VirtualMachine is read-only - see canBeModified().", "labels": []}
{"id": 15870, "text": "if the VirtualMachine is read-only -see canBeModified().", "labels": []}
{"id": 15871, "text": "if the 'refTypes' list is null.", "labels": []}
{"id": 15872, "text": "if the era is invalid", "labels": []}
{"id": 15873, "text": "if state is null", "labels": []}
{"id": 15874, "text": "if this CardTerminals object does not contain any terminals", "labels": []}
{"id": 15875, "text": "if the imageType is not TYPE_BYTE_BINARY or TYPE_BYTE_INDEXED or if the imageType is TYPE_BYTE_BINARY and the color map has more than 16 entries.", "labels": []}
{"id": 15876, "text": "if the number and types of bands in the SampleModel of the Raster do not match the number and types required by the ColorModel to represent its color and alpha components.", "labels": []}
{"id": 15877, "text": "if raster is incompatible with cm", "labels": []}
{"id": 15878, "text": "if both tileX and tileY are not equal to 0", "labels": []}
{"id": 15879, "text": "if this AttributeList is type-safe and element is not an Attribute.", "labels": []}
{"id": 15880, "text": "if this AttributeList is type-safe and c contains an element that is not an Attribute.", "labels": []}
{"id": 15881, "text": "if dimension is not a positive integer.", "labels": []}
{"id": 15882, "text": "if elementType's className is not one of the allowed Java class names for open data.", "labels": []}
{"id": 15883, "text": "if primitiveArray is true and elementType is not a valid SimpleType for a primitive type.", "labels": []}
{"id": 15884, "text": "if the field name is illegal.", "labels": []}
{"id": 15885, "text": "for illegal value for field names or field values.", "labels": []}
{"id": 15886, "text": "if no Provider supports a SecretKeyFactorySpi implementation for the specified algorithm", "labels": []}
{"id": 15887, "text": "if a SecretKeyFactorySpi implementation for the specified algorithm is not available from the specified provider", "labels": []}
{"id": 15888, "text": "if a SecretKeyFactorySpi implementation for the specified algorithm is not available from the specified Provider object", "labels": []}
{"id": 15889, "text": "If the expression's syntax is invalid", "labels": []}
{"id": 15890, "text": "if a security manager has been installed and it denies write access to the file", "labels": []}
{"id": 15891, "text": "if no Provider supports a KeyPairGeneratorSpi implementation for the specified algorithm", "labels": []}
{"id": 15892, "text": "if a KeyPairGeneratorSpi implementation for the specified algorithm is not available from the specified provider", "labels": []}
{"id": 15893, "text": "if a KeyPairGeneratorSpi implementation for the specified algorithm is not available from the specified Provider object", "labels": []}
{"id": 15894, "text": "if the keysize is not supported by this KeyPairGenerator object.", "labels": []}
{"id": 15895, "text": "if a matching line is not available due to resource restrictions", "labels": []}
{"id": 15896, "text": "if this mixer does not support any lines matching the description", "labels": []}
{"id": 15897, "text": "if a matching line is not available due to security restrictions", "labels": []}
{"id": 15898, "text": "if the lines cannot be unsynchronized.", "labels": []}
{"id": 15899, "text": "This may occur if the argument specified does not exactly match a set of lines for which synchronization has already been established.", "labels": []}
{"id": 15900, "text": "If the preconditions on the start and end parameters do not hold", "labels": []}
{"id": 15901, "text": "If there are fewer than length chars remaining in this buffer", "labels": []}
{"id": 15902, "text": "If there is insufficient space in this buffer for the remaining chars in the source buffer", "labels": []}
{"id": 15903, "text": "If the preconditions on start and end do not hold", "labels": []}
{"id": 15904, "text": "if object is unknown (not registered)", "labels": []}
{"id": 15905, "text": "if this card object has been disposed of via the disconnect() method", "labels": []}
{"id": 15906, "text": "if exclusive access has already been set or if exclusive access could not be established", "labels": []}
{"id": 15907, "text": "If a naming exception is encountered while attempting to retrieve the next element.", "labels": []}
{"id": 15908, "text": "See NamingException and its subclasses for the possible naming exceptions.", "labels": []}
{"id": 15909, "text": "If attempting to get the next element when none is available.", "labels": []}
{"id": 15910, "text": "If a naming exception is encountered while attempting to determine whether there is another element in the enumeration.", "labels": []}
{"id": 15911, "text": "If a naming exception is encountered while closing the enumeration.", "labels": []}
{"id": 15912, "text": "If ctl contains invalid data that prevents it from being used to create a control.", "labels": []}
{"id": 15913, "text": "A factory should only throw an exception if it knows how to produce the control (identified by the OID) but is unable to because of, for example invalid BER data.", "labels": []}
{"id": 15914, "text": "if a naming exception was encountered while attempting to create the control object.", "labels": []}
{"id": 15915, "text": "If one of the factories accessed throws an exception, it is propagated up to the caller.", "labels": []}
{"id": 15916, "text": "If an error was encountered while loading and instantiating the factory and object classes, the exception is wrapped inside a NamingException and then rethrown.", "labels": []}
{"id": 15917, "text": "Thrown when the buffers cannot be flushed, or because the system cannot guarantee that all the buffers have been synchronized with physical media.", "labels": []}
{"id": 15918, "text": "if the specified codePoint is an invalid Unicode code point.", "labels": []}
{"id": 15919, "text": "if blockName is an invalid name", "labels": []}
{"id": 15920, "text": "if blockName is null", "labels": []}
{"id": 15921, "text": "if parties is less than 1", "labels": []}
{"id": 15922, "text": "if another thread was interrupted or timed out while the current thread was waiting, or the barrier was reset, or the barrier was broken when await was called, or the barrier action (if present) failed due to an exception", "labels": []}
{"id": 15923, "text": "if the specified timeout elapses.", "labels": []}
{"id": 15924, "text": "if str is null.", "labels": []}
{"id": 15925, "text": "Wraps an IllegalArgumentException for a null constructor name.", "labels": []}
{"id": 15926, "text": "If this key has been cancelled", "labels": []}
{"id": 15927, "text": "If a bit in the set does not correspond to an operation that is supported by this key's channel, that is, if (ops & ~channel().validOps()) != 0", "labels": []}
{"id": 15928, "text": "in case the top-level linker throws an exception", "labels": []}
{"id": 15929, "text": "if either action or lookupSupplier are null.", "labels": []}
{"id": 15930, "text": "on decoding errors", "labels": []}
{"id": 15931, "text": "if the requested parameter specification is inappropriate for this parameter object.", "labels": []}
{"id": 15932, "text": "if a ZIP error has occurred", "labels": []}
{"id": 15933, "text": "WRONG_DOCUMENT_ERR: Raised if arg was created from a different document than the one that created this map.", "labels": []}
{"id": 15934, "text": "NO_MODIFICATION_ALLOWED_ERR: Raised if this map is readonly.", "labels": []}
{"id": 15935, "text": "INUSE_ATTRIBUTE_ERR: Raised if arg is an Attr that is already an attribute of another Element object.", "labels": []}
{"id": 15936, "text": "HIERARCHY_REQUEST_ERR: Raised if an attempt is made to add a node doesn't belong in this NamedNodeMap.", "labels": []}
{"id": 15937, "text": "NOT_FOUND_ERR: Raised if there is no node named name in this map.", "labels": []}
{"id": 15938, "text": "NOT_FOUND_ERR: Raised if there is no node with the specified namespaceURI and localName in this map.", "labels": []}
{"id": 15939, "text": "if type is not in the range of 0 to 255, inclusive.", "labels": []}
{"id": 15940, "text": "when an invalid string operation is passed to a method for constructing a query", "labels": []}
{"id": 15941, "text": "when an invalid expression is passed to a method for constructing a query", "labels": []}
{"id": 15942, "text": "when an invalid MBean attribute is passed to a query constructing method", "labels": []}
{"id": 15943, "text": "when an invalid apply is attempted", "labels": []}
{"id": 15944, "text": "if host is null.", "labels": []}
{"id": 15945, "text": "if field or style is invalid", "labels": []}
{"id": 15946, "text": "If this is a named module and the caller's module is not this module", "labels": []}
{"id": 15947, "text": "If pn is null, or this is a named module and the package pn is not a package in this module", "labels": []}
{"id": 15948, "text": "If this is a named module and this module has not opened the package to at least the caller's module", "labels": []}
{"id": 15949, "text": "if mask does not contain valid mask characters", "labels": []}
{"id": 15950, "text": "if the specified logger does not exist, or levelName is not a valid level name.", "labels": []}
{"id": 15951, "text": "if index is outside the range of this array, that is, if either of the following are true: index < 0 index >= length()", "labels": []}
{"id": 15952, "text": "if the type of value is not compatible with the declared type of array components.", "labels": []}
{"id": 15953, "text": "if the array component type has not yet been loaded through the appropriate class loader.", "labels": []}
{"id": 15954, "text": "if any of the new values is not compatible with the declared type of array components.", "labels": []}
{"id": 15955, "text": "if any element of values is not compatible with the declared type of array components.", "labels": []}
{"id": 15956, "text": "if the offset or length are invalid", "labels": []}
{"id": 15957, "text": "if the value supplied for position is less than zero or greater than the component's text length", "labels": []}
{"id": 15958, "text": "if the document is null", "labels": []}
{"id": 15959, "text": "if the selection doesn't have a valid mapping into the document for some reason", "labels": []}
{"id": 15960, "text": "if input is not an instance of the correct class or is null.", "labels": []}
{"id": 15961, "text": "if a cache file is needed but cacheDir is non-null and is not a directory.", "labels": []}
{"id": 15962, "text": "if the argument does not represent an annotation type", "labels": []}
{"id": 15963, "text": "if the any elements of the argument set do not represent an annotation type", "labels": []}
{"id": 15964, "text": "If the channel does not allow more than one read to be outstanding and a previous read has not completed", "labels": []}
{"id": 15965, "text": "If the channel is associated with a group that has terminated", "labels": []}
{"id": 15966, "text": "If the channel does not allow more than one write to be outstanding and a previous write has not completed", "labels": []}
{"id": 15967, "text": "If the postRegister (MBeanRegistration interface) method of the MBean throws a RuntimeException, the registerMBean method will throw a RuntimeMBeanException, although the MBean registration succeeded.", "labels": []}
{"id": 15968, "text": "In such a case, the MBean will be actually registered even though the registerMBean method threw an exception.", "labels": []}
{"id": 15969, "text": "If the postRegister (MBeanRegistration interface) method of the MBean throws an Error, the registerMBean method will throw a RuntimeErrorException, although the MBean registration succeeded.", "labels": []}
{"id": 15970, "text": "Wraps a java.lang.IllegalArgumentException: The object passed in parameter is null or no object name is specified.", "labels": []}
{"id": 15971, "text": "Wraps a java.lang.IllegalArgumentException: The object name in parameter is null or the MBean you are when trying to unregister is the MBeanServerDelegate MBean.", "labels": []}
{"id": 15972, "text": "If the postDeregister (MBeanRegistration interface) method of the MBean throws a RuntimeException, the unregisterMBean method will throw a RuntimeMBeanException, although the MBean unregistration succeeded.", "labels": []}
{"id": 15973, "text": "In such a case, the MBean will be actually unregistered even though the unregisterMBean method threw an exception.", "labels": []}
{"id": 15974, "text": "Note that RuntimeMBeanException can also be thrown by preDeregister, in which case the MBean will remain registered.", "labels": []}
{"id": 15975, "text": "If the postDeregister (MBeanRegistration interface) method of the MBean throws an Error, the unregisterMBean method will throw a RuntimeErrorException, although the MBean unregistration succeeded.", "labels": []}
{"id": 15976, "text": "The preDeregister ((MBeanRegistration interface) method of the MBean has thrown an exception.", "labels": []}
{"id": 15977, "text": "Wraps a java.lang.ClassNotFoundException or the java.lang.Exception that occurred when trying to invoke the object's constructor.", "labels": []}
{"id": 15978, "text": "The constructor of the object has thrown an exception", "labels": []}
{"id": 15979, "text": "Wraps a java.lang.IllegalArgumentException: The className passed in parameter is null.", "labels": []}
{"id": 15980, "text": "The constructor of the object has thrown an exception.", "labels": []}
{"id": 15981, "text": "if the compressed input data is corrupt.", "labels": []}
{"id": 15982, "text": "if an I/O error has occurred.", "labels": []}
{"id": 15983, "text": "if names or filters is null, or if names contains a null element, or if the three arrays do not all have the same size.", "labels": []}
{"id": 15984, "text": "if one of the elements of filters unmarshalls as a non-null object that is not a NotificationFilter.", "labels": []}
{"id": 15985, "text": "if one of the names does not correspond to any registered MBean.", "labels": []}
{"id": 15986, "text": "if, for one of the MBeans, the client, or the delegated Subject if any, does not have permission to add a listener.", "labels": []}
{"id": 15987, "text": "if a general communication exception occurred.", "labels": []}
{"id": 15988, "text": "if the supplied image capabilities could not be met by this graphics configuration", "labels": []}
{"id": 15989, "text": "if the transparency is not a valid value", "labels": []}
{"id": 15990, "text": "if unable to convert to a Year", "labels": []}
{"id": 15991, "text": "if the amount cannot be calculated, or the end temporal cannot be converted to a Year", "labels": []}
{"id": 15992, "text": "if the day of year is zero or less, 366 or greater or equal to 366 and this is not a leap year", "labels": []}
{"id": 15993, "text": "if either u or p is null, or p has the wrong type.", "labels": []}
{"id": 15994, "text": "if the subclass that implements the protocol doesn't support this method.", "labels": []}
{"id": 15995, "text": "if the protocol handler of the URL is different from this one", "labels": []}
{"id": 15996, "text": "NO_MODIFICATION_ALLOWED_ERR: Raised if this declaration is readonly or the property is readonly.", "labels": []}
{"id": 15997, "text": "if edgeName is null", "labels": []}
{"id": 15998, "text": "if history cannot be obtained for the zone ID", "labels": []}
{"id": 15999, "text": "if a zone ID is already registered", "labels": []}
{"id": 16000, "text": "if an error occurs during the refresh", "labels": []}
{"id": 16001, "text": "if a problem occurs while providing the IDs", "labels": []}
{"id": 16002, "text": "if rules cannot be obtained for the zone ID", "labels": []}
{"id": 16003, "text": "if bits is less than 1 or greater than 32", "labels": []}
{"id": 16004, "text": "if space is not a TYPE_RGB space", "labels": []}
{"id": 16005, "text": "if index is greater than the number of components minus 1 in this PackedColorModel or if index is less than zero", "labels": []}
{"id": 16006, "text": "if the element is null", "labels": []}
{"id": 16007, "text": "if the element could not be removed", "labels": []}
{"id": 16008, "text": "if the element structure is invalid", "labels": []}
{"id": 16009, "text": "if this stack frame has become invalid.", "labels": []}
{"id": 16010, "text": "if there is no local variable information for this method.", "labels": []}
{"id": 16011, "text": "if the current method is native.", "labels": []}
{"id": 16012, "text": "if the variable is either invalid for this frame's method or not visible.", "labels": []}
{"id": 16013, "text": "if any variable is either invalid for this frame's method or not visible.", "labels": []}
{"id": 16014, "text": "if the value's type does not match the variable's type.", "labels": []}
{"id": 16015, "text": "if the variable type has not yet been loaded through the appropriate class loader.", "labels": []}
{"id": 16016, "text": "if the scrollpane does not contain a child", "labels": []}
{"id": 16017, "text": "if the application chooses to discontinue the transformation.", "labels": []}
{"id": 16018, "text": "if the index is out of range (index < -1 || (certPath != null && index >= certPath.getCertificates().size())", "labels": []}
{"id": 16019, "text": "if certPath is null and index is not -1", "labels": []}
{"id": 16020, "text": "if reason is null", "labels": []}
{"id": 16021, "text": "if tab placement value isn't one of the above valid values", "labels": []}
{"id": 16022, "text": "if layoutPolicy value isn't one of the above valid values", "labels": []}
{"id": 16023, "text": "if index is out of range (index < -1 || index >= tab count)", "labels": []}
{"id": 16024, "text": "if the index is out of range (< 0 or > getTabCount())", "labels": []}
{"id": 16025, "text": "if index is out of range (index < 0 || index >= tab count)", "labels": []}
{"id": 16026, "text": "if index is out of range (tabIndex < 0 || tabIndex >= tab count)", "labels": []}
{"id": 16027, "text": "if tabIndex is out of range (tabIndex < 0 || tabIndex >= tab count)", "labels": []}
{"id": 16028, "text": "will be thrown if mnemonicIndex is >= length of the tab title , or < -1", "labels": []}
{"id": 16029, "text": "if component has already been added to this JTabbedPane", "labels": []}
{"id": 16030, "text": "If the pathname argument is null", "labels": []}
{"id": 16031, "text": "If child is null", "labels": []}
{"id": 16032, "text": "If a required system property value cannot be accessed.", "labels": []}
{"id": 16033, "text": "If an I/O error occurs, which is possible because the construction of the canonical pathname may require filesystem queries", "labels": []}
{"id": 16034, "text": "If a required system property value cannot be accessed, or if a security manager exists and its SecurityManager.checkRead(java.io.FileDescriptor) method denies read access to the file", "labels": []}
{"id": 16035, "text": "If a security manager exists and its SecurityManager.checkRead(java.lang.String) method denies read access to the file", "labels": []}
{"id": 16036, "text": "If a security manager exists and its SecurityManager.checkWrite(java.lang.String) method denies write access to the file", "labels": []}
{"id": 16037, "text": "If a security manager exists and its SecurityManager.checkRead(java.lang.String) method denies read access to the file or directory", "labels": []}
{"id": 16038, "text": "If an I/O error occurred", "labels": []}
{"id": 16039, "text": "If a security manager exists and its SecurityManager.checkDelete(java.lang.String) method denies delete access to the file", "labels": []}
{"id": 16040, "text": "If a security manager exists and its SecurityManager.checkRead(String) method denies read access to the directory", "labels": []}
{"id": 16041, "text": "If a security manager exists and its SecurityManager.checkRead(java.lang.String) method does not permit verification of the existence of the named directory and all necessary parent directories; or if the SecurityManager.checkWrite(java.lang.String) method does not permit the named directory and all necessary parent directories to be created", "labels": []}
{"id": 16042, "text": "If a security manager exists and its SecurityManager.checkWrite(java.lang.String) method denies write access to either the old or new pathnames", "labels": []}
{"id": 16043, "text": "If parameter dest is null", "labels": []}
{"id": 16044, "text": "If the argument is negative", "labels": []}
{"id": 16045, "text": "If a security manager exists and its SecurityManager.checkWrite(java.lang.String) method denies write access to the named file", "labels": []}
{"id": 16046, "text": "If a security manager exists and its SecurityManager.checkExec(java.lang.String) method denies execute access to the file", "labels": []}
{"id": 16047, "text": "If a security manager has been installed and it denies RuntimePermission(\"getFileSystemAttributes\") or its SecurityManager.checkRead(String) method denies read access to the file named by this abstract pathname", "labels": []}
{"id": 16048, "text": "If the prefix argument contains fewer than three characters", "labels": []}
{"id": 16049, "text": "If a file could not be created", "labels": []}
{"id": 16050, "text": "If a security manager exists and its SecurityManager.checkWrite(java.lang.String) method does not allow a file to be created", "labels": []}
{"id": 16051, "text": "if a Path object cannot be constructed from the abstract path (see FileSystem.getPath)", "labels": []}
{"id": 16052, "text": "if value is < 0 or > 1", "labels": []}
{"id": 16053, "text": "if the specified location is < 0 or > 1.0", "labels": []}
{"id": 16054, "text": "if the constraints object does not match an existing component", "labels": []}
{"id": 16055, "text": "if a database access error occurs or this method is called on a closed connection", "labels": []}
{"id": 16056, "text": "if a database access error occurs, setAutoCommit(true) is called while participating in a distributed transaction, or this method is called on a closed connection", "labels": []}
{"id": 16057, "text": "if a database access error occurs, this method is called while participating in a distributed transaction, if this method is called on a closed connection or this Connection object is in auto-commit mode", "labels": []}
{"id": 16058, "text": "if a database access error occurs, this method is called while participating in a distributed transaction, this method is called on a closed connection or this Connection object is in auto-commit mode", "labels": []}
{"id": 16059, "text": "if a database access error occurs, this method is called on a closed connection or this method is called during a transaction", "labels": []}
{"id": 16060, "text": "if a database access error occurs, this method is called on a closed connection or the given parameter is not one of the Connection constants", "labels": []}
{"id": 16061, "text": "if a database access error occurs, this method is called on a closed connection or the given parameter is not a java.util.Map object", "labels": []}
{"id": 16062, "text": "if a database access error occurs, this method is called while participating in a distributed transaction, this method is called on a closed connection or this Connection object is currently in auto-commit mode", "labels": []}
{"id": 16063, "text": "if a database access error occurs, this method is called while participating in a distributed transaction, this method is called on a closed connection, the Savepoint object is no longer valid, or this Connection object is currently in auto-commit mode", "labels": []}
{"id": 16064, "text": "if a database access error occurs, this method is called on a closed connection or the given Savepoint object is not a valid savepoint in the current transaction", "labels": []}
{"id": 16065, "text": "if a database access error occurs, this method is called on a closed connection or the given parameter is not a Statement constant indicating whether auto-generated keys should be returned", "labels": []}
{"id": 16066, "text": "if the value supplied for timeout is less than 0", "labels": []}
{"id": 16067, "text": "if the database server returns an error while setting the client info value on the database server or this method is called on a closed connection", "labels": []}
{"id": 16068, "text": "if the database server returns an error while setting the clientInfo values on the database server or this method is called on a closed connection", "labels": []}
{"id": 16069, "text": "if the database server returns an error when fetching the client info value from the database or this method is called on a closed connection", "labels": []}
{"id": 16070, "text": "if the database server returns an error when fetching the client info values from the database or this method is called on a closed connection", "labels": []}
{"id": 16071, "text": "if a database error occurs, the JDBC type is not appropriate for the typeName and the conversion is not supported, the typeName is null or this method is called on a closed connection", "labels": []}
{"id": 16072, "text": "if a database access error occurs or the executor is null,", "labels": []}
{"id": 16073, "text": "if a security manager exists and its checkPermission method denies calling abort", "labels": []}
{"id": 16074, "text": "if a database access error occurs, this method is called on a closed connection, the executor is null, or the value specified for seconds is less than 0.", "labels": []}
{"id": 16075, "text": "if a security manager exists and its checkPermission method denies calling setNetworkTimeout.", "labels": []}
{"id": 16076, "text": "if a database access error occurs or this method is called on a closed Connection", "labels": []}
{"id": 16077, "text": "if an error occurs while performing this validation; a superSharedingKey is specified without a shardingKey; this method is called on a closed connection; or the timeout value is negative.", "labels": []}
{"id": 16078, "text": "if the driver does not support sharding", "labels": []}
{"id": 16079, "text": "if there is an error while performing this validation; this method is called on a closed connection; or the timeout value is negative.", "labels": []}
{"id": 16080, "text": "if either name or value is null", "labels": []}
{"id": 16081, "text": "if attributes is null", "labels": []}
{"id": 16082, "text": "if this request has been deleted.", "labels": []}
{"id": 16083, "text": "if this is a StepRequest, val is true, and the thread named in the request has died or is not yet started.", "labels": []}
{"id": 16084, "text": "if count is less than one.", "labels": []}
{"id": 16085, "text": "Suspend policy may only be set in disabled requests.", "labels": []}
{"id": 16086, "text": "if the policy argument contains an illegal value.", "labels": []}
{"id": 16087, "text": "may be thrown if the socket cannot be connected to the remote destination", "labels": []}
{"id": 16088, "text": "if there are I/O errors while reading from the underlying InputStream", "labels": []}
{"id": 16089, "text": "if name does not correspond to a serializable field", "labels": []}
{"id": 16090, "text": "if mimeType is invalid or if the class is not successfully loaded", "labels": []}
{"id": 16091, "text": "if mimeType is null", "labels": []}
{"id": 16092, "text": "if the class is not loaded", "labels": []}
{"id": 16093, "text": "if mimeType is invalid", "labels": []}
{"id": 16094, "text": "if class is not found", "labels": []}
{"id": 16095, "text": "if the representation class is not one of the seven listed above", "labels": []}
{"id": 16096, "text": "if the Transferable has null data", "labels": []}
{"id": 16097, "text": "if this flavor's representation is java.io.InputStream, java.nio.ByteBuffer, or [B and this flavor's encoding is not supported by this implementation of the Java platform", "labels": []}
{"id": 16098, "text": "if the Transferable does not support this flavor", "labels": []}
{"id": 16099, "text": "if the data cannot be read because of an I/O error", "labels": []}
{"id": 16100, "text": "for normal exception occurrences", "labels": []}
{"id": 16101, "text": "if remote communication with the registry failed; if exception is a ServerException containing an AccessException, then the registry denies the caller access to perform this operation (if originating from a non-local host, for example)", "labels": []}
{"id": 16102, "text": "if this registry is local and it denies the caller access to perform this operation", "labels": []}
{"id": 16103, "text": "if name is null, or if obj is null", "labels": []}
{"id": 16104, "text": "the exception to throw from the method invocation on the proxy instance.", "labels": []}
{"id": 16105, "text": "The exception's type must be assignable either to any of the exception types declared in the throws clause of the interface method or to the unchecked exception types java.lang.RuntimeException or java.lang.Error.", "labels": []}
{"id": 16106, "text": "If a checked exception is thrown by this method that is not assignable to any of the exception types declared in the throws clause of the interface method, then an UndeclaredThrowableException containing the exception that was thrown by this method will be thrown by the method invocation on the proxy instance.", "labels": []}
{"id": 16107, "text": "if output is not an instance of the correct class or is null.", "labels": []}
{"id": 16108, "text": "if a cache file is needed, but cacheDir is non-null and is not a directory.", "labels": []}
{"id": 16109, "text": "If the stream is closed, or an I/O error occurs", "labels": []}
{"id": 16110, "text": "If there are fewer than length ints remaining in this buffer", "labels": []}
{"id": 16111, "text": "If there is insufficient space in this buffer for the remaining ints in the source buffer", "labels": []}
{"id": 16112, "text": "If the group parameter is not a multicast address, or the group parameter is an address type that is not supported by this channel", "labels": []}
{"id": 16113, "text": "If the channel already has source-specific membership of the group on the interface", "labels": []}
{"id": 16114, "text": "If the channel's socket is not an Internet Protocol socket, or the platform does not support multicasting", "labels": []}
{"id": 16115, "text": "If a security manager is set, and its checkMulticast method denies access to the multicast group", "labels": []}
{"id": 16116, "text": "If the group parameter is not a multicast address, the source parameter is not a unicast address, the group parameter is an address type that is not supported by this channel, or the source parameter is not the same address type as the group", "labels": []}
{"id": 16117, "text": "If the channel is currently a member of the group on the given interface to receive all datagrams", "labels": []}
{"id": 16118, "text": "If the channel's socket is not an Internet Protocol socket, or source filtering is not supported, or the platform does not support multicasting", "labels": []}
{"id": 16119, "text": "if the type of validateContext is not compatible with this XMLSignature", "labels": []}
{"id": 16120, "text": "if an unexpected error occurs during validation that prevented the validation operation from completing", "labels": []}
{"id": 16121, "text": "if the type of signContext is not compatible with this XMLSignature", "labels": []}
{"id": 16122, "text": "if signContext is null", "labels": []}
{"id": 16123, "text": "if an exception occurs while marshalling", "labels": []}
{"id": 16124, "text": "if an unexpected exception occurs while generating the signature", "labels": []}
{"id": 16125, "text": "If a problem was encountered while removing the listener.", "labels": []}
{"id": 16126, "text": "If the context's behavior in this regard cannot be determined.", "labels": []}
{"id": 16127, "text": "if threshold is negative or greater than the maximum amount of memory for this memory pool if defined.", "labels": []}
{"id": 16128, "text": "if this memory pool does not support a usage threshold.", "labels": []}
{"id": 16129, "text": "if this memory pool does not support a collection usage threshold.", "labels": []}
{"id": 16130, "text": "if dscp, trigger, or t are null, or if dragImage is non-null and offset is null", "labels": []}
{"id": 16131, "text": "if a DragSourceListener has already been added", "labels": []}
{"id": 16132, "text": "if the logger name is null.", "labels": []}
{"id": 16133, "text": "if there are IO problems reading the configuration.", "labels": []}
{"id": 16134, "text": "if there are problems reading from the stream, or the given stream is not in the properties file format.", "labels": []}
{"id": 16135, "text": "if a security manager exists and if the caller does not have LoggingPermission(\"control\"), or does not have the permissions required to set up the configuration (e.g.", "labels": []}
{"id": 16136, "text": "if mapper returns a null function when invoked.", "labels": []}
{"id": 16137, "text": "if there are problems reading from the logging configuration file.", "labels": []}
{"id": 16138, "text": "if ins is null or if mapper returns a null function when invoked.", "labels": []}
{"id": 16139, "text": "if the listener is null.", "labels": []}
{"id": 16140, "text": "containing the following major error codes: GSSException.NO_CRED GSSException.FAILURE", "labels": []}
{"id": 16141, "text": "if messageType is not either INFORMATION, WARNING, or ERROR, if optionType is not either YES_NO_OPTION, YES_NO_CANCEL_OPTION, or OK_CANCEL_OPTION, or if defaultOption does not correspond to one of the options in optionType.", "labels": []}
{"id": 16142, "text": "if messageType is not either INFORMATION, WARNING, or ERROR, if options is null, if options has a length of 0, if any element from options is null, if any element from options has a length of 0, or if defaultOption does not lie within the array boundaries of options.", "labels": []}
{"id": 16143, "text": "if prompt is null, if prompt has a length of 0, if messageType is not either INFORMATION, WARNING, or ERROR, if optionType is not either YES_NO_OPTION, YES_NO_CANCEL_OPTION, or OK_CANCEL_OPTION, or if defaultOption does not correspond to one of the options in optionType.", "labels": []}
{"id": 16144, "text": "if prompt is null, if prompt has a length of 0, if messageType is not either INFORMATION, WARNING, or ERROR, if options is null, if options has a length of 0, if any element from options is null, if any element from options has a length of 0, or if defaultOption does not lie within the array boundaries of options.", "labels": []}
{"id": 16145, "text": "if position is less than zero", "labels": []}
{"id": 16146, "text": "if object did not supply all mandatory attributes", "labels": []}
{"id": 16147, "text": "if an intermediate context does not exist", "labels": []}
{"id": 16148, "text": "if the name is bound but does not name a context, or does not name a context of the appropriate type", "labels": []}
{"id": 16149, "text": "if the named context is not empty", "labels": []}
{"id": 16150, "text": "if creation of the subcontext requires specification of mandatory attributes", "labels": []}
{"id": 16151, "text": "if the naming system does not have the notion of a full name", "labels": []}
{"id": 16152, "text": "if the given decimalPattern or the compactPatterns array contains an invalid pattern or if a null appears in the array of compact patterns", "labels": []}
{"id": 16153, "text": "when the Format cannot format the given object", "labels": []}
{"id": 16154, "text": "if rounding is needed with rounding mode being set to RoundingMode.UNNECESSARY", "labels": []}
{"id": 16155, "text": "if text or pos is null", "labels": []}
{"id": 16156, "text": "if newValue is negative or larger than 127", "labels": []}
{"id": 16157, "text": "if the number of bits in bits is less than 1", "labels": []}
{"id": 16158, "text": "if the length of the bit array is less than the number of color or alpha components in this ColorModel, or if the transparency is not a valid value.", "labels": []}
{"id": 16159, "text": "if the sum of the number of bits in bits is less than 1 or if any of the elements in bits is less than 0.", "labels": []}
{"id": 16160, "text": "if componentIdx is greater than the number of components or less than zero", "labels": []}
{"id": 16161, "text": "if the number of bits array is null", "labels": []}
{"id": 16162, "text": "if this method is not supported by this ColorModel", "labels": []}
{"id": 16163, "text": "If the component values for this ColorModel are not conveniently representable in the unnormalized form.", "labels": []}
{"id": 16164, "text": "if the constructor of this ColorModel called the super(bits) constructor, but did not override this method.", "labels": []}
{"id": 16165, "text": "if this method is unable to determine the number of bits per component", "labels": []}
{"id": 16166, "text": "if component values for this ColorModel are not conveniently representable in the unnormalized form", "labels": []}
{"id": 16167, "text": "if this method has not been implemented for this ColorModel", "labels": []}
{"id": 16168, "text": "if the type has not yet been created or loaded through the appropriate class loader.", "labels": []}
{"id": 16169, "text": "if there is no line number information for this (non-native, non-abstract) method.", "labels": []}
{"id": 16170, "text": "Or if sourceName is non-null and source name information is not present.", "labels": []}
{"id": 16171, "text": "if there is no line number information for this method.", "labels": []}
{"id": 16172, "text": "if there is no variable information for this method.", "labels": []}
{"id": 16173, "text": "Generally, local variable information is not available for native or abstract methods (that is, their argument name information is not available), thus they will throw this exception.", "labels": []}
{"id": 16174, "text": "if the target virtual machine does not support the retrieval of bytecodes.", "labels": []}
{"id": 16175, "text": "if a database access error occurs or any of the properties necessary for making a connection and creating a statement have not been set", "labels": []}
{"id": 16176, "text": "if the source names are not known.", "labels": []}
{"id": 16177, "text": "For arrays (ArrayType) and primitive classes, AbsentInformationException is always thrown.", "labels": []}
{"id": 16178, "text": "if the extension is not specified", "labels": []}
{"id": 16179, "text": "if the target virtual machine does not support this operation - see canGetSourceDebugExtension(),", "labels": []}
{"id": 16180, "text": "if a Mirror argument and this mirror do not belong to the same VirtualMachine.", "labels": []}
{"id": 16181, "text": "if there is no line number information for this class and there are non-native, non-abstract executable members of this class.", "labels": []}
{"id": 16182, "text": "if there is no line number information for this class.", "labels": []}
{"id": 16183, "text": "if maxInstances is less than zero.", "labels": []}
{"id": 16184, "text": "if the target virtual machine does not support this operation - see canGetClassFileVersion()", "labels": []}
{"id": 16185, "text": "if the target virtual machine does not support this operation - see canGetConstantPool()", "labels": []}
{"id": 16186, "text": "if the redirect does not correspond to a valid source of data, that is, has type WRITE or APPEND", "labels": []}
{"id": 16187, "text": "if the redirect does not correspond to a valid destination of data, that is, has type READ", "labels": []}
{"id": 16188, "text": "if an element of the command list is null", "labels": []}
{"id": 16189, "text": "if the command is an empty list (has size 0)", "labels": []}
{"id": 16190, "text": "if a security manager exists and its checkExec method doesn't allow creation of the subprocess, or the standard input to the subprocess was redirected from a file and the security manager's checkRead method denies read access to the file, or the standard output or standard error of the subprocess was redirected to a file and the security manager's checkWrite method denies write access to the file", "labels": []}
{"id": 16191, "text": "if an element of the command list is null or if an element of the ProcessBuilder list is null or the builders argument is null", "labels": []}
{"id": 16192, "text": "If the operating system does not support the creation of processes", "labels": []}
{"id": 16193, "text": "if any of the parameters is null.", "labels": []}
{"id": 16194, "text": "if elementName is null or is not a legal element name for this format.", "labels": []}
{"id": 16195, "text": "if the given attribute is not defined as an enumeration.", "labels": []}
{"id": 16196, "text": "if the given attribute is not defined as a range.", "labels": []}
{"id": 16197, "text": "if the given attribute is not defined as a list.", "labels": []}
{"id": 16198, "text": "if the named element cannot contain an object value (i.e., if getObjectValueType(elementName) == VALUE_NONE).", "labels": []}
{"id": 16199, "text": "if the Object is not defined as an enumeration.", "labels": []}
{"id": 16200, "text": "if the Object is not defined as a range.", "labels": []}
{"id": 16201, "text": "if the Object is not an array.", "labels": []}
{"id": 16202, "text": "if unable to convert to a Period", "labels": []}
{"id": 16203, "text": "if the amount of years, months or days exceeds an int", "labels": []}
{"id": 16204, "text": "if the text cannot be parsed to a period", "labels": []}
{"id": 16205, "text": "if the subregion is outside of the raster bounds.", "labels": []}
{"id": 16206, "text": "if w or h is less than or equal to zero, or computing any of parentX + w, parentY + h, childMinX + w, or childMinY + h results in integer overflow", "labels": []}
{"id": 16207, "text": "if the coordinates are not in bounds, or if inData is too small to hold the input.", "labels": []}
{"id": 16208, "text": "if inRaster is null.", "labels": []}
{"id": 16209, "text": "if srcRaster is null.", "labels": []}
{"id": 16210, "text": "if iArray is null.", "labels": []}
{"id": 16211, "text": "if fArray is null.", "labels": []}
{"id": 16212, "text": "if dArray is null.", "labels": []}
{"id": 16213, "text": "if the service type is not accessible to the caller or the caller is in an explicit module and its module descriptor does not declare that it uses service", "labels": []}
{"id": 16214, "text": "If a provider class cannot be loaded for any of the reasons specified in the Errors section above.", "labels": []}
{"id": 16215, "text": "If there are fewer than length longs remaining in this buffer", "labels": []}
{"id": 16216, "text": "If there is insufficient space in this buffer for the remaining longs in the source buffer", "labels": []}
{"id": 16217, "text": "if the target VM cannot provide information on synthetic attributes.", "labels": []}
{"id": 16218, "text": "if there is a fatal error writing the event", "labels": []}
{"id": 16219, "text": "if some aspect of this key or value prevents it from being stored in this context", "labels": []}
{"id": 16220, "text": "if the same pathname has already been created, the same type has already been created, the name is otherwise not valid for the entity requested to being created, if the target module cannot be determined, if the target module is not writable, or a module is specified when the environment doesn't support modules.", "labels": []}
{"id": 16221, "text": "if the file cannot be created", "labels": []}
{"id": 16222, "text": "if the same pathname has already been created, the same type has already been created, the name is not valid for a type, if the target module cannot be determined, if the target module is not writable, or a module is specified when the environment doesn't support modules.", "labels": []}
{"id": 16223, "text": "if the same pathname has already been created, if the target module cannot be determined, or if the target module is not writable, or if an explicit target module is specified and the location does not support it.", "labels": []}
{"id": 16224, "text": "if moduleAndPkg is ill-formed", "labels": []}
{"id": 16225, "text": "if relativeName is not relative", "labels": []}
{"id": 16226, "text": "if the same pathname has already been opened for writing, if the source module cannot be determined, or if the target module is not writable, or if an explicit target module is specified and the location does not support it.", "labels": []}
{"id": 16227, "text": "if the file cannot be opened", "labels": []}
{"id": 16228, "text": "if access is denied.", "labels": []}
{"id": 16229, "text": "if AbstractQueuedLongSynchronizer.isHeldExclusively() returns false", "labels": []}
{"id": 16230, "text": "if the class file contains a MethodParameters attribute that is improperly formatted.", "labels": []}
{"id": 16231, "text": "if the system does not support at least one line matching the specified Line.Info object through any installed mixer", "labels": []}
{"id": 16232, "text": "if a clip object is not available due to resource restrictions", "labels": []}
{"id": 16233, "text": "if a clip object is not available due to security restrictions", "labels": []}
{"id": 16234, "text": "if the system does not support at least one clip instance through any installed mixer", "labels": []}
{"id": 16235, "text": "if a clip is not available from this mixer due to resource restrictions", "labels": []}
{"id": 16236, "text": "if a clip is not available from this mixer due to security restrictions", "labels": []}
{"id": 16237, "text": "if the system does not support at least one clip through the specified mixer", "labels": []}
{"id": 16238, "text": "if a matching source data line is not available due to resource restrictions", "labels": []}
{"id": 16239, "text": "if a matching source data line is not available due to security restrictions", "labels": []}
{"id": 16240, "text": "if the system does not support at least one source data line supporting the specified audio format through any installed mixer", "labels": []}
{"id": 16241, "text": "if a matching source data line is not available from the specified mixer due to resource restrictions", "labels": []}
{"id": 16242, "text": "if a matching source data line is not available from the specified mixer due to security restrictions", "labels": []}
{"id": 16243, "text": "if the specified mixer does not support at least one source data line supporting the specified audio format", "labels": []}
{"id": 16244, "text": "if a matching target data line is not available due to resource restrictions", "labels": []}
{"id": 16245, "text": "if a matching target data line is not available due to security restrictions", "labels": []}
{"id": 16246, "text": "if the system does not support at least one target data line supporting the specified audio format through any installed mixer", "labels": []}
{"id": 16247, "text": "if a matching target data line is not available from the specified mixer due to resource restrictions", "labels": []}
{"id": 16248, "text": "if a matching target data line is not available from the specified mixer due to security restrictions", "labels": []}
{"id": 16249, "text": "if the specified mixer does not support at least one target data line supporting the specified audio format", "labels": []}
{"id": 16250, "text": "if an input/output exception occurs", "labels": []}
{"id": 16251, "text": "if the runtime type of any element in this collection is not assignable to the runtime component type of the generated array", "labels": []}
{"id": 16252, "text": "if the generator function is null", "labels": []}
{"id": 16253, "text": "if the specified filter is null", "labels": []}
{"id": 16254, "text": "if elements cannot be removed from this collection.", "labels": []}
{"id": 16255, "text": "Implementations may throw this exception if a matching element cannot be removed or if, in general, removal is not supported.", "labels": []}
{"id": 16256, "text": "TYPE_ERR: raised if resultType is not NUMBER_TYPE.", "labels": []}
{"id": 16257, "text": "TYPE_ERR: raised if resultType is not ANY_UNORDERED_NODE_TYPE or FIRST_ORDERED_NODE_TYPE.", "labels": []}
{"id": 16258, "text": "TYPE_ERR: raised if resultType is not UNORDERED_NODE_ITERATOR_TYPE or ORDERED_NODE_ITERATOR_TYPE.", "labels": []}
{"id": 16259, "text": "TYPE_ERR: raised if resultType is not UNORDERED_NODE_SNAPSHOT_TYPE or ORDERED_NODE_SNAPSHOT_TYPE.", "labels": []}
{"id": 16260, "text": "if a value is found, but does not parse as a Long", "labels": []}
{"id": 16261, "text": "if any of: headerMap, a key or value in the given map, or an entry in the map's value list, or filter, is null", "labels": []}
{"id": 16262, "text": "if the given headerMap contains any two keys that are equal ( without regard to case ); or if the given map contains any key whose length, after trimming whitespaces, is 0", "labels": []}
{"id": 16263, "text": "When prefix is null", "labels": []}
{"id": 16264, "text": "When namespaceURI is null", "labels": []}
{"id": 16265, "text": "if the current thread is interrupted while acquiring the lock (and interruption of lock acquisition is supported)", "labels": []}
{"id": 16266, "text": "if this Lock implementation does not support conditions", "labels": []}
{"id": 16267, "text": "if the nth value does not exist.", "labels": []}
{"id": 16268, "text": "if index is invalid (see addImpl(java.awt.Component, java.lang.Object, int) for details)", "labels": []}
{"id": 16269, "text": "if comp is one of the container's parents", "labels": []}
{"id": 16270, "text": "if index is not in the range [0, getComponentCount()] for moving between containers, or not in the range [0, getComponentCount()-1] for moving inside a container", "labels": []}
{"id": 16271, "text": "if adding a container to itself", "labels": []}
{"id": 16272, "text": "if adding a Window to a container", "labels": []}
{"id": 16273, "text": "if index is invalid; if comp is a child of this container, the valid range is [-1, getComponentCount()-1]; if component is not a child of this container, the valid range is [-1, getComponentCount()]", "labels": []}
{"id": 16274, "text": "if comp is an ancestor of this container", "labels": []}
{"id": 16275, "text": "if index is not in range [0, getComponentCount()-1]", "labels": []}
{"id": 16276, "text": "if id is not one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS, or if keystrokes contains null, or if any keystroke represents a KEY_TYPED event, or if any keystroke already maps to another focus traversal operation for this Container", "labels": []}
{"id": 16277, "text": "if threshhold < 0", "labels": []}
{"id": 16278, "text": "if the array contains an attribute that cannot be set atomically when creating the file", "labels": []}
{"id": 16279, "text": "if a file of that name already exists (optional specific exception)", "labels": []}
{"id": 16280, "text": "if an I/O error occurs or the parent directory does not exist", "labels": []}
{"id": 16281, "text": "if the array contains an attribute that cannot be set atomically when creating the directory", "labels": []}
{"id": 16282, "text": "if a directory could not otherwise be created because a file of that name already exists (optional specific exception)", "labels": []}
{"id": 16283, "text": "if dir exists but is not a directory (optional specific exception)", "labels": []}
{"id": 16284, "text": "If dir is not an absolute path then its toAbsolutePath may need to be invoked to get its absolute path.", "labels": []}
{"id": 16285, "text": "if the prefix or suffix parameters cannot be used to generate a candidate file name", "labels": []}
{"id": 16286, "text": "if an I/O error occurs or dir does not exist", "labels": []}
{"id": 16287, "text": "if the prefix cannot be used to generate a candidate directory name", "labels": []}
{"id": 16288, "text": "In the case of the default provider, and a security manager is installed, the checkWrite method is invoked to check write access when creating the directory.", "labels": []}
{"id": 16289, "text": "the REPLACE_EXISTING option is specified but the file cannot be replaced because it is a non-empty directory, or the source is a non-empty directory containing entries that would be required to be moved (optional specific exceptions)", "labels": []}
{"id": 16290, "text": "If a security manager is installed and it denies an unspecified permission required by a file type detector implementation.", "labels": []}
{"id": 16291, "text": "if an attributes of the given type are not supported", "labels": []}
{"id": 16292, "text": "If this method is invoked to read security sensitive attributes then the security manager may be invoke to check for additional permissions.", "labels": []}
{"id": 16293, "text": "if the attribute view is not available", "labels": []}
{"id": 16294, "text": "if the attribute name is not specified, or is not recognized, or the attribute value is of the correct type but has an inappropriate value", "labels": []}
{"id": 16295, "text": "if the attribute value is not of the expected type or is a collection containing elements that are not of the expected type", "labels": []}
{"id": 16296, "text": "If this method is invoked to set security sensitive attributes then the security manager may be invoked to check for additional permissions.", "labels": []}
{"id": 16297, "text": "if the attribute name is not specified or is not recognized", "labels": []}
{"id": 16298, "text": "If this method is invoked to read security sensitive attributes then the security manager may be invoked to check for additional permissions.", "labels": []}
{"id": 16299, "text": "if no attributes are specified or an unrecognized attribute is specified", "labels": []}
{"id": 16300, "text": "if the associated file system does not support the PosixFileAttributeView", "labels": []}
{"id": 16301, "text": "if the sets contains elements that are not of type PosixFilePermission", "labels": []}
{"id": 16302, "text": "if the maxDepth parameter is negative", "labels": []}
{"id": 16303, "text": "If the security manager denies access to the starting file.", "labels": []}
{"id": 16304, "text": "if an I/O error is thrown by a visitor method", "labels": []}
{"id": 16305, "text": "if an I/O error occurs opening the file", "labels": []}
{"id": 16306, "text": "if an I/O error occurs opening or creating the file", "labels": []}
{"id": 16307, "text": "the REPLACE_EXISTING option is specified but the file cannot be replaced because it is a non-empty directory (optional specific exception) *", "labels": []}
{"id": 16308, "text": "if options contains a copy option that is not supported", "labels": []}
{"id": 16309, "text": "if an I/O error occurs reading from the stream", "labels": []}
{"id": 16310, "text": "if an array of the required size cannot be allocated, for example the file is larger that 2GB", "labels": []}
{"id": 16311, "text": "if an I/O error occurs reading from the file or a malformed or unmappable byte sequence is read", "labels": []}
{"id": 16312, "text": "if the file is extremely large, for example larger than 2GB", "labels": []}
{"id": 16313, "text": "if an I/O error occurs writing to or creating the file", "labels": []}
{"id": 16314, "text": "if an I/O error occurs writing to or creating the file, or the text cannot be encoded using the specified charset", "labels": []}
{"id": 16315, "text": "if an I/O error occurs writing to or creating the file, or the text cannot be encoded as UTF-8", "labels": []}
{"id": 16316, "text": "if an I/O error occurs when opening the directory", "labels": []}
{"id": 16317, "text": "if an I/O error is thrown when accessing the starting file.", "labels": []}
{"id": 16318, "text": "If the path string cannot be converted", "labels": []}
{"id": 16319, "text": "If the parameter does not take the form: syntax:pattern", "labels": []}
{"id": 16320, "text": "If the pattern is invalid", "labels": []}
{"id": 16321, "text": "If the pattern syntax is not known to the implementation", "labels": []}
{"id": 16322, "text": "if the current thread cannot create a thread in the specified thread group", "labels": []}
{"id": 16323, "text": "if the current thread cannot create a thread in the specified thread group or cannot override the context class loader methods.", "labels": []}
{"id": 16324, "text": "if the thread was already started.", "labels": []}
{"id": 16325, "text": "if the current thread cannot modify this thread", "labels": []}
{"id": 16326, "text": "If the priority is not in the range MIN_PRIORITY to MAX_PRIORITY.", "labels": []}
{"id": 16327, "text": "if the current thread cannot modify this thread.", "labels": []}
{"id": 16328, "text": "if ThreadGroup.checkAccess() determines that the current thread cannot access its thread group", "labels": []}
{"id": 16329, "text": "if the value of millis is negative", "labels": []}
{"id": 16330, "text": "if any thread has interrupted the current thread.", "labels": []}
{"id": 16331, "text": "if the value of millis is negative, or the value of nanos is not in the range 0-999999", "labels": []}
{"id": 16332, "text": "if this thread is alive", "labels": []}
{"id": 16333, "text": "if checkAccess() determines that the current thread cannot modify this thread", "labels": []}
{"id": 16334, "text": "if the current thread is not allowed to access this thread.", "labels": []}
{"id": 16335, "text": "if a security manager is present, and the caller's class loader is not null and is not the same as or an ancestor of the context class loader, and the caller does not have the RuntimePermission(\"getClassLoader\")", "labels": []}
{"id": 16336, "text": "if the current thread cannot set the context ClassLoader", "labels": []}
{"id": 16337, "text": "if a security manager exists and its checkPermission method doesn't allow getting the stack trace of thread.", "labels": []}
{"id": 16338, "text": "if a security manager is present and it denies RuntimePermission(\"setDefaultUncaughtExceptionHandler\")", "labels": []}
{"id": 16339, "text": "if the current thread is not allowed to modify this thread.", "labels": []}
